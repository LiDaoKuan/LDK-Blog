{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/butterfly/source/manifest.json","path":"manifest.json","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/custom.css","path":"css/custom.css","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/nav_style.css","path":"css/nav_style.css","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/siderbar.css","path":"css/siderbar.css","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/butterfly-icon.png","path":"img/butterfly-icon.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/error-page.png","path":"img/error-page.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"source/background/001.webp","path":"background/001.webp","modified":1,"renderable":0},{"_id":"source/background/002.webp","path":"background/002.webp","modified":1,"renderable":0},{"_id":"source/background/003.webp","path":"background/003.webp","modified":1,"renderable":0},{"_id":"source/background/004.webp","path":"background/004.webp","modified":1,"renderable":0},{"_id":"source/background/005.webp","path":"background/005.webp","modified":1,"renderable":0},{"_id":"source/background/006.webp","path":"background/006.webp","modified":1,"renderable":0},{"_id":"source/background/007.webp","path":"background/007.webp","modified":1,"renderable":0},{"_id":"source/background/008.webp","path":"background/008.webp","modified":1,"renderable":0},{"_id":"source/background/009.webp","path":"background/009.webp","modified":1,"renderable":0},{"_id":"source/background/010.webp","path":"background/010.webp","modified":1,"renderable":0},{"_id":"source/background/011.webp","path":"background/011.webp","modified":1,"renderable":0},{"_id":"source/background/012.webp","path":"background/012.webp","modified":1,"renderable":0},{"_id":"source/background/013.webp","path":"background/013.webp","modified":1,"renderable":0},{"_id":"source/background/014.webp","path":"background/014.webp","modified":1,"renderable":0},{"_id":"source/background/015.webp","path":"background/015.webp","modified":1,"renderable":0},{"_id":"source/background/016.webp","path":"background/016.webp","modified":1,"renderable":0},{"_id":"source/background/017.webp","path":"background/017.webp","modified":1,"renderable":0},{"_id":"source/background/018.webp","path":"background/018.webp","modified":1,"renderable":0},{"_id":"source/background/021.webp","path":"background/021.webp","modified":1,"renderable":0},{"_id":"source/background/020.webp","path":"background/020.webp","modified":1,"renderable":0},{"_id":"source/background/022.webp","path":"background/022.webp","modified":1,"renderable":0},{"_id":"source/background/019.webp","path":"background/019.webp","modified":1,"renderable":0},{"_id":"source/background/023.webp","path":"background/023.webp","modified":1,"renderable":0},{"_id":"source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/manifest.json","hash":"1b0fae97891c808f83e85ac40f28114167e18071","modified":1757817371054},{"_id":"source/_data/link.yml","hash":"62b326e208283e3623d4b609c4bb52dc540de645","modified":1757817371008},{"_id":"source/_posts/hello-world.md","hash":"ecd69f09308376f864b958b0d638fe8ed2ea52f0","modified":1757817371009},{"_id":"source/about/index.md","hash":"21f484f8a0a67640ef721642925d255d9838b9f8","modified":1757817371049},{"_id":"source/categories/index.md","hash":"2c2f4213c2293b4c023f5148b3d489ec1b5ae816","modified":1757817371053},{"_id":"source/background/003.webp","hash":"06960efae139f508127ccdc9984713631fa4ebf4","modified":1757817371050},{"_id":"source/link/index.md","hash":"f26ba3bd281ff03303b1412da974295bca599c3f","modified":1757817371054},{"_id":"source/tags/index.md","hash":"5101bd5ca18599a7dab9a55ac25d45aed849f827","modified":1757817371054},{"_id":"source/_posts/C-Plus-Plus/新标准.md","hash":"f0eec6c5e9e6a01242d5284534526b57f1eee73e","modified":1757817371009},{"_id":"source/_posts/C-Plus-Plus/语法.md","hash":"cbb8a632a9fda774818d53977b6b2e0fa214abb3","modified":1757817371009},{"_id":"source/_posts/LeetCode/leetcode-1477.md","hash":"856fe2aea6d6061ca7bee24a005400a26abc6815","modified":1757817371009},{"_id":"source/_posts/LeetCode/leetcode-31.md","hash":"dfc5414c67026b5f68c4b63f2ed058a7a2d81157","modified":1757817371009},{"_id":"source/_posts/C语言/标准库.md","hash":"411027e3dfa8e189d445b46e47aff3e055b2c4ce","modified":1757817371009},{"_id":"source/_posts/主题样例/Mdmdt主题演示demo.md","hash":"ff5c977a9bb87373612479fa34a3de6bafe08c8c","modified":1757817371009},{"_id":"source/_posts/主题样例/readme.en.md","hash":"97d8b98b24275eae36b435f9a70855107090969e","modified":1757817371047},{"_id":"source/_posts/主题样例/readme.md","hash":"4c8b9493e6335abda303f4dcef32800c4305104e","modified":1757817371047},{"_id":"source/_posts/程序/string分割.md","hash":"db8e047c0cb9f488391e674b1daaf590b38314da","modified":1757817371048},{"_id":"source/_posts/程序/获取文件大小.md","hash":"b57bf57466af295580b8e4baedd3c31c96d82f14","modified":1757817371049},{"_id":"source/_posts/算法/SortAlgorithem.md","hash":"2aa7802c3cf99efe9f8df61e2e8dc5d63d1a3dce","modified":1757817371049},{"_id":"source/_posts/网络编程/Linux的IO多路复用.md","hash":"8ecf8c2c6832d85f328be526c754d2c830417788","modified":1757817371049},{"_id":"source/_posts/网络编程/TCP协议和UDP协议.md","hash":"43f33cb129a2c2439e3fc42bcc9caceb94263e32","modified":1757817371049},{"_id":"source/_posts/网络编程/epoll的LT模式和ET模式.md","hash":"2f51f2ad2a59b6f3e8ef43b88ee013332e35d761","modified":1757817371049},{"_id":"source/_posts/网络编程/socket.md","hash":"41a39d1017851c3387474119d0811687aff1fcf5","modified":1757817371049},{"_id":"source/_posts/系统编程/多进程.md","hash":"14c98c74e7cb0349dc8e94b2bba11b0ec275d32a","modified":1757817371049},{"_id":"source/_posts/系统编程/标准IO.md","hash":"5c58526a01c1d8f4f5d9a21e443220ae13f93ccf","modified":1757817371049},{"_id":"source/_posts/系统编程/系统调用.md","hash":"753cfb13457747e0a9bcf35a3721b7348c6c8588","modified":1757817371049},{"_id":"source/_posts/C-Plus-Plus/STL/map.md","hash":"9c9eb7639d584fdcd3eed9b024daef239331e52c","modified":1757817371008},{"_id":"source/_posts/C-Plus-Plus/STL/set.md","hash":"f406db93024013e0567dcd7c6026adf6b8f8e475","modified":1757817371008},{"_id":"source/_posts/C-Plus-Plus/c-plus-plus-14/shared_lock.md","hash":"1a215057d1275fa04844c0411db0d6695180da58","modified":1757817371008},{"_id":"source/_posts/C-Plus-Plus/c-plus-plus-14/shared_timed_mutex.md","hash":"24d97a362f7e20c0419a96719ff88bd7e011f01c","modified":1757817371008},{"_id":"source/_posts/C-Plus-Plus/c-plus-plus-17/nodiscard.md","hash":"c571e31a574436eddc1bd5a3150a711aa53aba33","modified":1757817371008},{"_id":"source/_posts/C-Plus-Plus/对象模型/内存对齐.md","hash":"93bee55a864118b7423ea03801f339a0600d90d9","modified":1757817371008},{"_id":"source/_posts/C-Plus-Plus/并发/内存序.md","hash":"ea442cfd02b5629521c87027bc24c401b8a0b216","modified":1757817371008},{"_id":"source/_posts/C-Plus-Plus/并发/原子操作.md","hash":"0bbb34602771e257b888851da6f523fe03e86531","modified":1757817371009},{"_id":"source/_posts/数据结构/堆/大顶堆.md","hash":"312511d95040b359dcfe546ed26ec6b7f674a731","modified":1757817371048},{"_id":"source/_posts/数据结构/image/image-20250623201450979.png","hash":"5be048a20b3ce5e90993f4af84cc225172c827cd","modified":1757817371048},{"_id":"source/_posts/数据结构/树/BalancedBinarySearchTree(AVL).md","hash":"9af359ae31e3fca053fb41fa2e026d31a27aa69b","modified":1757817371048},{"_id":"source/_posts/数据结构/树/BinarySearchTree.md","hash":"1b6f675e6eb8fd99cbddae6db2279de11e57f1d4","modified":1757817371048},{"_id":"source/_posts/数据结构/树/BinaryTree.md","hash":"e9f79b7ce456743e8f186dbdfc458d0421712edc","modified":1757817371048},{"_id":"source/_posts/数据结构/树/CompleteBinaryTree.md","hash":"3320cbb517759fa3e323f5794eed2fcd80f74260","modified":1757817371048},{"_id":"source/_posts/数据结构/树/FullBinaryTree.md","hash":"fae1b50c148936ce6d6295b8a78607db152228cc","modified":1757817371048},{"_id":"source/_posts/数据结构/树/RBTree.md","hash":"9baba695cc268a01b68cccccc58905d4bc6bc7a2","modified":1757817371048},{"_id":"source/background/002.webp","hash":"c868b30959bb0d3a516aa99da2937fe7df128ac9","modified":1757817371050},{"_id":"source/background/007.webp","hash":"0834f5bb7c5ced6ef4a91f0f4fe3c10a4aa75980","modified":1757817371050},{"_id":"source/background/009.webp","hash":"1fede8dfffcc436f782645439bcd75106105036d","modified":1757817371050},{"_id":"source/background/010.webp","hash":"0b23ea05d29947ca7315e0db5853c0ba4a9295b2","modified":1757817371050},{"_id":"source/background/017.webp","hash":"6ff3d4c82f986f3a72a4a05e26a0ba72cdc1152d","modified":1757817371052},{"_id":"source/background/018.webp","hash":"c7bc1213ba066379d2806e0a62606a888d489085","modified":1757817371052},{"_id":"source/background/023.webp","hash":"ea07c5ff2b42f90d29c7c25dd5e47e669a93f7a6","modified":1757817371053},{"_id":"source/background/004.webp","hash":"0a65570bf47864b2a968c3a1aac818e518723daf","modified":1757817371050},{"_id":"source/background/006.webp","hash":"f45e2e8122235d3add61413d359d61a3acbb7019","modified":1757817371050},{"_id":"source/background/008.webp","hash":"2e5dedf619a46218b2e02eac46669cc4eb8812da","modified":1757817371050},{"_id":"source/background/012.webp","hash":"3b93a4dcb2cad91ad0cbf8fae45cace8cc337511","modified":1757817371051},{"_id":"source/background/021.webp","hash":"657eb2ca190332268b894841a8d403388b5a31b4","modified":1757817371053},{"_id":"source/background/022.webp","hash":"71140891318eaada83a3a796a75033dad8239a3b","modified":1757817371053},{"_id":"source/_posts/网络编程/image/Pasted_image_20250610210518.png","hash":"5592a750636ca7af16ad643c6d127ddde76e0fe2","modified":1757817371049},{"_id":"source/background/001.webp","hash":"6f59a612a698ad124bbba4902d407bc3d1ba511a","modified":1757817371049},{"_id":"source/background/005.webp","hash":"d8fb95cb3fe8c94b5a5844d03dc971571212dc4a","modified":1757817371050},{"_id":"source/background/013.webp","hash":"369be7f60db7f5795e64723d64bf7cc86988b523","modified":1757817371051},{"_id":"source/background/016.webp","hash":"9dc032191e3b97bfa432231a98ad2a7dedc783fd","modified":1757817371052},{"_id":"source/background/020.webp","hash":"aa831e0d86eb2b939b317ebb55947358a2b52654","modified":1757817371053},{"_id":"source/_posts/主题样例/img/mdmdt-ui-2.png","hash":"1d624549fd065c08864b318a57a073d721b3f7b2","modified":1757817371036},{"_id":"source/background/011.webp","hash":"bd913f1948c2c75b1cb93ff2937350926a3c6cdb","modified":1757817371051},{"_id":"source/background/019.webp","hash":"103165a1d40e25eeaf726ec0075da0341986be12","modified":1757817371053},{"_id":"themes/butterfly/.gitignore","hash":"a1373164627c9a3e36c8eec1ad71b4b269800682","modified":1757817371056},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1757817371056},{"_id":"themes/butterfly/README_CN.md","hash":"92e45255b8725f0a00450c88fcfd51ec61e1db67","modified":1757817371056},{"_id":"themes/butterfly/README.md","hash":"e1b9096ae0c4e5ef0a911aec05dbad4a3aae3173","modified":1757817371056},{"_id":"themes/butterfly/.github/FUNDING.yml","hash":"da5e77f5e0cdb7e11b36546fb6796d10e3dfbe5d","modified":1757817371055},{"_id":"themes/butterfly/package.json","hash":"32ac2c2e70a4369d20b6a0a6b10fc90556c67b23","modified":1757817371059},{"_id":"themes/butterfly/plugins.yml","hash":"97a55ae0f4784ca80c7862da36da22b54be41ae5","modified":1757817371059},{"_id":"themes/butterfly/languages/default.yml","hash":"2e3beaf7fb585d83c3e7cd1cca51573f42935f3c","modified":1757817371056},{"_id":"themes/butterfly/languages/en.yml","hash":"2e3beaf7fb585d83c3e7cd1cca51573f42935f3c","modified":1757817371056},{"_id":"themes/butterfly/languages/ja.yml","hash":"bde04a89febd0dbf320eac4da4ecd81624f2f29f","modified":1757817371056},{"_id":"themes/butterfly/languages/ko.yml","hash":"70d6df7cf6472799faf4778405b332101ea822c1","modified":1757817371056},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"3cdeb46ad36f3b76703b4f39c72a8aa1a15425cb","modified":1757817371056},{"_id":"themes/butterfly/layout/archive.pug","hash":"bc77220dfc269b8faad0930e1a4142ebf68165e5","modified":1757817371056},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"b59fedd9e1e65112d6a90dc7f55179085d0f1a6a","modified":1757817371056},{"_id":"themes/butterfly/languages/zh-HK.yml","hash":"c93e510c7b119173226f3b0afb87c5f553f6eea8","modified":1757817371056},{"_id":"themes/butterfly/layout/index.pug","hash":"a93004cc8ec8050df603d32a6e6e02cd96fd9875","modified":1757817371059},{"_id":"themes/butterfly/layout/category.pug","hash":"a7e9805a781e34e38d27462e6ce2a5821c34bb9f","modified":1757817371056},{"_id":"themes/butterfly/layout/post.pug","hash":"65c4a49c65c3fc4d9dc88b9791a75710c698c3a1","modified":1757817371059},{"_id":"themes/butterfly/layout/tag.pug","hash":"ca5333bd262cb58c195c844b593a0eed0c721766","modified":1757817371059},{"_id":"themes/butterfly/layout/page.pug","hash":"7ce2a49c6c41847de4ccea377ade116339984434","modified":1757817371059},{"_id":"themes/butterfly/_config.yml","hash":"ec8cd5967a4509a5928f95fb8c5c49ac32a4699e","modified":1757817371056},{"_id":"themes/butterfly/source/manifest.json","hash":"1b0fae97891c808f83e85ac40f28114167e18071","modified":1757817371064},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"63ad2249ad09fb3fe21bd5ff9adefb304a7ab24a","modified":1757817371055},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"10ce05c8dbde09f53bdabe40b5388de9ccc71a31","modified":1757817371055},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1757817371055},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1757817371055},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1757817371056},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"e1611a30df80cbe7ecf60be2e0cdd816ecabdd03","modified":1757817371056},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"d30413aa2a17bf31e4084f1096523ead7f2a6bf1","modified":1757817371056},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"1d11e334b22dbbedcb0f751f9ee9789d4416605e","modified":1757817371056},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"e5e6c05a621483b3542f2884e8ba45e84b1e973a","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"062137cb4d078b27680da1ae28d524a9c963eebc","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"3617840416f26078117f760579fb544dce07e1bc","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"3e65b7bf6bccccbba7e15349f0a44f15c64c5b5e","modified":1757817371057},{"_id":"themes/butterfly/scripts/common/postDesc.js","hash":"ba98361b9d469076bfb045e5ff42eaf764a38fb1","modified":1757817371059},{"_id":"themes/butterfly/scripts/events/404.js","hash":"039fc75f363d79669b0b2177d929cdff6f2ef7a4","modified":1757817371059},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1757817371059},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"7b1b16e1e8e08245a345764616956be50487eb53","modified":1757817371059},{"_id":"themes/butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1757817371059},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"bac639c404588ea62e601ef0bcd368c3bd0119af","modified":1757817371059},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1757817371059},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"b23108d29fff3e32384d8689c8bcd2ab306a1ae7","modified":1757817371059},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"20a6ebf63439501a4b3fc81e7a2a2ea5d103bace","modified":1757817371060},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"0cdf781a8c14d7b50d309e69f282ec7b178804bb","modified":1757817371060},{"_id":"themes/butterfly/scripts/helpers/getArchiveLength.js","hash":"bf77635e920eaf52bceebc95f87c7c87a7ca8038","modified":1757817371060},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"d2878483c160999240e969a34e3ddc51a780821b","modified":1757817371060},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"950b7d0966429bf0f9e6c5e1161e50e545e320b4","modified":1757817371060},{"_id":"themes/butterfly/scripts/helpers/series.js","hash":"45367c4ce827329867dbcc750ec125da9ccb2cfd","modified":1757817371060},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"00c5742ad1c75b3c5684d02ffc6a1921399e5376","modified":1757817371060},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"b9af69d8998d748178348d93a19daccff0550c56","modified":1757817371060},{"_id":"themes/butterfly/scripts/events/merge_config.js","hash":"cead7891fbc0a53ffca4d68124e68efa855354a5","modified":1757817371059},{"_id":"themes/butterfly/scripts/tag/chartjs.js","hash":"195ba802d7e8406c155124a9c939a2318f82938b","modified":1757817371060},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"2f44e1b3ccd170b256eae178299d6fa933a8d490","modified":1757817371060},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"25eefe10189caf3910a0e5d5b2f2043ae9255531","modified":1757817371060},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"fa3d0a64f7fce4aff7928d4ddd95548978ba001c","modified":1757817371060},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"f02fb085a88a2c0c82aeffacc24e1b71c74bd7c0","modified":1757817371060},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"89c6c78d2db43b190055d5690741a79bab4f3e7e","modified":1757817371060},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"cf0bc17d0180231167cc6aa8a00fc64f198cb9f9","modified":1757817371060},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"50d8d8fac5c5b6e26317028895d7d82a2cf46606","modified":1757817371060},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"e68d8d21f3a86e3646907a3685550ee20e8d4a9f","modified":1757817371060},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"f589fb6646bd17cf12d77a9b251dd614e1c8b899","modified":1757817371060},{"_id":"themes/butterfly/scripts/tag/series.js","hash":"40bc9a065e3a1423e0e66f4911e00713ca9f5e9e","modified":1757817371060},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"3c486b149e28edd1a06843f05a5c355000991b82","modified":1757817371060},{"_id":"themes/butterfly/source/css/custom.css","hash":"b9dde7abe14bfbb0aecaaee78ffe327e843ce407","modified":1757817371062},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"176804f07567aa80f1ed95897a968a996b155dec","modified":1757817371060},{"_id":"themes/butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1757817371062},{"_id":"themes/butterfly/source/css/nav_style.css","hash":"8bdea8ee5bcc91bd7bdf31a88240d8af6d1a5785","modified":1757817371062},{"_id":"themes/butterfly/source/css/siderbar.css","hash":"4d9a9049b508b32ee7d669a8126da60ff6ed91ef","modified":1757817371062},{"_id":"themes/butterfly/source/css/var.styl","hash":"d1eec577074ab7b262182885576135bf1896e12c","modified":1757817371062},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1757817371062},{"_id":"themes/butterfly/source/img/favicon.ico","hash":"455ac256580bf31a45813dbbdb87219bfc8bfb04","modified":1757817371062},{"_id":"themes/butterfly/source/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1757817371062},{"_id":"themes/butterfly/source/js/main.js","hash":"5a52047b8520f79864d5a4ee2379a29751aead23","modified":1757817371063},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"fdb5482d04a75bd79946ad1ed291d281d0e9362d","modified":1757817371064},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"e93a36d3c29b5a02c7f26a23f96e1f84b063cbe8","modified":1757817371056},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c2156c77a011b20fafd34f03ca073397c21b099f","modified":1757817371056},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"9ea75b06f19bf356f340f4a3fc1bdc0713cfe445","modified":1757817371056},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"56a3c32de1a15627ff38c67f1131cdd6ec5ac924","modified":1757817371056},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1757817371056},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"83ed05ef1e39f2ee70c3fba2cf96e488d8ffec66","modified":1757817371056},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"1e1a69aa2cbda2e621c741b3802093244b3cc04e","modified":1757817371056},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1757817371056},{"_id":"themes/butterfly/layout/includes/head/structured_data.pug","hash":"8ef72cd688999bf3915be6724c12700a1e2724d9","modified":1757817371056},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"44331c9db74b281b5c5c41439d3407a9076df1a1","modified":1757817371056},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"733184f88e3a586a5fcc9d193ad500556b6c8eed","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"f478a82ba4c15d4f6a5db38eca5c61f7054fa71d","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"e2d31e0f450ad42c47f7ee96375799342bf2f19b","modified":1757817371057},{"_id":"themes/butterfly/source/js/utils.js","hash":"b2ed9937fd00459c0e569db709a26cf8738ab18d","modified":1757817371064},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1757817371063},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"a2f7d69ca7ec58f24fe7d4e04ae21d5b62b01567","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"d76ce71ba106e350670c021a3dcae57547d01830","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"9d2d539555bab495959b9df734ed5c43a9f9e5a9","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"ef7afe0df7a3746744ac8185da7163b7406120ca","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"7d799c4694adb6e265e3f4b975d7f7f6a7021a17","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/page/404.pug","hash":"15d32c511e4875066fcbe9cb84c3ada07b5a7c41","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"efb40388e37cca0b5e7c3c66e811a42f8d32c910","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"79ad31eb72a9e14007770b18a426406a25315b38","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"6b0fa5f048aca8e9cbe56978301af918cf7ac34a","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/post/outdate-notice.pug","hash":"b7ce9484bc5c97ea6154f0b78fb9b8951fafedbd","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"b96c232e5178d927987791d9ae386dd83679535a","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/mixins/indexPostUI.pug","hash":"f3389fa9ae4fa32e3c16573286583bc3023e57ad","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"ed79fef5b5025415ea12eaed970f3fe7f6ef9596","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/page/shuoshuo.pug","hash":"b2423cfc57a5e3a0e1112ff7c18d5c5c720d89d5","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"db92f25ff3fd061882f81bf74ca560ff66983a0c","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"88f979a0b1a19eeb0db229247833bf9c6865c3b9","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"43014bfc63583d3ee8808d526dd165848c0ed52f","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"d29ee6a07e6716c0dc1d4533c87b19b6076fefd3","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"236c3ce26dd76e80b04d457789475c42da5ac0c8","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/third-party/umami_analytics.pug","hash":"bc35a1552d26ecdeeadbf06300078dbb5128a6e5","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"1aba8aa7cd767dc96879d13a13b4c8ceb9023233","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"d8753772889b5d0f4d15639ed6af5e91e53b1d03","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/widget/card_post_series.pug","hash":"e0bb72fa0ce15964b11b8fe421cae3432394e35f","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"1dd19a564320d248dbcee7f118a5b96c6466da65","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"fcddd80cdeb6aa81f342cd9f0102302f6ba087a8","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"45f620cd87b9ef2aa9d1e024e697ed6b4eecff34","modified":1757817371059},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"d12340a7df4601b9a23f070e16645861aeb3bb0a","modified":1757817371060},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"4fcb8222b9548e22f7b76f12d33e3698240cbae0","modified":1757817371060},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"a51edfd3e499e7d38c32241c40e8e4d371efca73","modified":1757817371061},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"4cc02bcbaa4a1933a82a9ea57a603fe2d059fc77","modified":1757817371061},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"67062d597408068e4a59e95851e98fed34b745da","modified":1757817371060},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"ba174889e770ae9f6683379b9eae9d8c94253080","modified":1757817371061},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"fbfce4d67cacd1df22fb73d89d008693f59d9d91","modified":1757817371061},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"5692bcf8929f7ef12b10d860da6cb90ca55752c0","modified":1757817371061},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"7d7554573c005399bc8c2264a85896d2d51be1e1","modified":1757817371061},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1757817371061},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"ef8e8549fe7ad4b99793844a93b4a89f77f417d5","modified":1757817371061},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"d220d32f74b44ca00dd9091246f38904fc765177","modified":1757817371061},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"5ee6285b4fe34cd5d52c7485ac3d1e5bcfa65359","modified":1757817371061},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"d9cdf564a822a585e67fd5bac8573ba87eeb3743","modified":1757817371061},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"a0f5835f04358122e8b1d38dd3e8da09a1b5b431","modified":1757817371061},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"084dc4dfb41f55e237a9d6cf8c2f5dba729b83be","modified":1757817371061},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"0af7c8754f04bdd9a02a14d880774753bd2e35ee","modified":1757817371061},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"4c9849df9c68d892c7df0ca28123aeb0dc9dc424","modified":1757817371061},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"ad66212554468b7067590308ed4cf40524fea662","modified":1757817371061},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"c4cda7b0c99015df29ce00fdfddd2f7679653754","modified":1757817371061},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"205ccc7d0ec6ce1193b46bc0c9ce0385594581fb","modified":1757817371061},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"dcff804c4c237e1e908481b44c1ac4e39ac0da34","modified":1757817371061},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"5abe5480d83ff8b452a780a484d50a44091475bf","modified":1757817371061},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"7543bb688876a946538d66b991c71b94b5216277","modified":1757817371061},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"1f8d715faf3b91b53426e38195c0920afb3bfa1c","modified":1757817371061},{"_id":"themes/butterfly/source/css/_page/shuoshuo.styl","hash":"79bb1d9a27822ed5675d1e52f5dbd0e2f5d5010a","modified":1757817371061},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"fc26e980fedde31644ebf878967f66ef9ba32be2","modified":1757817371061},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"d8a8275a68a1421c4c09b604cf78bea16c1d0463","modified":1757817371061},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"6c4cbdadd9a49029fe0c59e29808d873e5b6b6ee","modified":1757817371062},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"1f2b86df86df81c3a59377b29102314ffc73dfa6","modified":1757817371062},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"de8437a058a315d14d7e7034066f095b7b3ed4b4","modified":1757817371062},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1757817371062},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"3be8d0a75e7cc96548667cae0cb6a474279bd0b5","modified":1757817371062},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"d27dbccaf3de1c9158d19e4fd49a25953cb5778d","modified":1757817371062},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"30d1f809efd252ed0233d96d4374efd2b01d2292","modified":1757817371062},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"216f52fefc2274b542b549d8470503e6f1a308fb","modified":1757817371062},{"_id":"themes/butterfly/source/css/_tags/series.styl","hash":"0657169849bc4bf4d93b5492ade040c8f58c1901","modified":1757817371062},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"3a88eedcb694da79e92581ce50cb1a430b1fb615","modified":1757817371062},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"4929382bd60788d34752a66e2fe764ef797a72a0","modified":1757817371062},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"e846ddaef494d46cdfa2379deacfe74fa1cc5264","modified":1757817371062},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1757817371062},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f0a90d8e39915a74b16ef22e851f179415cd7eaa","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"fb0b341ac8cb3ce466d1853cea4704f1e3e5ba7f","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"b03ee8625149191f9d5d057bbc9824b68d8dd0c4","modified":1757817371057},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"7119f2f2943de71999d3dd6ba5c60cde846f114b","modified":1757817371064},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"cbfbcf34a24d21ba2b21cf9eedb76f4c3c563c5a","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d6fff5a7f84c8b09f282f9ddc0020a68a8aac9ea","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1757817371057},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"a2b783230a9143de69004cfc914d9f55e6fc1660","modified":1757817371064},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"7884883ec15792f7e54daacb3c62b851dde2b66a","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"b5db4203a1392385838c73549ddeae0a4be67eba","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"e8438941085def0591a72fc9b0d705dbf107f54f","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"5b29badecbbe828112c001156023fc0566045cf6","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"fd2320ee25507bb8ef49f932c2d170586b44ea4d","modified":1757817371057},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"24d094fd917947c0ca7492fa094328b1a183b873","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"c81fa7d8a5cb96d1ae07bfa8c46b84a58161add1","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f2ea5249b3e6670f6c8c77868f4f42c502e43830","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"8af585e6d6f73ee57114eefad574dc6e8ea9f570","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"592b2251db6c1abeb8b0eebe3b2e6d9aa0dec445","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"58914c58a190e3bc0aa37cb581e77e442b563501","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"62466b251052cae609b6369d4cb4b6a85320757d","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"89c63a5f0c0ab6314de7158fbc8fcbc84997fc55","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"db6713d2b90eb8183f86ac92c26761a8501c0ddb","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"7a80231fc71822e503879383a2d9611edf1d72dd","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"84f7cfde00f929fa3dc40349bcab060ec68f1b9f","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"53d99831f29aeb2e336ed1407d79590041f77002","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"30a7d157890de69deab28baa47fb7bb28b040efd","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"24f18b0c67803210d53abbf9c1d454c000b06eee","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"e2bf15357485cd502414b3b20f5b1f762a2fd014","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/math/chartjs.pug","hash":"732eb1118ea1a73aa5c164d639097c614f8e9953","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"b83db9fa64d42a0bfd97efb660e09be3f166a144","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"af66d13204030d47537b9e31a6173e63589ce7ff","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"187302dbc916852ff2fdf47061e272c061611dda","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"ca2fc5928ca292f29fd8333c73733344994096fb","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"fa4b4194749d05f7249f365f2b89c0281057ce54","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"a7c07dbc1e970a5b247091458e1ee9b144a3366d","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"72e2970b23570e308f8af5d8ba8e5e3321d01bbf","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/common.pug","hash":"27fa75affebc6e84a487c62bceff783bde595256","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"34edfebf0cace0852806be774910ccb0e0914650","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"db2f4fff80a1166476ea76ae004aa186df11bad3","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"d376ec17fb19fcdcf0d2ad71330190146d3af879","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"d2e12a9fc302a4efe52c90d44896fbd73e193a1f","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ec6c685080634ac46ffbea1b8f10313388888f43","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"7f0ede1cd3fed2669c94a8e1b21bc0b183f310b8","modified":1757817371058},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"013756ff3363344987cc00fc9bd833baf193c341","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"2622b4cf9189fa23e4a422aaf9ef272e4f2c6137","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"f8557548d2ad8dd149c562193991c6c6cda02415","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"f5ee1c9c8ffa4bca972d30f4de69268b8d47f052","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"e51e896ccb13900de38dc81cf44dc789e2418a12","modified":1757817371059},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"efef352c1d122409575386bf3894dce8e87032e2","modified":1757817371059},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"ef52ebf1e8e751a412f9456fdaeee7d88afd9a72","modified":1757817371061},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"9f02598b5e4296aec6470639d4bac4c9ac46392e","modified":1757817371061},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"077ec530831be1d80e93da380406b9f5abd0918a","modified":1757817371061},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"1883c91d43bff10aae55122a21e0b064b6f5c9dd","modified":1757817371061},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"de4bb5fc2dfca368b35e4c1109c92f7abc9e2245","modified":1757817371061},{"_id":"source/background/015.webp","hash":"fecbebb898246cf9cca283dd81599dc32f70ee53","modified":1757817371052},{"_id":"source/_posts/主题样例/img/mdmdt-ui-4.png","hash":"6419659c1958782997717ca278b38eecbe0bf732","modified":1757817371039},{"_id":"source/background/014.webp","hash":"cdb6b22c9394375a21b10bd7be03934adcad01c6","modified":1757817371052},{"_id":"source/_posts/主题样例/img/mdmdt-mermaid.png","hash":"2c49a7cb5ada56b857195fee1e09aab628638a4e","modified":1757817371024},{"_id":"source/_posts/主题样例/img/mdmdt-ui-1.png","hash":"6bc83d857d72885c17c9a0c72289ef55cc535f20","modified":1757817371035},{"_id":"source/_posts/主题样例/img/mdmdt-math.png","hash":"67c2dd6760c67ce2e68b4ab8178048874780cba2","modified":1757817371022},{"_id":"source/_posts/主题样例/img/mdmdt-ui-3.png","hash":"29c53be7a4d64214579b1e9484b37ef67521f14e","modified":1757817371038},{"_id":"themes/butterfly/source/img/butterfly-icon.png","hash":"f5dd732fed5c3bcd4aa76bac3441bac8485fb432","modified":1757817371062},{"_id":"source/_posts/主题样例/img/mdmdt-blockquote.png","hash":"545815ace3d2d0315772edecd58f6c178a52890a","modified":1757817371010},{"_id":"source/_posts/主题样例/img/mdtht-light.png","hash":"dee8966527166b69bfa6ac273e9a0086600fe61a","modified":1757817371047},{"_id":"source/_posts/主题样例/img/mdmdt-list.png","hash":"3d67d31407821bbe27a628bd1774ee49e838c672","modified":1757817371021},{"_id":"source/_posts/主题样例/img/mdmdt-title.png","hash":"c8fc3a759bb798d21d87f93f36862bbe6ba85fc4","modified":1757817371034},{"_id":"source/_posts/主题样例/img/mdtht-dark.png","hash":"a22e3a93b3468563f838817ee5cc799ca5932a9a","modified":1757817371045},{"_id":"source/_posts/主题样例/img/mdmdt.png","hash":"de6ad0e72771def4b0f7dd80d7725a64b5ccad22","modified":1757817371042},{"_id":"source/img/avatar.png","hash":"2716769a3818d1db9148bbbc977b00d0e09760f4","modified":1757817371054},{"_id":"source/_posts/主题样例/img/mdmdt-code.png","hash":"b48561ef25e2a6826eab768bbfd9461d002a16cc","modified":1757817371014},{"_id":"source/_posts/主题样例/img/mdmdt-source.png","hash":"977f9b736b4bc207bd7fd1e96f17adb3275423f2","modified":1757817371027},{"_id":"source/_posts/主题样例/img/mdmdt-text.png","hash":"c9d5912c5fd1c31bc2fe2d52552eff2e0ecf1c8d","modified":1757817371031},{"_id":"source/_posts/主题样例/img/mdmdt-layout.png","hash":"85d9e5e64b8cfda533affc3f54d141669d78659a","modified":1757817371018},{"_id":"public/manifest.json","hash":"c77a184193b6816fda911daa70f7705efafd7506","modified":1757829443985},{"_id":"public/about/index.html","hash":"6c2b7fa77cb215497e5d0cf9c55acd4b485a2a73","modified":1757829443985},{"_id":"public/categories/index.html","hash":"45acf48c73595f1680b6de56a8c8345a627bd26b","modified":1757829443985},{"_id":"public/link/index.html","hash":"a23cc9116c7c712d1eeb8c22995d7858b9137471","modified":1757829443985},{"_id":"public/tags/index.html","hash":"b59793a48114300c50332cb016e36a90d5910da8","modified":1757829443985},{"_id":"public/2020/12/07/hello-world/index.html","hash":"f255cad927dcd6ee9483ee2b5682fd879709a295","modified":1757829443985},{"_id":"public/2025/07/06/C-Plus-Plus/新标准/index.html","hash":"5844e9d8e450bb9dbabac31517c536a4e8919ad6","modified":1757829443985},{"_id":"public/2025/07/06/C-Plus-Plus/语法/index.html","hash":"fd0ab1aba52496e938ed73411251c8eb6b32650e","modified":1757829443985},{"_id":"public/2025/07/06/LeetCode/leetcode-1477/index.html","hash":"88e8d0a12a08f9ad1a7aed74d13b75d63ff067b5","modified":1757829443985},{"_id":"public/2025/07/06/LeetCode/leetcode-31/index.html","hash":"e1a4cdb05a248f8fcab4fe5f8c7203b46c8e4611","modified":1757829443985},{"_id":"public/2025/07/06/C语言/标准库/index.html","hash":"7b972a97fb70595d45d3bb4b97ea71969e900020","modified":1757829443985},{"_id":"public/2025/07/06/主题样例/Mdmdt主题演示demo/index.html","hash":"21aabe8e2f0c8a1560c9c0f70dc5d35fc1648e66","modified":1757829443985},{"_id":"public/2025/07/06/主题样例/readme.en/index.html","hash":"02fdf991497ecde85562aca702044dc1bdf137cf","modified":1757829443985},{"_id":"public/2025/07/06/主题样例/readme/index.html","hash":"a14eaf5b7aeef22ebaf2baaaa1603e057e336f09","modified":1757829443985},{"_id":"public/2025/07/06/程序/string分割/index.html","hash":"9cce3f6e9e3ff143cebb2a5b79b8f2c294c9f71a","modified":1757829443985},{"_id":"public/2025/07/06/程序/获取文件大小/index.html","hash":"665e4b00bf5775edb7c9cf10d7d9dda33950cbd3","modified":1757829443985},{"_id":"public/2025/07/06/网络编程/TCP协议和UDP协议/index.html","hash":"f35daa5ada4313fb1474aa4c604ba4af26c8f7d1","modified":1757829443985},{"_id":"public/2025/07/06/网络编程/socket/index.html","hash":"78d6cf58f69ffad7c1259167281eaae546464543","modified":1757829443985},{"_id":"public/2025/07/06/系统编程/多进程/index.html","hash":"97a1219aeec2e39ce74c8928dfbfe6a116baa33c","modified":1757829443985},{"_id":"public/2025/07/06/系统编程/标准IO/index.html","hash":"e0357126cda765072d35d57180bbefa95831a1a2","modified":1757829443985},{"_id":"public/2025/07/06/系统编程/系统调用/index.html","hash":"595e7d4f7fa7a8a07737a9c985a8436f80529d12","modified":1757829443985},{"_id":"public/2025/07/06/C-Plus-Plus/STL/map/index.html","hash":"13e08ecae5886cf0a46caafdced41da2cd7a417d","modified":1757829443985},{"_id":"public/2025/07/06/C-Plus-Plus/STL/set/index.html","hash":"c17d428a1410e804c2c9cf64f39cf5b518c3d9c7","modified":1757829443985},{"_id":"public/2025/07/06/C-Plus-Plus/c-plus-plus-14/shared_lock/index.html","hash":"f355e2c091f336ef5f84abe6771d863722eca105","modified":1757829443985},{"_id":"public/2025/07/06/C-Plus-Plus/c-plus-plus-14/shared_timed_mutex/index.html","hash":"6b50905e8e97e1b2a8fd03d8dc56f8dd0d054f6d","modified":1757829443985},{"_id":"public/2025/07/06/C-Plus-Plus/c-plus-plus-17/nodiscard/index.html","hash":"6196611116f71b59693725cad1c06ce430059eb9","modified":1757829443985},{"_id":"public/2025/07/06/C-Plus-Plus/对象模型/内存对齐/index.html","hash":"d26f773ce000f3f203acdb1daa40be8a88070594","modified":1757829443985},{"_id":"public/2025/07/06/C-Plus-Plus/并发/内存序/index.html","hash":"a47144a7e79c7abc34a977de177517d90655eb89","modified":1757829443985},{"_id":"public/2025/07/06/C-Plus-Plus/并发/原子操作/index.html","hash":"61a35c50a31a8751e3afbd5e87feabef155b9342","modified":1757829443985},{"_id":"public/2025/07/08/数据结构/树/BinaryTree/index.html","hash":"a4404f00f418a4017da461887275f5f874a85b48","modified":1757829443985},{"_id":"public/2025/07/09/数据结构/树/CompleteBinaryTree/index.html","hash":"77877b487607908160571cb70405fb4486312ac1","modified":1757829443985},{"_id":"public/2025/07/10/算法/SortAlgorithem/index.html","hash":"edaec84dbdf3a37d8001cee137896d0247810bf5","modified":1757829443985},{"_id":"public/2025/07/10/数据结构/树/BinarySearchTree/index.html","hash":"37192e4456ea3de4572accba9714c35c37e786c5","modified":1757829443985},{"_id":"public/2025/07/12/数据结构/树/BalancedBinarySearchTree(AVL)/index.html","hash":"9bb7be6d2152c9eb6258d4d7f109c7a3c0cf08b7","modified":1757829443985},{"_id":"public/2025/07/13/数据结构/树/FullBinaryTree/index.html","hash":"f29c984de4053c31a0ceb98797097f55cb0bc5a2","modified":1757829443985},{"_id":"public/2025/07/14/数据结构/树/RBTree/index.html","hash":"ec51196787c9eef55566eccd02cfe64e68620342","modified":1757829443985},{"_id":"public/2025/07/20/数据结构/堆/大顶堆/index.html","hash":"2c77db002c2aa2b148a9cc3f3927c1e439e9792f","modified":1757829443985},{"_id":"public/2025/08/10/网络编程/Linux的IO多路复用/index.html","hash":"18dc4f0445e67b77eed90e7d762dff81e02422d2","modified":1757829443985},{"_id":"public/2025/08/10/网络编程/epoll的LT模式和ET模式/index.html","hash":"0d8142d7bed615ff2add3898289911715be5d240","modified":1757829443985},{"_id":"public/archives/index.html","hash":"f8ffc57bf88da4b785864edcc5baba22dcee1003","modified":1757829443985},{"_id":"public/archives/page/2/index.html","hash":"804b9288626415de1041d997a95efb8542cdc7eb","modified":1757829443985},{"_id":"public/archives/page/3/index.html","hash":"9f44a7932f616cf9ff25dac1c049e8936d4bb33c","modified":1757829443985},{"_id":"public/archives/page/4/index.html","hash":"4a035c4cc39e8ff6f55cdbf6d6c6c62c120d272d","modified":1757829443985},{"_id":"public/archives/2020/index.html","hash":"7a2a7b33f4b133ff693a7487b94b71fb1bf9df83","modified":1757829443985},{"_id":"public/archives/2020/12/index.html","hash":"8f4421fe969b22273ee4638b75c73ad2a430b50d","modified":1757829443985},{"_id":"public/archives/2025/index.html","hash":"8dd244014b7bbdebfac9030cbc7cdf936a47e99a","modified":1757829443985},{"_id":"public/archives/2025/page/2/index.html","hash":"a7f88e0e1bfcf52eda9722c0d2759e1df2b1e5ad","modified":1757829443985},{"_id":"public/archives/2025/page/3/index.html","hash":"8dc512d3f5397ba885efd511de15740a01e6facd","modified":1757829443985},{"_id":"public/archives/2025/page/4/index.html","hash":"4150557241956e698a890b167b3c1c8b619062cb","modified":1757829443985},{"_id":"public/archives/2025/07/index.html","hash":"6d9d24cc1cb80a7e2eb2f4750856b9ad5a002754","modified":1757829443985},{"_id":"public/archives/2025/07/page/2/index.html","hash":"13f0630abd3fd236a6c7ce1d793e234eff23fa58","modified":1757829443985},{"_id":"public/archives/2025/07/page/3/index.html","hash":"7628dd8587640f949a3fcdc6d25da7a32afe4b91","modified":1757829443985},{"_id":"public/archives/2025/07/page/4/index.html","hash":"e41349ec181fbee2e8cef0d6620403a0c121dd45","modified":1757829443985},{"_id":"public/archives/2025/08/index.html","hash":"55ca95c8f8fed81000f6690cadd158c3da430506","modified":1757829443985},{"_id":"public/categories/C/index.html","hash":"b90a6575d79c022b0ee68facfc1b53e44bb7e750","modified":1757829443985},{"_id":"public/categories/测试/index.html","hash":"c44dad0cd81c115e31a09313ff153761d307346d","modified":1757829443985},{"_id":"public/categories/实用代码段/index.html","hash":"540f835c7e7b645587cca34b0f95061b2dfa162f","modified":1757829443985},{"_id":"public/categories/算法/index.html","hash":"4d92a50d25472326df2f9784a06298c4424b2f91","modified":1757829443985},{"_id":"public/categories/网络编程/index.html","hash":"1fc3e08e41dfe2d805ea13dc3036cdf4218c9dfd","modified":1757829443985},{"_id":"public/categories/系统编程/index.html","hash":"fadf2a2e8da1ab218a603b3eba41c0e285684847","modified":1757829443985},{"_id":"public/categories/数据结构/index.html","hash":"c4d058b15e9efb2b59128e18190e3323267e95ba","modified":1757829443985},{"_id":"public/index.html","hash":"103b8241f7d149372f40c755bf07594d3cc9df7c","modified":1757829443985},{"_id":"public/page/3/index.html","hash":"55b0e0a344011044b4bc0aa4e9c665869f989fe2","modified":1757829443985},{"_id":"public/page/2/index.html","hash":"7f76e8945ca16910d422e3cea9be755310ba056e","modified":1757829443985},{"_id":"public/page/4/index.html","hash":"6b85dfd46daa288e7525c292567980d3ffb8af97","modified":1757829443985},{"_id":"public/tags/C/index.html","hash":"d30b8eebb110938f16d0a817e267836060ec760c","modified":1757829443985},{"_id":"public/tags/C/page/2/index.html","hash":"7ed95e848f1b406308ad09cb62c9cbd04d02f85b","modified":1757829443985},{"_id":"public/tags/测试/index.html","hash":"92d12fe2df32117fa9cf51a9e1c8d32c82a4c6c4","modified":1757829443985},{"_id":"public/tags/string/index.html","hash":"5fbe799e7675c94891cb16a9e96400bf5b46be53","modified":1757829443985},{"_id":"public/tags/实用代码/index.html","hash":"1ccdac6dc7cb1f090e284872357f165425818974","modified":1757829443985},{"_id":"public/tags/文件操作/index.html","hash":"157fa007ad8b205bd360d6e18e662a50ecb16672","modified":1757829443985},{"_id":"public/tags/算法/index.html","hash":"dab2cf3ba52c282b8f206da83867374f8906eac5","modified":1757829443985},{"_id":"public/tags/排序/index.html","hash":"99159a3b275638424185e8d9ae030e25d70fe9dc","modified":1757829443985},{"_id":"public/tags/epoll/index.html","hash":"6fc14b4147d57bf436b618b040c3cf881e404e01","modified":1757829443985},{"_id":"public/tags/socket/index.html","hash":"7e8a2df2c79d6f80596353b225accef6085a26fa","modified":1757829443985},{"_id":"public/tags/Linux/index.html","hash":"aeab0d5f23871f11a190c92ceb3843c9a2681906","modified":1757829443985},{"_id":"public/tags/IO多路复用/index.html","hash":"b97a215da72e3ed657e184e6d03fbc8c72cadbd0","modified":1757829443985},{"_id":"public/tags/网络协议/index.html","hash":"4d36bb049f04d92f856ee377dca7cb3fa5b98811","modified":1757829443985},{"_id":"public/tags/并发/index.html","hash":"82d5e2574f3e5b0975f66def6068bd7caed3c50d","modified":1757829443985},{"_id":"public/tags/对象模型/index.html","hash":"d059f28354d3e33b0bfe1009db84aa799dda27db","modified":1757829443985},{"_id":"public/tags/数据结构/index.html","hash":"39245c01063719a6bdedabcfced7bbc532807e45","modified":1757829443985},{"_id":"public/tags/堆/index.html","hash":"91f95b7f14f68eefd9d2ca9fc921b7d944a6ec98","modified":1757829443985},{"_id":"public/tags/优先级队列/index.html","hash":"46a33e9a78838f24eae47ee786e4639689115586","modified":1757829443985},{"_id":"public/tags/二叉树/index.html","hash":"15f454ef83e25ddfce470180fc86a49a6304231d","modified":1757829443985},{"_id":"public/tags/树/index.html","hash":"930d6efee2e61a4ccfe232a6510527bd361e28b2","modified":1757829443985},{"_id":"public/tags/完全N叉树/index.html","hash":"d830b8076536668a3bcb96d7e72e4187f91bbb3a","modified":1757829443985},{"_id":"public/tags/红黑树/index.html","hash":"c9b65e8790134d050725f04e50817ebc2929222c","modified":1757829443985},{"_id":"public/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1757829443985},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1757829443985},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1757829443985},{"_id":"public/img/favicon.ico","hash":"455ac256580bf31a45813dbbdb87219bfc8bfb04","modified":1757829443985},{"_id":"public/background/003.webp","hash":"06960efae139f508127ccdc9984713631fa4ebf4","modified":1757829443985},{"_id":"public/background/002.webp","hash":"c868b30959bb0d3a516aa99da2937fe7df128ac9","modified":1757829443985},{"_id":"public/background/007.webp","hash":"0834f5bb7c5ced6ef4a91f0f4fe3c10a4aa75980","modified":1757829443985},{"_id":"public/background/009.webp","hash":"1fede8dfffcc436f782645439bcd75106105036d","modified":1757829443985},{"_id":"public/background/010.webp","hash":"0b23ea05d29947ca7315e0db5853c0ba4a9295b2","modified":1757829443985},{"_id":"public/background/017.webp","hash":"6ff3d4c82f986f3a72a4a05e26a0ba72cdc1152d","modified":1757829443985},{"_id":"public/background/018.webp","hash":"c7bc1213ba066379d2806e0a62606a888d489085","modified":1757829443985},{"_id":"public/background/023.webp","hash":"ea07c5ff2b42f90d29c7c25dd5e47e669a93f7a6","modified":1757829443985},{"_id":"public/css/custom.css","hash":"b9dde7abe14bfbb0aecaaee78ffe327e843ce407","modified":1757829443985},{"_id":"public/css/index.css","hash":"79edc973621df1031191266897a66d3fb4c2d628","modified":1757829443985},{"_id":"public/css/nav_style.css","hash":"8bdea8ee5bcc91bd7bdf31a88240d8af6d1a5785","modified":1757829443985},{"_id":"public/css/siderbar.css","hash":"4d9a9049b508b32ee7d669a8126da60ff6ed91ef","modified":1757829443985},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1757829443985},{"_id":"public/js/main.js","hash":"fb746a3e67d0373deea8481110dd436fea4ca38c","modified":1757829443985},{"_id":"public/js/tw_cn.js","hash":"7ef59df188ea523da89f4caf69c5c0f14e78da69","modified":1757829443985},{"_id":"public/js/utils.js","hash":"ce898acc9081131cdc3a97baf43cb7b1a25da47f","modified":1757829443985},{"_id":"public/js/search/algolia.js","hash":"e5821f78381af9f0f646952a7dd118daab2a79a6","modified":1757829443985},{"_id":"public/js/search/local-search.js","hash":"4e11d033fb58563f5e1b497f1a6f1c62d3501ee6","modified":1757829443985},{"_id":"public/background/004.webp","hash":"0a65570bf47864b2a968c3a1aac818e518723daf","modified":1757829443985},{"_id":"public/background/006.webp","hash":"f45e2e8122235d3add61413d359d61a3acbb7019","modified":1757829443985},{"_id":"public/background/008.webp","hash":"2e5dedf619a46218b2e02eac46669cc4eb8812da","modified":1757829443985},{"_id":"public/background/012.webp","hash":"3b93a4dcb2cad91ad0cbf8fae45cace8cc337511","modified":1757829443985},{"_id":"public/background/021.webp","hash":"657eb2ca190332268b894841a8d403388b5a31b4","modified":1757829443985},{"_id":"public/background/022.webp","hash":"71140891318eaada83a3a796a75033dad8239a3b","modified":1757829443985},{"_id":"public/background/005.webp","hash":"d8fb95cb3fe8c94b5a5844d03dc971571212dc4a","modified":1757829443985},{"_id":"public/background/001.webp","hash":"6f59a612a698ad124bbba4902d407bc3d1ba511a","modified":1757829443985},{"_id":"public/background/013.webp","hash":"369be7f60db7f5795e64723d64bf7cc86988b523","modified":1757829443985},{"_id":"public/background/016.webp","hash":"9dc032191e3b97bfa432231a98ad2a7dedc783fd","modified":1757829443985},{"_id":"public/background/020.webp","hash":"aa831e0d86eb2b939b317ebb55947358a2b52654","modified":1757829443985},{"_id":"public/img/butterfly-icon.png","hash":"f5dd732fed5c3bcd4aa76bac3441bac8485fb432","modified":1757829443985},{"_id":"public/background/011.webp","hash":"bd913f1948c2c75b1cb93ff2937350926a3c6cdb","modified":1757829443985},{"_id":"public/background/019.webp","hash":"103165a1d40e25eeaf726ec0075da0341986be12","modified":1757829443985},{"_id":"public/background/015.webp","hash":"fecbebb898246cf9cca283dd81599dc32f70ee53","modified":1757829443985},{"_id":"public/background/014.webp","hash":"cdb6b22c9394375a21b10bd7be03934adcad01c6","modified":1757829443985},{"_id":"public/img/avatar.png","hash":"2716769a3818d1db9148bbbc977b00d0e09760f4","modified":1757829443985}],"Category":[{"name":"C++","_id":"cmfja9lpj00064e4p8dna0jy1"},{"name":"测试","_id":"cmfja9lpo000h4e4p0bwyg9fo"},{"name":"实用代码段","_id":"cmfja9lpp000m4e4p39p5bgc0"},{"name":"算法","_id":"cmfja9lpt000x4e4p7gvoabi6"},{"name":"网络编程","_id":"cmfja9lpv00154e4pcsxt3t4s"},{"name":"系统编程","_id":"cmfja9lq0001t4e4p4muy5d3c"},{"name":"数据结构","_id":"cmfja9lq4002b4e4p5lioh504"}],"Data":[{"_id":"link","data":[{"class_name":"友链","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"网站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}],"Page":[{"_content":"{\n  \"name\": \"string\",\n  \"short_name\": \"LDK\",\n  \"theme_color\": \"#49b1f5\",\n  \"background_color\": \"#49b1f5\",\n  \"display\": \"standalone\",\n  \"scope\": \"/\",\n  \"start_url\": \"/\",\n  \"icons\": [\n    {\n      \"src\": \"imag/avatar.png\",\n      \"sizes\": \"82x82\",\n      \"type\": \"image/png\"\n    },\n    {\n      \"src\": \"background/001.webp\",\n      \"sizes\": \"1920x1052\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/002.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/003.webp\",\n      \"sizes\": \"1918x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/004.webp\",\n      \"sizes\": \"1728x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/005.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/006.webp\",\n      \"sizes\": \"1920x1076\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/007.webp\",\n      \"sizes\": \"1920x1035\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/008.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/009.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/010.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/011.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/012.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/013.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/014.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/015.webp\",\n      \"sizes\": \"1920x1076\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/016.webp\",\n      \"sizes\": \"1920x1074\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/017.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/018.webp\",\n      \"sizes\": \"1920x960\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/019.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/020.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/021.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/022.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/023.webp\",\n      \"sizes\": \"1920x991\",\n      \"type\": \"image/webp\"\n    }\n  ],\n  \"splash_pages\": null\n}\n","source":"manifest.json","raw":"{\n  \"name\": \"string\",\n  \"short_name\": \"LDK\",\n  \"theme_color\": \"#49b1f5\",\n  \"background_color\": \"#49b1f5\",\n  \"display\": \"standalone\",\n  \"scope\": \"/\",\n  \"start_url\": \"/\",\n  \"icons\": [\n    {\n      \"src\": \"imag/avatar.png\",\n      \"sizes\": \"82x82\",\n      \"type\": \"image/png\"\n    },\n    {\n      \"src\": \"background/001.webp\",\n      \"sizes\": \"1920x1052\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/002.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/003.webp\",\n      \"sizes\": \"1918x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/004.webp\",\n      \"sizes\": \"1728x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/005.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/006.webp\",\n      \"sizes\": \"1920x1076\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/007.webp\",\n      \"sizes\": \"1920x1035\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/008.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/009.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/010.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/011.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/012.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/013.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/014.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/015.webp\",\n      \"sizes\": \"1920x1076\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/016.webp\",\n      \"sizes\": \"1920x1074\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/017.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/018.webp\",\n      \"sizes\": \"1920x960\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/019.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/020.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/021.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/022.webp\",\n      \"sizes\": \"1920x1080\",\n      \"type\": \"image/webp\"\n    },\n    {\n      \"src\": \"background/023.webp\",\n      \"sizes\": \"1920x991\",\n      \"type\": \"image/webp\"\n    }\n  ],\n  \"splash_pages\": null\n}\n","date":"2025-09-14T02:36:11.054Z","updated":"2025-09-14T02:36:11.054Z","path":"manifest.json","layout":"false","title":"","comments":1,"_id":"cmfja9lpc00004e4p3z0h11or","content":"{\"name\":\"string\",\"short_name\":\"LDK\",\"theme_color\":\"#49b1f5\",\"background_color\":\"#49b1f5\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"imag/avatar.png\",\"sizes\":\"82x82\",\"type\":\"image/png\"},{\"src\":\"background/001.webp\",\"sizes\":\"1920x1052\",\"type\":\"image/webp\"},{\"src\":\"background/002.webp\",\"sizes\":\"1920x1080\",\"type\":\"image/webp\"},{\"src\":\"background/003.webp\",\"sizes\":\"1918x1080\",\"type\":\"image/webp\"},{\"src\":\"background/004.webp\",\"sizes\":\"1728x1080\",\"type\":\"image/webp\"},{\"src\":\"background/005.webp\",\"sizes\":\"1920x1080\",\"type\":\"image/webp\"},{\"src\":\"background/006.webp\",\"sizes\":\"1920x1076\",\"type\":\"image/webp\"},{\"src\":\"background/007.webp\",\"sizes\":\"1920x1035\",\"type\":\"image/webp\"},{\"src\":\"background/008.webp\",\"sizes\":\"1920x1080\",\"type\":\"image/webp\"},{\"src\":\"background/009.webp\",\"sizes\":\"1920x1080\",\"type\":\"image/webp\"},{\"src\":\"background/010.webp\",\"sizes\":\"1920x1080\",\"type\":\"image/webp\"},{\"src\":\"background/011.webp\",\"sizes\":\"1920x1080\",\"type\":\"image/webp\"},{\"src\":\"background/012.webp\",\"sizes\":\"1920x1080\",\"type\":\"image/webp\"},{\"src\":\"background/013.webp\",\"sizes\":\"1920x1080\",\"type\":\"image/webp\"},{\"src\":\"background/014.webp\",\"sizes\":\"1920x1080\",\"type\":\"image/webp\"},{\"src\":\"background/015.webp\",\"sizes\":\"1920x1076\",\"type\":\"image/webp\"},{\"src\":\"background/016.webp\",\"sizes\":\"1920x1074\",\"type\":\"image/webp\"},{\"src\":\"background/017.webp\",\"sizes\":\"1920x1080\",\"type\":\"image/webp\"},{\"src\":\"background/018.webp\",\"sizes\":\"1920x960\",\"type\":\"image/webp\"},{\"src\":\"background/019.webp\",\"sizes\":\"1920x1080\",\"type\":\"image/webp\"},{\"src\":\"background/020.webp\",\"sizes\":\"1920x1080\",\"type\":\"image/webp\"},{\"src\":\"background/021.webp\",\"sizes\":\"1920x1080\",\"type\":\"image/webp\"},{\"src\":\"background/022.webp\",\"sizes\":\"1920x1080\",\"type\":\"image/webp\"},{\"src\":\"background/023.webp\",\"sizes\":\"1920x991\",\"type\":\"image/webp\"}],\"splash_pages\":null}"},{"title":"关于","date":"2025-07-06T13:00:00.000Z","type":"about","top_img":"https://s2.loli.net/2022/07/06/3z5X4J8Z6Wq9x7Y.jpg","_content":"\n## 关于我\n\n一个热爱编程的普通人，喜欢研究新技术，喜欢分享，喜欢折腾。\n\n## 关于本站","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2025-07-06 21:00:00\ntype: \"about\"\ntop_img: https://s2.loli.net/2022/07/06/3z5X4J8Z6Wq9x7Y.jpg\n---\n\n## 关于我\n\n一个热爱编程的普通人，喜欢研究新技术，喜欢分享，喜欢折腾。\n\n## 关于本站","updated":"2025-09-14T02:36:11.049Z","path":"about/index.html","comments":1,"layout":"page","_id":"cmfja9lpg00024e4p4zq306le","content":"<h2 id=\"关于我\">关于我</h2>\n<p>一个热爱编程的普通人，喜欢研究新技术，喜欢分享，喜欢折腾。</p>\n<h2 id=\"关于本站\">关于本站</h2>\n","excerpt":"","more":"<h2 id=\"关于我\">关于我</h2>\n<p>一个热爱编程的普通人，喜欢研究新技术，喜欢分享，喜欢折腾。</p>\n<h2 id=\"关于本站\">关于本站</h2>\n"},{"title":"categories","date":"2025-07-06T12:08:02.000Z","aside":false,"type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2025-07-06 20:08:02\naside: false\ntype: \"categories\"\n---\n","updated":"2025-09-14T02:36:11.053Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cmfja9lpi00044e4pcoodh9kx","content":"","excerpt":"","more":""},{"title":"友链","date":"2025-07-06T13:00:00.000Z","type":"link","top_img":"https://cdn.jsdelivr.net/gh/maoyiting/maoyiting.github.io@master/source/img/links.jpg","_content":"\n## 友链\n\n### 友链申请\n","source":"link/index.md","raw":"---\ntitle: 友链\ndate: 2025-07-06 21:00:00\ntype: \"link\"\ntop_img: https://cdn.jsdelivr.net/gh/maoyiting/maoyiting.github.io@master/source/img/links.jpg\n---\n\n## 友链\n\n### 友链申请\n","updated":"2025-09-14T02:36:11.054Z","path":"link/index.html","comments":1,"layout":"page","_id":"cmfja9lpk00084e4p8p7s8j2z","content":"<h2 id=\"友链\">友链</h2>\n<h3 id=\"友链申请\">友链申请</h3>\n","excerpt":"","more":"<h2 id=\"友链\">友链</h2>\n<h3 id=\"友链申请\">友链申请</h3>\n"},{"title":"标签","date":"2025-07-06T12:05:22.000Z","type":"tags","orderby":"random","order":1,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2025-07-06 20:05:22\ntype: \"tags\"\norderby: random\norder: 1\n---\n","updated":"2025-09-14T02:36:11.054Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cmfja9lpl000a4e4pac67g05n","content":"","excerpt":"","more":""}],"Post":[{"title":"Hello World","date":"2020-12-07T08:47:35.000Z","updated":"2025-09-14T02:36:11.009Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":null,"toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"noticeOutdate":null,"_content":"\n## Hello World\n\n### 1. 前言\n\n> Hello World\n\n### 2. 介绍\n\n> Hello World\n\n### 3. 使用\n\n> Hello World\n\n### 4. 参考资料\n\n> Hello World\n\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2020-12-07 16:47:35\nupdated:\ntags:\ncategories:\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\nnoticeOutdate:\n\n---\n\n## Hello World\n\n### 1. 前言\n\n> Hello World\n\n### 2. 介绍\n\n> Hello World\n\n### 3. 使用\n\n> Hello World\n\n### 4. 参考资料\n\n> Hello World\n\n","slug":"hello-world","published":1,"layout":"post","photos":[],"_id":"cmfja9lpe00014e4p8ry206mr","content":"<h2 id=\"Hello-World\">Hello World</h2>\n<h3 id=\"1-前言\">1. 前言</h3>\n<blockquote>\n<p>Hello World</p>\n</blockquote>\n<h3 id=\"2-介绍\">2. 介绍</h3>\n<blockquote>\n<p>Hello World</p>\n</blockquote>\n<h3 id=\"3-使用\">3. 使用</h3>\n<blockquote>\n<p>Hello World</p>\n</blockquote>\n<h3 id=\"4-参考资料\">4. 参考资料</h3>\n<blockquote>\n<p>Hello World</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"Hello-World\">Hello World</h2>\n<h3 id=\"1-前言\">1. 前言</h3>\n<blockquote>\n<p>Hello World</p>\n</blockquote>\n<h3 id=\"2-介绍\">2. 介绍</h3>\n<blockquote>\n<p>Hello World</p>\n</blockquote>\n<h3 id=\"3-使用\">3. 使用</h3>\n<blockquote>\n<p>Hello World</p>\n</blockquote>\n<h3 id=\"4-参考资料\">4. 参考资料</h3>\n<blockquote>\n<p>Hello World</p>\n</blockquote>\n"},{"title":"C++新标准","date":"2025-07-05T16:00:00.000Z","description":"C++新标准(11～20)","_content":"\n# C++新标准\n### C++ 11\n\n语法特性：\n\n- `auto`\n- `decltype`\n- 返回类型后置(`auto`+`decltype`)\n- 右值引用\n- 列表初始化\n- 移动语义(`std::move`)\n- 万能引用(`T&&`)\n- 智能指针(`share_ptr; wake_ptr; unique_ptr`)\n- 范围for循环\n- 委托构造函数\n- 继承构造函数\n- `final`和`override`\n- `default`\n- 函数`delete`\n- `explicit`\n- `constexpr`\n- 强类型枚举(`enum class`)\n- 原始字符串字面量\n- 基于范围的`for`循环\n- `lambda`表达式\n- 内联命名空间\n- 右`>`的优化\n- `noexcept`\n- `char32_t`和`char16_t`\n\n库特性：\n\n- `chrono`库\n- `thread`库\n- `std::function`\n- `std::bind`\n- `std::move`\n- `std::forword`：与万能引用配合使用\n\n- `std::array`\n- `std::to_string()`\n- `std::tuple`(元组)\n- `std::tie`\n- `std::ref`\n- `std::make_shared`\n- 无序容器：\n  - `std::unordered_map`\n  - `std::unordered_multimap`\n  - `std::unordered_set`\n  - `std::unordered_multiset`\n- 内存模型\n- `std::async`\n- `std::forward_list`（单链表）\n\n### C++ 14\n\n- 变量模板\n\n- 泛型`lambda`参数\n\n- `lambda`初始化捕获\n\n- 放宽`constexptr`函数限制\n\n  在C++11中，constexpr函数的限制非常严格，要求其函数体仅能包含一个返回语句，且不能包含复杂的控制流语句（如循环、条件分支等）。\n\n  ```cpp\n  // C++11 constexpr阶乘函数的写法，只能使用递归\n  constexpr int factorial(int n) {\n      return n <= 1 ? 1 : (n * factorial(n - 1));\n  }\n  ```\n\n  \n\n  而在C++14中，允许在其函数体内使用更复杂的控制流结构和局部变量声明，也可以有多个返回语句，只要最终的结果能够在编译时计算得出即可。\n\n  ```cpp\n  // C++14 constexpr阶乘函数的写法，可以使用循环\n  constexpr int factorial(int n) {\n      int ret = 0;\n      for (int i = 0; i < n; ++i) {\n          ret += i;\n      }\n      return ret;\n  }\n  ```\n\n- `[[deprecated]]`(废弃标志)\n\n  标记已弃用的函数、类或其他声明。这有助于编译器在编译时发出警告，提醒开发者不应再使用某个已标记为过时的API\n\n  ```cpp\n  [[deprecated]]\n  void TriassicPeriod() {\n  \tstd::clog << \"Triassic Period: [251.9 - 208.5] million years ago.\\n\";\n  }\n  \n  [[deprecated(\"Use NeogenePeriod() instead.\")]]\t\t// 弃用并标明弃用原因\n  void JurassicPeriod() {\n  \tstd::clog << \"Jurassic Period: [201.3 - 152.1] million years ago.\\n\";\n  }\n  ```\n\n- `std::shared_timed_mutex`\n\n  超时读写锁。[shared_timed_mutex](./C++14/shared_timed_mutex.md)\n\n- `std::shared_lock`\n\n- `std::make_unique`\n\n- `std::exchange`\n\n  <mark>原子地</mark>交换一个对象的值，并返回其旧值。这个函数在处理资源管理、状态转换等场景时特别有用。\n\n  ```c++\n  #include <iostream>\n  #include <iterator>\n  #include <utility>\n  #include <vector>\n   \n  class stream\n  {\n  public:\n      using flags_type = int;\n   \n  public:\n      flags_type flags() const { return flags_; }\n   \n      // Replaces flags_ by newf, and returns the old value.\n      flags_type flags(flags_type newf) { return std::exchange(flags_, newf); }\n   \n  private:\n      flags_type flags_ = 0;\n  };\n   \n  void f() { std::cout << \"f()\"; }\n   \n  int main()\n  {\n      stream s;\n   \n      std::cout << s.flags() << '\\n';\n      std::cout << s.flags(12) << '\\n';\n      std::cout << s.flags() << \"\\n\\n\";\n   \n      std::vector<int> v;\n   \n      // Since the second template parameter has a default value, it is possible\n      // to use a braced-init-list as second argument. The expression below\n      // is equivalent to std::exchange(v, std::vector<int>{1, 2, 3, 4});\n   \n      std::exchange(v, {1, 2, 3, 4});\n   \n      std::copy(begin(v), end(v), std::ostream_iterator<int>(std::cout, \", \"));\n   \n      std::cout << \"\\n\\n\";\n   \n      void (*fun)();\n   \n      // The default value of template parameter also makes possible to use a\n      // normal function as second argument. The expression below is equivalent to\n      // std::exchange(fun, static_cast<void(*)()>(f))\n      std::exchange(fun, f);\n      fun();\n   \n      std::cout << \"\\n\\nFibonacci sequence: \";\n      for (int a{0}, b{1}; a < 100; a = std::exchange(b, a + b))\n          std::cout << a << \", \";\n      std::cout << \"...\\n\";\n  }\n  ```\n\n  输出：\n\n  ```xml\n  0\n  0\n  12\n  \n  1, 2, 3, 4,\n  \n  f()\n  \n  Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n  ```\n\n- `std::quoted`\n\n  具体使用案例：（来自`cppreference`）\n\n  ```cpp\n  #include <iomanip>\n  #include <iostream>\n  #include <sstream>\n   \n  void default_delimiter()\n  {\n      const std::string in = \"std::quoted() quotes this string and embedded \\\"quotes\\\" too\";\n      std::stringstream ss;\n      ss << std::quoted(in);\n      std::string out;\n      ss >> std::quoted(out);\n   \n      std::cout << \"Default delimiter case:\\n\"\n                   \"read in     [\" << in << \"]\\n\"\n                   \"stored as   [\" << ss.str() << \"]\\n\"\n                   \"written out [\" << out << \"]\\n\\n\";\n  }\n   \n  void custom_delimiter()\n  {\n      const char delim{'$'};\n      const char escape{'%'};\n   \n      const std::string in = \"std::quoted() quotes this string and embedded $quotes$ $too\";\n      std::stringstream ss;\n      ss << std::quoted(in, delim, escape);\n      std::string out;\n      ss >> std::quoted(out, delim, escape);\n   \n      std::cout << \"Custom delimiter case:\\n\"\n                   \"read in     [\" << in << \"]\\n\"\n                   \"stored as   [\" << ss.str() << \"]\\n\"\n                   \"written out [\" << out << \"]\\n\\n\";\n  }\n   \n  int main()\n  {\n      default_delimiter();\n      custom_delimiter();\n  }\n  ```\n\n  输出：\n\n  ```cpp\n  Default delimiter case:\n  read in     [std::quoted() quotes this string and embedded \"quotes\" too]\n  stored as   [\"std::quoted() quotes this string and embedded \\\"quotes\\\" too\"]\n  written out [std::quoted() quotes this string and embedded \"quotes\" too]\n   \n  Custom delimiter case:\n  read in     [std::quoted() quotes this string and embedded $quotes$ $too]\n  stored as   [$std::quoted() quotes this string and embedded %$quotes%$ %$too$]\n  written out [std::quoted() quotes this string and embedded $quotes$ $too]\n  ```\n\n### C++ 17\n\n- #### [nodiscard](./C++17/nodiscard.md)\n\n- \n\n### C++ 20\n\n[ddd]: ","source":"_posts/C-Plus-Plus/新标准.md","raw":"---\ntitle: C++新标准\ndate: 2025-07-06\ntags: C++\ncategories: C++\ndescription: C++新标准(11～20)\n---\n\n# C++新标准\n### C++ 11\n\n语法特性：\n\n- `auto`\n- `decltype`\n- 返回类型后置(`auto`+`decltype`)\n- 右值引用\n- 列表初始化\n- 移动语义(`std::move`)\n- 万能引用(`T&&`)\n- 智能指针(`share_ptr; wake_ptr; unique_ptr`)\n- 范围for循环\n- 委托构造函数\n- 继承构造函数\n- `final`和`override`\n- `default`\n- 函数`delete`\n- `explicit`\n- `constexpr`\n- 强类型枚举(`enum class`)\n- 原始字符串字面量\n- 基于范围的`for`循环\n- `lambda`表达式\n- 内联命名空间\n- 右`>`的优化\n- `noexcept`\n- `char32_t`和`char16_t`\n\n库特性：\n\n- `chrono`库\n- `thread`库\n- `std::function`\n- `std::bind`\n- `std::move`\n- `std::forword`：与万能引用配合使用\n\n- `std::array`\n- `std::to_string()`\n- `std::tuple`(元组)\n- `std::tie`\n- `std::ref`\n- `std::make_shared`\n- 无序容器：\n  - `std::unordered_map`\n  - `std::unordered_multimap`\n  - `std::unordered_set`\n  - `std::unordered_multiset`\n- 内存模型\n- `std::async`\n- `std::forward_list`（单链表）\n\n### C++ 14\n\n- 变量模板\n\n- 泛型`lambda`参数\n\n- `lambda`初始化捕获\n\n- 放宽`constexptr`函数限制\n\n  在C++11中，constexpr函数的限制非常严格，要求其函数体仅能包含一个返回语句，且不能包含复杂的控制流语句（如循环、条件分支等）。\n\n  ```cpp\n  // C++11 constexpr阶乘函数的写法，只能使用递归\n  constexpr int factorial(int n) {\n      return n <= 1 ? 1 : (n * factorial(n - 1));\n  }\n  ```\n\n  \n\n  而在C++14中，允许在其函数体内使用更复杂的控制流结构和局部变量声明，也可以有多个返回语句，只要最终的结果能够在编译时计算得出即可。\n\n  ```cpp\n  // C++14 constexpr阶乘函数的写法，可以使用循环\n  constexpr int factorial(int n) {\n      int ret = 0;\n      for (int i = 0; i < n; ++i) {\n          ret += i;\n      }\n      return ret;\n  }\n  ```\n\n- `[[deprecated]]`(废弃标志)\n\n  标记已弃用的函数、类或其他声明。这有助于编译器在编译时发出警告，提醒开发者不应再使用某个已标记为过时的API\n\n  ```cpp\n  [[deprecated]]\n  void TriassicPeriod() {\n  \tstd::clog << \"Triassic Period: [251.9 - 208.5] million years ago.\\n\";\n  }\n  \n  [[deprecated(\"Use NeogenePeriod() instead.\")]]\t\t// 弃用并标明弃用原因\n  void JurassicPeriod() {\n  \tstd::clog << \"Jurassic Period: [201.3 - 152.1] million years ago.\\n\";\n  }\n  ```\n\n- `std::shared_timed_mutex`\n\n  超时读写锁。[shared_timed_mutex](./C++14/shared_timed_mutex.md)\n\n- `std::shared_lock`\n\n- `std::make_unique`\n\n- `std::exchange`\n\n  <mark>原子地</mark>交换一个对象的值，并返回其旧值。这个函数在处理资源管理、状态转换等场景时特别有用。\n\n  ```c++\n  #include <iostream>\n  #include <iterator>\n  #include <utility>\n  #include <vector>\n   \n  class stream\n  {\n  public:\n      using flags_type = int;\n   \n  public:\n      flags_type flags() const { return flags_; }\n   \n      // Replaces flags_ by newf, and returns the old value.\n      flags_type flags(flags_type newf) { return std::exchange(flags_, newf); }\n   \n  private:\n      flags_type flags_ = 0;\n  };\n   \n  void f() { std::cout << \"f()\"; }\n   \n  int main()\n  {\n      stream s;\n   \n      std::cout << s.flags() << '\\n';\n      std::cout << s.flags(12) << '\\n';\n      std::cout << s.flags() << \"\\n\\n\";\n   \n      std::vector<int> v;\n   \n      // Since the second template parameter has a default value, it is possible\n      // to use a braced-init-list as second argument. The expression below\n      // is equivalent to std::exchange(v, std::vector<int>{1, 2, 3, 4});\n   \n      std::exchange(v, {1, 2, 3, 4});\n   \n      std::copy(begin(v), end(v), std::ostream_iterator<int>(std::cout, \", \"));\n   \n      std::cout << \"\\n\\n\";\n   \n      void (*fun)();\n   \n      // The default value of template parameter also makes possible to use a\n      // normal function as second argument. The expression below is equivalent to\n      // std::exchange(fun, static_cast<void(*)()>(f))\n      std::exchange(fun, f);\n      fun();\n   \n      std::cout << \"\\n\\nFibonacci sequence: \";\n      for (int a{0}, b{1}; a < 100; a = std::exchange(b, a + b))\n          std::cout << a << \", \";\n      std::cout << \"...\\n\";\n  }\n  ```\n\n  输出：\n\n  ```xml\n  0\n  0\n  12\n  \n  1, 2, 3, 4,\n  \n  f()\n  \n  Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n  ```\n\n- `std::quoted`\n\n  具体使用案例：（来自`cppreference`）\n\n  ```cpp\n  #include <iomanip>\n  #include <iostream>\n  #include <sstream>\n   \n  void default_delimiter()\n  {\n      const std::string in = \"std::quoted() quotes this string and embedded \\\"quotes\\\" too\";\n      std::stringstream ss;\n      ss << std::quoted(in);\n      std::string out;\n      ss >> std::quoted(out);\n   \n      std::cout << \"Default delimiter case:\\n\"\n                   \"read in     [\" << in << \"]\\n\"\n                   \"stored as   [\" << ss.str() << \"]\\n\"\n                   \"written out [\" << out << \"]\\n\\n\";\n  }\n   \n  void custom_delimiter()\n  {\n      const char delim{'$'};\n      const char escape{'%'};\n   \n      const std::string in = \"std::quoted() quotes this string and embedded $quotes$ $too\";\n      std::stringstream ss;\n      ss << std::quoted(in, delim, escape);\n      std::string out;\n      ss >> std::quoted(out, delim, escape);\n   \n      std::cout << \"Custom delimiter case:\\n\"\n                   \"read in     [\" << in << \"]\\n\"\n                   \"stored as   [\" << ss.str() << \"]\\n\"\n                   \"written out [\" << out << \"]\\n\\n\";\n  }\n   \n  int main()\n  {\n      default_delimiter();\n      custom_delimiter();\n  }\n  ```\n\n  输出：\n\n  ```cpp\n  Default delimiter case:\n  read in     [std::quoted() quotes this string and embedded \"quotes\" too]\n  stored as   [\"std::quoted() quotes this string and embedded \\\"quotes\\\" too\"]\n  written out [std::quoted() quotes this string and embedded \"quotes\" too]\n   \n  Custom delimiter case:\n  read in     [std::quoted() quotes this string and embedded $quotes$ $too]\n  stored as   [$std::quoted() quotes this string and embedded %$quotes%$ %$too$]\n  written out [std::quoted() quotes this string and embedded $quotes$ $too]\n  ```\n\n### C++ 17\n\n- #### [nodiscard](./C++17/nodiscard.md)\n\n- \n\n### C++ 20\n\n[ddd]: ","slug":"C-Plus-Plus/新标准","published":1,"updated":"2025-09-14T02:36:11.009Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lph00034e4pgtsi38bp","content":"<h1>C++新标准</h1>\n<h3 id=\"C-11\">C++ 11</h3>\n<p>语法特性：</p>\n<ul>\n<li><code>auto</code></li>\n<li><code>decltype</code></li>\n<li>返回类型后置(<code>auto</code>+<code>decltype</code>)</li>\n<li>右值引用</li>\n<li>列表初始化</li>\n<li>移动语义(<code>std::move</code>)</li>\n<li>万能引用(<code>T&amp;&amp;</code>)</li>\n<li>智能指针(<code>share_ptr; wake_ptr; unique_ptr</code>)</li>\n<li>范围for循环</li>\n<li>委托构造函数</li>\n<li>继承构造函数</li>\n<li><code>final</code>和<code>override</code></li>\n<li><code>default</code></li>\n<li>函数<code>delete</code></li>\n<li><code>explicit</code></li>\n<li><code>constexpr</code></li>\n<li>强类型枚举(<code>enum class</code>)</li>\n<li>原始字符串字面量</li>\n<li>基于范围的<code>for</code>循环</li>\n<li><code>lambda</code>表达式</li>\n<li>内联命名空间</li>\n<li>右<code>&gt;</code>的优化</li>\n<li><code>noexcept</code></li>\n<li><code>char32_t</code>和<code>char16_t</code></li>\n</ul>\n<p>库特性：</p>\n<ul>\n<li>\n<p><code>chrono</code>库</p>\n</li>\n<li>\n<p><code>thread</code>库</p>\n</li>\n<li>\n<p><code>std::function</code></p>\n</li>\n<li>\n<p><code>std::bind</code></p>\n</li>\n<li>\n<p><code>std::move</code></p>\n</li>\n<li>\n<p><code>std::forword</code>：与万能引用配合使用</p>\n</li>\n<li>\n<p><code>std::array</code></p>\n</li>\n<li>\n<p><code>std::to_string()</code></p>\n</li>\n<li>\n<p><code>std::tuple</code>(元组)</p>\n</li>\n<li>\n<p><code>std::tie</code></p>\n</li>\n<li>\n<p><code>std::ref</code></p>\n</li>\n<li>\n<p><code>std::make_shared</code></p>\n</li>\n<li>\n<p>无序容器：</p>\n<ul>\n<li><code>std::unordered_map</code></li>\n<li><code>std::unordered_multimap</code></li>\n<li><code>std::unordered_set</code></li>\n<li><code>std::unordered_multiset</code></li>\n</ul>\n</li>\n<li>\n<p>内存模型</p>\n</li>\n<li>\n<p><code>std::async</code></p>\n</li>\n<li>\n<p><code>std::forward_list</code>（单链表）</p>\n</li>\n</ul>\n<h3 id=\"C-14\">C++ 14</h3>\n<ul>\n<li>\n<p>变量模板</p>\n</li>\n<li>\n<p>泛型<code>lambda</code>参数</p>\n</li>\n<li>\n<p><code>lambda</code>初始化捕获</p>\n</li>\n<li>\n<p>放宽<code>constexptr</code>函数限制</p>\n<p>在C++11中，constexpr函数的限制非常严格，要求其函数体仅能包含一个返回语句，且不能包含复杂的控制流语句（如循环、条件分支等）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C++11 constexpr阶乘函数的写法，只能使用递归</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">constexpr</span> <span class=\"type\">int</span> <span class=\"title\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n &lt;= <span class=\"number\">1</span> ? <span class=\"number\">1</span> : (n * <span class=\"built_in\">factorial</span>(n - <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而在C++14中，允许在其函数体内使用更复杂的控制流结构和局部变量声明，也可以有多个返回语句，只要最终的结果能够在编译时计算得出即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C++14 constexpr阶乘函数的写法，可以使用循环</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">constexpr</span> <span class=\"type\">int</span> <span class=\"title\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        ret += i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>[[deprecated]]</code>(废弃标志)</p>\n<p>标记已弃用的函数、类或其他声明。这有助于编译器在编译时发出警告，提醒开发者不应再使用某个已标记为过时的API</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[deprecated]]</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TriassicPeriod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstd::clog &lt;&lt; <span class=\"string\">&quot;Triassic Period: [251.9 - 208.5] million years ago.\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[[<span class=\"built_in\">deprecated</span>(<span class=\"string\">&quot;Use NeogenePeriod() instead.&quot;</span>)]]\t\t<span class=\"comment\">// 弃用并标明弃用原因</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">JurassicPeriod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstd::clog &lt;&lt; <span class=\"string\">&quot;Jurassic Period: [201.3 - 152.1] million years ago.\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>std::shared_timed_mutex</code></p>\n<p>超时读写锁。<a href=\"./C++14/shared_timed_mutex.md\">shared_timed_mutex</a></p>\n</li>\n<li>\n<p><code>std::shared_lock</code></p>\n</li>\n<li>\n<p><code>std::make_unique</code></p>\n</li>\n<li>\n<p><code>std::exchange</code></p>\n<p><mark>原子地</mark>交换一个对象的值，并返回其旧值。这个函数在处理资源管理、状态转换等场景时特别有用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iterator&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">stream</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> flags_type = <span class=\"type\">int</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">flags_type <span class=\"title\">flags</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> flags_; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Replaces flags_ by newf, and returns the old value.</span></span><br><span class=\"line\">    <span class=\"function\">flags_type <span class=\"title\">flags</span><span class=\"params\">(flags_type newf)</span> </span>&#123; <span class=\"keyword\">return</span> std::<span class=\"built_in\">exchange</span>(flags_, newf); &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    flags_type flags_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"string\">&quot;f()&quot;</span>; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    stream s;</span><br><span class=\"line\"> </span><br><span class=\"line\">    std::cout &lt;&lt; s.<span class=\"built_in\">flags</span>() &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; s.<span class=\"built_in\">flags</span>(<span class=\"number\">12</span>) &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; s.<span class=\"built_in\">flags</span>() &lt;&lt; <span class=\"string\">&quot;\\n\\n&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; v;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Since the second template parameter has a default value, it is possible</span></span><br><span class=\"line\">    <span class=\"comment\">// to use a braced-init-list as second argument. The expression below</span></span><br><span class=\"line\">    <span class=\"comment\">// is equivalent to std::exchange(v, std::vector&lt;int&gt;&#123;1, 2, 3, 4&#125;);</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    std::<span class=\"built_in\">exchange</span>(v, &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">    std::<span class=\"built_in\">copy</span>(<span class=\"built_in\">begin</span>(v), <span class=\"built_in\">end</span>(v), std::<span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(std::cout, <span class=\"string\">&quot;, &quot;</span>));</span><br><span class=\"line\"> </span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\n\\n&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">void</span> (*fun)();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// The default value of template parameter also makes possible to use a</span></span><br><span class=\"line\">    <span class=\"comment\">// normal function as second argument. The expression below is equivalent to</span></span><br><span class=\"line\">    <span class=\"comment\">// std::exchange(fun, static_cast&lt;void(*)()&gt;(f))</span></span><br><span class=\"line\">    std::<span class=\"built_in\">exchange</span>(fun, f);</span><br><span class=\"line\">    <span class=\"built_in\">fun</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\n\\nFibonacci sequence: &quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> a&#123;<span class=\"number\">0</span>&#125;, b&#123;<span class=\"number\">1</span>&#125;; a &lt; <span class=\"number\">100</span>; a = std::<span class=\"built_in\">exchange</span>(b, a + b))</span><br><span class=\"line\">        std::cout &lt;&lt; a &lt;&lt; <span class=\"string\">&quot;, &quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;...\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">0</span><br><span class=\"line\">12</span><br><span class=\"line\"></span><br><span class=\"line\">1, 2, 3, 4,</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\"></span><br><span class=\"line\">Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>std::quoted</code></p>\n<p>具体使用案例：（来自<code>cppreference</code>）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iomanip&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">default_delimiter</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> std::string in = <span class=\"string\">&quot;std::quoted() quotes this string and embedded \\&quot;quotes\\&quot; too&quot;</span>;</span><br><span class=\"line\">    std::stringstream ss;</span><br><span class=\"line\">    ss &lt;&lt; std::<span class=\"built_in\">quoted</span>(in);</span><br><span class=\"line\">    std::string out;</span><br><span class=\"line\">    ss &gt;&gt; std::<span class=\"built_in\">quoted</span>(out);</span><br><span class=\"line\"> </span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Default delimiter case:\\n&quot;</span></span><br><span class=\"line\">                 <span class=\"string\">&quot;read in     [&quot;</span> &lt;&lt; in &lt;&lt; <span class=\"string\">&quot;]\\n&quot;</span></span><br><span class=\"line\">                 <span class=\"string\">&quot;stored as   [&quot;</span> &lt;&lt; ss.<span class=\"built_in\">str</span>() &lt;&lt; <span class=\"string\">&quot;]\\n&quot;</span></span><br><span class=\"line\">                 <span class=\"string\">&quot;written out [&quot;</span> &lt;&lt; out &lt;&lt; <span class=\"string\">&quot;]\\n\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">custom_delimiter</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> delim&#123;<span class=\"string\">&#x27;$&#x27;</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> escape&#123;<span class=\"string\">&#x27;%&#x27;</span>&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">const</span> std::string in = <span class=\"string\">&quot;std::quoted() quotes this string and embedded $quotes$ $too&quot;</span>;</span><br><span class=\"line\">    std::stringstream ss;</span><br><span class=\"line\">    ss &lt;&lt; std::<span class=\"built_in\">quoted</span>(in, delim, escape);</span><br><span class=\"line\">    std::string out;</span><br><span class=\"line\">    ss &gt;&gt; std::<span class=\"built_in\">quoted</span>(out, delim, escape);</span><br><span class=\"line\"> </span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Custom delimiter case:\\n&quot;</span></span><br><span class=\"line\">                 <span class=\"string\">&quot;read in     [&quot;</span> &lt;&lt; in &lt;&lt; <span class=\"string\">&quot;]\\n&quot;</span></span><br><span class=\"line\">                 <span class=\"string\">&quot;stored as   [&quot;</span> &lt;&lt; ss.<span class=\"built_in\">str</span>() &lt;&lt; <span class=\"string\">&quot;]\\n&quot;</span></span><br><span class=\"line\">                 <span class=\"string\">&quot;written out [&quot;</span> &lt;&lt; out &lt;&lt; <span class=\"string\">&quot;]\\n\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">default_delimiter</span>();</span><br><span class=\"line\">    <span class=\"built_in\">custom_delimiter</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Default delimiter <span class=\"keyword\">case</span>:</span><br><span class=\"line\">read in     [std::<span class=\"built_in\">quoted</span>() quotes <span class=\"keyword\">this</span> string <span class=\"keyword\">and</span> embedded <span class=\"string\">&quot;quotes&quot;</span> too]</span><br><span class=\"line\">stored as   [<span class=\"string\">&quot;std::quoted() quotes this string and embedded \\&quot;quotes\\&quot; too&quot;</span>]</span><br><span class=\"line\">written out [std::<span class=\"built_in\">quoted</span>() quotes <span class=\"keyword\">this</span> string <span class=\"keyword\">and</span> embedded <span class=\"string\">&quot;quotes&quot;</span> too]</span><br><span class=\"line\"> </span><br><span class=\"line\">Custom delimiter <span class=\"keyword\">case</span>:</span><br><span class=\"line\">read in     [std::<span class=\"built_in\">quoted</span>() quotes <span class=\"keyword\">this</span> string <span class=\"keyword\">and</span> embedded $quotes$ $too]</span><br><span class=\"line\">stored as   [$std::<span class=\"built_in\">quoted</span>() quotes <span class=\"keyword\">this</span> string <span class=\"keyword\">and</span> embedded %$quotes%$ %$too$]</span><br><span class=\"line\">written out [std::<span class=\"built_in\">quoted</span>() quotes <span class=\"keyword\">this</span> string <span class=\"keyword\">and</span> embedded $quotes$ $too]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"C-17\">C++ 17</h3>\n<ul>\n<li>\n<h4 id=\"nodiscard\"><a href=\"./C++17/nodiscard.md\">nodiscard</a></h4>\n</li>\n<li></li>\n</ul>\n<h3 id=\"C-20\">C++ 20</h3>\n<p>[ddd]:</p>\n","excerpt":"","more":"<h1>C++新标准</h1>\n<h3 id=\"C-11\">C++ 11</h3>\n<p>语法特性：</p>\n<ul>\n<li><code>auto</code></li>\n<li><code>decltype</code></li>\n<li>返回类型后置(<code>auto</code>+<code>decltype</code>)</li>\n<li>右值引用</li>\n<li>列表初始化</li>\n<li>移动语义(<code>std::move</code>)</li>\n<li>万能引用(<code>T&amp;&amp;</code>)</li>\n<li>智能指针(<code>share_ptr; wake_ptr; unique_ptr</code>)</li>\n<li>范围for循环</li>\n<li>委托构造函数</li>\n<li>继承构造函数</li>\n<li><code>final</code>和<code>override</code></li>\n<li><code>default</code></li>\n<li>函数<code>delete</code></li>\n<li><code>explicit</code></li>\n<li><code>constexpr</code></li>\n<li>强类型枚举(<code>enum class</code>)</li>\n<li>原始字符串字面量</li>\n<li>基于范围的<code>for</code>循环</li>\n<li><code>lambda</code>表达式</li>\n<li>内联命名空间</li>\n<li>右<code>&gt;</code>的优化</li>\n<li><code>noexcept</code></li>\n<li><code>char32_t</code>和<code>char16_t</code></li>\n</ul>\n<p>库特性：</p>\n<ul>\n<li>\n<p><code>chrono</code>库</p>\n</li>\n<li>\n<p><code>thread</code>库</p>\n</li>\n<li>\n<p><code>std::function</code></p>\n</li>\n<li>\n<p><code>std::bind</code></p>\n</li>\n<li>\n<p><code>std::move</code></p>\n</li>\n<li>\n<p><code>std::forword</code>：与万能引用配合使用</p>\n</li>\n<li>\n<p><code>std::array</code></p>\n</li>\n<li>\n<p><code>std::to_string()</code></p>\n</li>\n<li>\n<p><code>std::tuple</code>(元组)</p>\n</li>\n<li>\n<p><code>std::tie</code></p>\n</li>\n<li>\n<p><code>std::ref</code></p>\n</li>\n<li>\n<p><code>std::make_shared</code></p>\n</li>\n<li>\n<p>无序容器：</p>\n<ul>\n<li><code>std::unordered_map</code></li>\n<li><code>std::unordered_multimap</code></li>\n<li><code>std::unordered_set</code></li>\n<li><code>std::unordered_multiset</code></li>\n</ul>\n</li>\n<li>\n<p>内存模型</p>\n</li>\n<li>\n<p><code>std::async</code></p>\n</li>\n<li>\n<p><code>std::forward_list</code>（单链表）</p>\n</li>\n</ul>\n<h3 id=\"C-14\">C++ 14</h3>\n<ul>\n<li>\n<p>变量模板</p>\n</li>\n<li>\n<p>泛型<code>lambda</code>参数</p>\n</li>\n<li>\n<p><code>lambda</code>初始化捕获</p>\n</li>\n<li>\n<p>放宽<code>constexptr</code>函数限制</p>\n<p>在C++11中，constexpr函数的限制非常严格，要求其函数体仅能包含一个返回语句，且不能包含复杂的控制流语句（如循环、条件分支等）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C++11 constexpr阶乘函数的写法，只能使用递归</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">constexpr</span> <span class=\"type\">int</span> <span class=\"title\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n &lt;= <span class=\"number\">1</span> ? <span class=\"number\">1</span> : (n * <span class=\"built_in\">factorial</span>(n - <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而在C++14中，允许在其函数体内使用更复杂的控制流结构和局部变量声明，也可以有多个返回语句，只要最终的结果能够在编译时计算得出即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C++14 constexpr阶乘函数的写法，可以使用循环</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">constexpr</span> <span class=\"type\">int</span> <span class=\"title\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        ret += i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>[[deprecated]]</code>(废弃标志)</p>\n<p>标记已弃用的函数、类或其他声明。这有助于编译器在编译时发出警告，提醒开发者不应再使用某个已标记为过时的API</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[deprecated]]</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TriassicPeriod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstd::clog &lt;&lt; <span class=\"string\">&quot;Triassic Period: [251.9 - 208.5] million years ago.\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[[<span class=\"built_in\">deprecated</span>(<span class=\"string\">&quot;Use NeogenePeriod() instead.&quot;</span>)]]\t\t<span class=\"comment\">// 弃用并标明弃用原因</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">JurassicPeriod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstd::clog &lt;&lt; <span class=\"string\">&quot;Jurassic Period: [201.3 - 152.1] million years ago.\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>std::shared_timed_mutex</code></p>\n<p>超时读写锁。<a href=\"./C++14/shared_timed_mutex.md\">shared_timed_mutex</a></p>\n</li>\n<li>\n<p><code>std::shared_lock</code></p>\n</li>\n<li>\n<p><code>std::make_unique</code></p>\n</li>\n<li>\n<p><code>std::exchange</code></p>\n<p><mark>原子地</mark>交换一个对象的值，并返回其旧值。这个函数在处理资源管理、状态转换等场景时特别有用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iterator&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">stream</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> flags_type = <span class=\"type\">int</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">flags_type <span class=\"title\">flags</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> flags_; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Replaces flags_ by newf, and returns the old value.</span></span><br><span class=\"line\">    <span class=\"function\">flags_type <span class=\"title\">flags</span><span class=\"params\">(flags_type newf)</span> </span>&#123; <span class=\"keyword\">return</span> std::<span class=\"built_in\">exchange</span>(flags_, newf); &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    flags_type flags_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"string\">&quot;f()&quot;</span>; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    stream s;</span><br><span class=\"line\"> </span><br><span class=\"line\">    std::cout &lt;&lt; s.<span class=\"built_in\">flags</span>() &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; s.<span class=\"built_in\">flags</span>(<span class=\"number\">12</span>) &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; s.<span class=\"built_in\">flags</span>() &lt;&lt; <span class=\"string\">&quot;\\n\\n&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; v;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Since the second template parameter has a default value, it is possible</span></span><br><span class=\"line\">    <span class=\"comment\">// to use a braced-init-list as second argument. The expression below</span></span><br><span class=\"line\">    <span class=\"comment\">// is equivalent to std::exchange(v, std::vector&lt;int&gt;&#123;1, 2, 3, 4&#125;);</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    std::<span class=\"built_in\">exchange</span>(v, &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">    std::<span class=\"built_in\">copy</span>(<span class=\"built_in\">begin</span>(v), <span class=\"built_in\">end</span>(v), std::<span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(std::cout, <span class=\"string\">&quot;, &quot;</span>));</span><br><span class=\"line\"> </span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\n\\n&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">void</span> (*fun)();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// The default value of template parameter also makes possible to use a</span></span><br><span class=\"line\">    <span class=\"comment\">// normal function as second argument. The expression below is equivalent to</span></span><br><span class=\"line\">    <span class=\"comment\">// std::exchange(fun, static_cast&lt;void(*)()&gt;(f))</span></span><br><span class=\"line\">    std::<span class=\"built_in\">exchange</span>(fun, f);</span><br><span class=\"line\">    <span class=\"built_in\">fun</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\n\\nFibonacci sequence: &quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> a&#123;<span class=\"number\">0</span>&#125;, b&#123;<span class=\"number\">1</span>&#125;; a &lt; <span class=\"number\">100</span>; a = std::<span class=\"built_in\">exchange</span>(b, a + b))</span><br><span class=\"line\">        std::cout &lt;&lt; a &lt;&lt; <span class=\"string\">&quot;, &quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;...\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">0</span><br><span class=\"line\">12</span><br><span class=\"line\"></span><br><span class=\"line\">1, 2, 3, 4,</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\"></span><br><span class=\"line\">Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>std::quoted</code></p>\n<p>具体使用案例：（来自<code>cppreference</code>）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iomanip&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">default_delimiter</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> std::string in = <span class=\"string\">&quot;std::quoted() quotes this string and embedded \\&quot;quotes\\&quot; too&quot;</span>;</span><br><span class=\"line\">    std::stringstream ss;</span><br><span class=\"line\">    ss &lt;&lt; std::<span class=\"built_in\">quoted</span>(in);</span><br><span class=\"line\">    std::string out;</span><br><span class=\"line\">    ss &gt;&gt; std::<span class=\"built_in\">quoted</span>(out);</span><br><span class=\"line\"> </span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Default delimiter case:\\n&quot;</span></span><br><span class=\"line\">                 <span class=\"string\">&quot;read in     [&quot;</span> &lt;&lt; in &lt;&lt; <span class=\"string\">&quot;]\\n&quot;</span></span><br><span class=\"line\">                 <span class=\"string\">&quot;stored as   [&quot;</span> &lt;&lt; ss.<span class=\"built_in\">str</span>() &lt;&lt; <span class=\"string\">&quot;]\\n&quot;</span></span><br><span class=\"line\">                 <span class=\"string\">&quot;written out [&quot;</span> &lt;&lt; out &lt;&lt; <span class=\"string\">&quot;]\\n\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">custom_delimiter</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> delim&#123;<span class=\"string\">&#x27;$&#x27;</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> escape&#123;<span class=\"string\">&#x27;%&#x27;</span>&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">const</span> std::string in = <span class=\"string\">&quot;std::quoted() quotes this string and embedded $quotes$ $too&quot;</span>;</span><br><span class=\"line\">    std::stringstream ss;</span><br><span class=\"line\">    ss &lt;&lt; std::<span class=\"built_in\">quoted</span>(in, delim, escape);</span><br><span class=\"line\">    std::string out;</span><br><span class=\"line\">    ss &gt;&gt; std::<span class=\"built_in\">quoted</span>(out, delim, escape);</span><br><span class=\"line\"> </span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Custom delimiter case:\\n&quot;</span></span><br><span class=\"line\">                 <span class=\"string\">&quot;read in     [&quot;</span> &lt;&lt; in &lt;&lt; <span class=\"string\">&quot;]\\n&quot;</span></span><br><span class=\"line\">                 <span class=\"string\">&quot;stored as   [&quot;</span> &lt;&lt; ss.<span class=\"built_in\">str</span>() &lt;&lt; <span class=\"string\">&quot;]\\n&quot;</span></span><br><span class=\"line\">                 <span class=\"string\">&quot;written out [&quot;</span> &lt;&lt; out &lt;&lt; <span class=\"string\">&quot;]\\n\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">default_delimiter</span>();</span><br><span class=\"line\">    <span class=\"built_in\">custom_delimiter</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Default delimiter <span class=\"keyword\">case</span>:</span><br><span class=\"line\">read in     [std::<span class=\"built_in\">quoted</span>() quotes <span class=\"keyword\">this</span> string <span class=\"keyword\">and</span> embedded <span class=\"string\">&quot;quotes&quot;</span> too]</span><br><span class=\"line\">stored as   [<span class=\"string\">&quot;std::quoted() quotes this string and embedded \\&quot;quotes\\&quot; too&quot;</span>]</span><br><span class=\"line\">written out [std::<span class=\"built_in\">quoted</span>() quotes <span class=\"keyword\">this</span> string <span class=\"keyword\">and</span> embedded <span class=\"string\">&quot;quotes&quot;</span> too]</span><br><span class=\"line\"> </span><br><span class=\"line\">Custom delimiter <span class=\"keyword\">case</span>:</span><br><span class=\"line\">read in     [std::<span class=\"built_in\">quoted</span>() quotes <span class=\"keyword\">this</span> string <span class=\"keyword\">and</span> embedded $quotes$ $too]</span><br><span class=\"line\">stored as   [$std::<span class=\"built_in\">quoted</span>() quotes <span class=\"keyword\">this</span> string <span class=\"keyword\">and</span> embedded %$quotes%$ %$too$]</span><br><span class=\"line\">written out [std::<span class=\"built_in\">quoted</span>() quotes <span class=\"keyword\">this</span> string <span class=\"keyword\">and</span> embedded $quotes$ $too]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"C-17\">C++ 17</h3>\n<ul>\n<li>\n<h4 id=\"nodiscard\"><a href=\"./C++17/nodiscard.md\">nodiscard</a></h4>\n</li>\n<li></li>\n</ul>\n<h3 id=\"C-20\">C++ 20</h3>\n<p>[ddd]:</p>\n"},{"title":"C++语法","date":"2025-07-05T16:00:00.000Z","description":"C++语法","_content":"\n## C++语法\n### 强制类型转换\n\n#### static_cast\n\n> 用于基本数据类型之间的转换，以及在类层次结构中基类和派生类之间的指针或引用的转换。它在**编译时执行，不提供运行时类型检查**。\n>\n> > 如果对象所属的类重载了强制类型转换运算符 T（如 T 是 int、int* 或其他类型名），则 static_cast 也能用来进行对象到 T 类型的转换。\n>\n> > static_cast 不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。因为这些属于风险比较高的转换。\n\n例：\n\n```cpp\nint a = 10;\nint b = 3;\ndouble result = static_cast<double>(a) / static_cast<double>(b);\n```\n\n#### dynamic_cast\n\n> 用于类层次结构中的指针和引用的转换，它在运行时检查类型的安全性。它要求转换的类型必须包含至少一个虚函数。\n>\n> > **如果转换失败，*dynamic_cast*会返回*nullptr***。\n\n例：\n\n```cpp\nclass Base {};\nclass Derived : public Base {};\nBase* basePtr = new Derived();\nDerived* derivedPtr = dynamic_cast<Derived*>(basePtr); // 安全的转换\n```\n\ndynamic_cast与reinterpret_cast的区别：\n\n- 用 reinterpret_cast 可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，但是这种转换不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。\n- dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 nullptr 指针。\n\n#### const_cast\n\n> 仅用于去除变量的*const*属性。它主要用于操作指向常量对象的指针或引用的*const*属性。\n\n例：\n\n```cpp\nconst int a = 10;\nconst int* p = &a;\nint* q = const_cast<int*>(p);\n*q = 20; // 现在*q可以被修改\n```\n\n#### reinterpret_cast\n\n> 用于低级的强制类型转换，如改变指针类型或将指针转换为足够长度的整型。**它仅仅复制位模式，不改变值本身**。\n>\n> > [!warning]\n> >\n> > 这种转换是不安全的，因为它不保证转换结果的有效性：\n> >\n> > > 例如，执意把一个 int* 指针、函数指针或其他类型的指针转换成 string* 类型的指针也是可以的，至于以后用转换后的指针调用 string 类的成员函数引发错误，则需要程序员自行承担查找错误的烦琐工作\n\n例：\n\n```cpp\nint* a = new int;\ndouble* d = reinterpret_cast<double*>(a);\n```\n\n### 主题\n","source":"_posts/C-Plus-Plus/语法.md","raw":"---\ntitle: C++语法\ndate: 2025-07-06\ndescription: C++语法\n---\n\n## C++语法\n### 强制类型转换\n\n#### static_cast\n\n> 用于基本数据类型之间的转换，以及在类层次结构中基类和派生类之间的指针或引用的转换。它在**编译时执行，不提供运行时类型检查**。\n>\n> > 如果对象所属的类重载了强制类型转换运算符 T（如 T 是 int、int* 或其他类型名），则 static_cast 也能用来进行对象到 T 类型的转换。\n>\n> > static_cast 不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。因为这些属于风险比较高的转换。\n\n例：\n\n```cpp\nint a = 10;\nint b = 3;\ndouble result = static_cast<double>(a) / static_cast<double>(b);\n```\n\n#### dynamic_cast\n\n> 用于类层次结构中的指针和引用的转换，它在运行时检查类型的安全性。它要求转换的类型必须包含至少一个虚函数。\n>\n> > **如果转换失败，*dynamic_cast*会返回*nullptr***。\n\n例：\n\n```cpp\nclass Base {};\nclass Derived : public Base {};\nBase* basePtr = new Derived();\nDerived* derivedPtr = dynamic_cast<Derived*>(basePtr); // 安全的转换\n```\n\ndynamic_cast与reinterpret_cast的区别：\n\n- 用 reinterpret_cast 可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，但是这种转换不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。\n- dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 nullptr 指针。\n\n#### const_cast\n\n> 仅用于去除变量的*const*属性。它主要用于操作指向常量对象的指针或引用的*const*属性。\n\n例：\n\n```cpp\nconst int a = 10;\nconst int* p = &a;\nint* q = const_cast<int*>(p);\n*q = 20; // 现在*q可以被修改\n```\n\n#### reinterpret_cast\n\n> 用于低级的强制类型转换，如改变指针类型或将指针转换为足够长度的整型。**它仅仅复制位模式，不改变值本身**。\n>\n> > [!warning]\n> >\n> > 这种转换是不安全的，因为它不保证转换结果的有效性：\n> >\n> > > 例如，执意把一个 int* 指针、函数指针或其他类型的指针转换成 string* 类型的指针也是可以的，至于以后用转换后的指针调用 string 类的成员函数引发错误，则需要程序员自行承担查找错误的烦琐工作\n\n例：\n\n```cpp\nint* a = new int;\ndouble* d = reinterpret_cast<double*>(a);\n```\n\n### 主题\n","slug":"C-Plus-Plus/语法","published":1,"updated":"2025-09-14T02:36:11.009Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpi00054e4p5rx91g7x","content":"<h2 id=\"C-语法\">C++语法</h2>\n<h3 id=\"强制类型转换\">强制类型转换</h3>\n<h4 id=\"static-cast\">static_cast</h4>\n<blockquote>\n<p>用于基本数据类型之间的转换，以及在类层次结构中基类和派生类之间的指针或引用的转换。它在<strong>编译时执行，不提供运行时类型检查</strong>。</p>\n<blockquote>\n<p>如果对象所属的类重载了强制类型转换运算符 T（如 T 是 int、int* 或其他类型名），则 static_cast 也能用来进行对象到 T 类型的转换。</p>\n</blockquote>\n<blockquote>\n<p>static_cast 不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。因为这些属于风险比较高的转换。</p>\n</blockquote>\n</blockquote>\n<p>例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> b = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"type\">double</span> result = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">double</span>&gt;(a) / <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">double</span>&gt;(b);</span><br></pre></td></tr></table></figure>\n<h4 id=\"dynamic-cast\">dynamic_cast</h4>\n<blockquote>\n<p>用于类层次结构中的指针和引用的转换，它在运行时检查类型的安全性。它要求转换的类型必须包含至少一个虚函数。</p>\n<blockquote>\n<p><strong>如果转换失败，<em>dynamic_cast</em>会返回<em>nullptr</em></strong>。</p>\n</blockquote>\n</blockquote>\n<p>例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base &#123;&#125;;</span><br><span class=\"line\">Base* basePtr = <span class=\"keyword\">new</span> <span class=\"built_in\">Derived</span>();</span><br><span class=\"line\">Derived* derivedPtr = <span class=\"built_in\">dynamic_cast</span>&lt;Derived*&gt;(basePtr); <span class=\"comment\">// 安全的转换</span></span><br></pre></td></tr></table></figure>\n<p>dynamic_cast与reinterpret_cast的区别：</p>\n<ul>\n<li>用 reinterpret_cast 可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，但是这种转换不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。</li>\n<li>dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 nullptr 指针。</li>\n</ul>\n<h4 id=\"const-cast\">const_cast</h4>\n<blockquote>\n<p>仅用于去除变量的<em>const</em>属性。它主要用于操作指向常量对象的指针或引用的<em>const</em>属性。</p>\n</blockquote>\n<p>例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span>* p = &amp;a;</span><br><span class=\"line\"><span class=\"type\">int</span>* q = <span class=\"built_in\">const_cast</span>&lt;<span class=\"type\">int</span>*&gt;(p);</span><br><span class=\"line\">*q = <span class=\"number\">20</span>; <span class=\"comment\">// 现在*q可以被修改</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"reinterpret-cast\">reinterpret_cast</h4>\n<blockquote>\n<p>用于低级的强制类型转换，如改变指针类型或将指针转换为足够长度的整型。<strong>它仅仅复制位模式，不改变值本身</strong>。</p>\n<blockquote>\n<p>[!warning]</p>\n<p>这种转换是不安全的，因为它不保证转换结果的有效性：</p>\n<blockquote>\n<p>例如，执意把一个 int* 指针、函数指针或其他类型的指针转换成 string* 类型的指针也是可以的，至于以后用转换后的指针调用 string 类的成员函数引发错误，则需要程序员自行承担查找错误的烦琐工作</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>* a = <span class=\"keyword\">new</span> <span class=\"type\">int</span>;</span><br><span class=\"line\"><span class=\"type\">double</span>* d = <span class=\"built_in\">reinterpret_cast</span>&lt;<span class=\"type\">double</span>*&gt;(a);</span><br></pre></td></tr></table></figure>\n<h3 id=\"主题\">主题</h3>\n","excerpt":"","more":"<h2 id=\"C-语法\">C++语法</h2>\n<h3 id=\"强制类型转换\">强制类型转换</h3>\n<h4 id=\"static-cast\">static_cast</h4>\n<blockquote>\n<p>用于基本数据类型之间的转换，以及在类层次结构中基类和派生类之间的指针或引用的转换。它在<strong>编译时执行，不提供运行时类型检查</strong>。</p>\n<blockquote>\n<p>如果对象所属的类重载了强制类型转换运算符 T（如 T 是 int、int* 或其他类型名），则 static_cast 也能用来进行对象到 T 类型的转换。</p>\n</blockquote>\n<blockquote>\n<p>static_cast 不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。因为这些属于风险比较高的转换。</p>\n</blockquote>\n</blockquote>\n<p>例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> b = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"type\">double</span> result = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">double</span>&gt;(a) / <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">double</span>&gt;(b);</span><br></pre></td></tr></table></figure>\n<h4 id=\"dynamic-cast\">dynamic_cast</h4>\n<blockquote>\n<p>用于类层次结构中的指针和引用的转换，它在运行时检查类型的安全性。它要求转换的类型必须包含至少一个虚函数。</p>\n<blockquote>\n<p><strong>如果转换失败，<em>dynamic_cast</em>会返回<em>nullptr</em></strong>。</p>\n</blockquote>\n</blockquote>\n<p>例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base &#123;&#125;;</span><br><span class=\"line\">Base* basePtr = <span class=\"keyword\">new</span> <span class=\"built_in\">Derived</span>();</span><br><span class=\"line\">Derived* derivedPtr = <span class=\"built_in\">dynamic_cast</span>&lt;Derived*&gt;(basePtr); <span class=\"comment\">// 安全的转换</span></span><br></pre></td></tr></table></figure>\n<p>dynamic_cast与reinterpret_cast的区别：</p>\n<ul>\n<li>用 reinterpret_cast 可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，但是这种转换不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。</li>\n<li>dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 nullptr 指针。</li>\n</ul>\n<h4 id=\"const-cast\">const_cast</h4>\n<blockquote>\n<p>仅用于去除变量的<em>const</em>属性。它主要用于操作指向常量对象的指针或引用的<em>const</em>属性。</p>\n</blockquote>\n<p>例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span>* p = &amp;a;</span><br><span class=\"line\"><span class=\"type\">int</span>* q = <span class=\"built_in\">const_cast</span>&lt;<span class=\"type\">int</span>*&gt;(p);</span><br><span class=\"line\">*q = <span class=\"number\">20</span>; <span class=\"comment\">// 现在*q可以被修改</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"reinterpret-cast\">reinterpret_cast</h4>\n<blockquote>\n<p>用于低级的强制类型转换，如改变指针类型或将指针转换为足够长度的整型。<strong>它仅仅复制位模式，不改变值本身</strong>。</p>\n<blockquote>\n<p>[!warning]</p>\n<p>这种转换是不安全的，因为它不保证转换结果的有效性：</p>\n<blockquote>\n<p>例如，执意把一个 int* 指针、函数指针或其他类型的指针转换成 string* 类型的指针也是可以的，至于以后用转换后的指针调用 string 类的成员函数引发错误，则需要程序员自行承担查找错误的烦琐工作</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>* a = <span class=\"keyword\">new</span> <span class=\"type\">int</span>;</span><br><span class=\"line\"><span class=\"type\">double</span>* d = <span class=\"built_in\">reinterpret_cast</span>&lt;<span class=\"type\">double</span>*&gt;(a);</span><br></pre></td></tr></table></figure>\n<h3 id=\"主题\">主题</h3>\n"},{"title":"leetcode-1477","date":"2025-07-05T16:00:00.000Z","description":"找到两个和为目标值且不重复的子数组","_content":"\n#### leetcode-1477: 找两个和为目标值且不重复的子数组\n\n- 双指针\n- 动态规划\n\n```cpp\n```\n\n","source":"_posts/LeetCode/leetcode-1477.md","raw":"---\ntitle: leetcode-1477\ndate: 2025-07-06\ndescription: 找到两个和为目标值且不重复的子数组\n---\n\n#### leetcode-1477: 找两个和为目标值且不重复的子数组\n\n- 双指针\n- 动态规划\n\n```cpp\n```\n\n","slug":"LeetCode/leetcode-1477","published":1,"updated":"2025-09-14T02:36:11.009Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpl00094e4p2eaihmhk","content":"<h4 id=\"leetcode-1477-找两个和为目标值且不重复的子数组\">leetcode-1477: 找两个和为目标值且不重复的子数组</h4>\n<ul>\n<li>双指针</li>\n<li>动态规划</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h4 id=\"leetcode-1477-找两个和为目标值且不重复的子数组\">leetcode-1477: 找两个和为目标值且不重复的子数组</h4>\n<ul>\n<li>双指针</li>\n<li>动态规划</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"leetcode-31","date":"2025-07-05T16:00:00.000Z","description":"下一个排列","_content":"\n### leetcode-31：下一个排列\n\n题目描述：[下一个排列](https://leetcode.cn/problems/next-permutation/description/)。\n\n#### 解题思路：\n\n\n\n#### 实现：\n\n","source":"_posts/LeetCode/leetcode-31.md","raw":"---\ntitle: leetcode-31\ndate: 2025-07-06\ndescription: 下一个排列\n---\n\n### leetcode-31：下一个排列\n\n题目描述：[下一个排列](https://leetcode.cn/problems/next-permutation/description/)。\n\n#### 解题思路：\n\n\n\n#### 实现：\n\n","slug":"LeetCode/leetcode-31","published":1,"updated":"2025-09-14T02:36:11.009Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpm000b4e4p6swa67yj","content":"<h3 id=\"leetcode-31：下一个排列\">leetcode-31：下一个排列</h3>\n<p>题目描述：<a href=\"https://leetcode.cn/problems/next-permutation/description/\">下一个排列</a>。</p>\n<h4 id=\"解题思路：\">解题思路：</h4>\n<h4 id=\"实现：\">实现：</h4>\n","excerpt":"","more":"<h3 id=\"leetcode-31：下一个排列\">leetcode-31：下一个排列</h3>\n<p>题目描述：<a href=\"https://leetcode.cn/problems/next-permutation/description/\">下一个排列</a>。</p>\n<h4 id=\"解题思路：\">解题思路：</h4>\n<h4 id=\"实现：\">实现：</h4>\n"},{"title":"C标准库","date":"2025-07-05T16:00:00.000Z","description":"C语言标准库函数","_content":"\n- `stdio.h`\n    - `void perror(const char* err)`\n- `stdlib.h`\n    - `int system(const char* command)`\n        在windows系统中，system函数直接在控制台调用一个command命令。  在Linux/Unix系统中，system函数会调用fork函数产生子进程，由子进程来执行shell command命令，命令执行完后随即返回原调用的进程。\n    - \n- ","source":"_posts/C语言/标准库.md","raw":"---\ntitle: C标准库\ndate: 2025-07-06\ndescription: C语言标准库函数\n---\n\n- `stdio.h`\n    - `void perror(const char* err)`\n- `stdlib.h`\n    - `int system(const char* command)`\n        在windows系统中，system函数直接在控制台调用一个command命令。  在Linux/Unix系统中，system函数会调用fork函数产生子进程，由子进程来执行shell command命令，命令执行完后随即返回原调用的进程。\n    - \n- ","slug":"C语言/标准库","published":1,"updated":"2025-09-14T02:36:11.009Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpm000c4e4pfp2v24zh","content":"<ul>\n<li><code>stdio.h</code>\n<ul>\n<li><code>void perror(const char* err)</code></li>\n</ul>\n</li>\n<li><code>stdlib.h</code>\n<ul>\n<li><code>int system(const char* command)</code><br>\n在windows系统中，system函数直接在控制台调用一个command命令。  在Linux/Unix系统中，system函数会调用fork函数产生子进程，由子进程来执行shell command命令，命令执行完后随即返回原调用的进程。</li>\n<li></li>\n</ul>\n</li>\n<li></li>\n</ul>\n","excerpt":"","more":"<ul>\n<li><code>stdio.h</code>\n<ul>\n<li><code>void perror(const char* err)</code></li>\n</ul>\n</li>\n<li><code>stdlib.h</code>\n<ul>\n<li><code>int system(const char* command)</code><br>\n在windows系统中，system函数直接在控制台调用一个command命令。  在Linux/Unix系统中，system函数会调用fork函数产生子进程，由子进程来执行shell command命令，命令执行完后随即返回原调用的进程。</li>\n<li></li>\n</ul>\n</li>\n<li></li>\n</ul>\n"},{"title":"Markdown语法测试文章","date":"2025-07-05T16:00:00.000Z","description":"Markdown渲染效果测试","_content":"\n## 关于Mdmdt主题\n**Mdmdt **是 markdown minimalism document theme 的缩写，意为: **Markdown极简文档主题**。\n**Mdmdt**[^1]是深度定制的个性化Typora主题，其目的是打造一个**清爽极简**的文档样式。\n\n> [!NOte]\n>\n> **注意：**mdmdt.css 文件中包含了亮色和暗色两者主题，会跟随系统模式自动切换亮暗主题。 `This is a single line code style`\n>\n> **Attention:** The MDMDT.CSS file contains both light and dark themes, which will automatically switch between light and dark themes according to the system mode.\n\n## 文本\n这是一段正文内容样式，以下是不同文本样式效果：**这是加粗文本样式**, <u>这是下划线样式</u>, *这是斜体字样式*,  [这是超链接样式: https://github.com/cayxc/mdmdt](https://github.com/cayxc/mdmdt),  `This is a single line code style`,  ~~这是删除线效果样式~~,  ==这是文字高亮效果==，上下标样式: $\\LaTeX$, X^2^, H~2~O, <span style='background:var(--color-2-0-c)'> 这是鼠标选中效果 </span>,  键盘键样式：<kbd>Command+Q</kbd> 🐳 😀 🇨🇳\n\nThis is a text content style and the following are the effects of different text styles: **This is a bold text style**,  [This is a hyperlink style: https://github.com/cayxc/mdmdt](https://github.com/cayxc/mdmdt), *This is the italic font style*, ~~This is the strikethrough effect style~~, <u>This is the underline style</u>, `This is a single line code style`,  keyboard key style: <kbd>Command+Q</kbd>,  $\\text{LaTeX}$ X^2^H~2~O, ==This is the text highlighting effect==, <span style='background:var(--color-2-0-c)'>This is the mouse selection effect</span>  🐳 😀 🇨🇳\n\n<!-- 这是注释内容......, This is the annotation content -->\n\n## 数学公式\n\n直接使用公式：\n\n$$\n\\begin{aligned} I &=\\int_0^{ct}\\frac{r}{\\sqrt{c^2t^2 -r^2}}\\int_0^{2\\pi} m^2(m+n) d\\theta dr\\&=\\int_0^{ct}\\frac{r}{\\sqrt{c^2t^2 -r^2}}\\end{aligned}\n$$\n\n$$代入公式得到：$$  $$u(t,x,y) = (3x+y) c^2 t^2 + x^2(x+y)$$\n\n$$\nu(t,x,y) = \\frac{1}{2\\pi c} \\frac{\\partial}{\\partial t} \\iint\\limits_{r<ct} \\frac{m^2(m+n)}{\\sqrt{c^2t^2 -r^2 }}dmdn\n$$\n\n## 列表\n\n这些是列表样式效果:\n\n\n1. 这是有序列表 A\n2. 这是有序列表 B\n\n- This is Item 1.\n- This is Item 2.\n- [ ] Something is Not TODO.\n- [x] Something is DONE.\n\n---\n\n1. 这是有序列表 A\n2. 这是有序列表 B\n    1. 这是有序列表 A\n    2. 这是有序列表 B\n\n- This is Item 1.\n- This is Item 2.\n    - This is Item 1.\n    - This is Item 2.\n\n---\n\n这是嵌套列表样式：\n\n1. 这是有序列表 A\n2. 这是有序列表 B\n    - This is Item 1.\n    - This is Item 2.\n        - [x] Something is Not TODO.\n        - [ ] Something is DONE.\n\n- 这是有序列表 A\n- 这是有序列表 B\n    1. This is Item 1.\n    2. This is Item 2.\n        - [ ] Something is Not TODO.\n        - [x] Something is DONE.\n\n## 代码\n\n单行代码样式：`composer require --dev barryvdh/laravel-ide-helper`\n\n大段代码块样式：\n\n```javascript\n/**\n  * ----------------------------------------\n  * 设置递增的 level 编号\n  * ----------------------------------------\n  * @param tag obj 标签对象\n  */\nsetLevelNumber(tag){\n   try {\n     if ((typeof tag) != 'object') {\n       throw 'setLevelNumber() 调用时参数类型错误，必须是一个h标签的对象集合！';\n     }\n     let str = tag.id;\n     if (str.lastIndexOf('.') == -1) { //如果是一级目录形式 level-1000\n       let newValue = parseInt(str.slice(6)) + 1;\n       return 'level-' + newValue;\n     }\n   } catch (err) {\n     return err;\n   }\n}\n```\n\n## 表格样式\n\n| Left-Aligned            |                Center Aligned                | Right Aligned |\n| :---------------------- | :------------------------------------------: | ------------: |\n| This is the first line  | `this is code` some wordy text and some code |          $160 |\n| This is the second line |      some code: `this is code` centered      |      $1200.99 |\n| This is the third line  |             These are some texts             |        $125.5 |\n\n## 引用文本框\n\n> [!NOTE]\n>\n> This is a Note text box ...... `this is code style`\n> > \n> > This is a Note text box ......\n\n> [!TIP]\n>\n> - `this is code` This is a Tip text box ......\n>\n> - 代码段：\n> > ```bash\n> >   these are  codes...\n> >   ...\n> > ```\n>\n> - This is a Tip text box ......\n>\n> 1. This is itemA\n> 1. This is itemB\n> 1. This is itemC\n\n> [!IMPORTANT]\n>\n> This is a Important text box ......\n>\n\n> [!WARNING]\n>\n> This is a Warning text box ......\n\n> [!CAUTION]\n>\n> `this is  code` This is a Caution text box ......\n\n## 个性化图文布局\n### 单张图片\n\n![](https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt.png)\n\n### 多图并排\n\n图片的个性化排列使用方式是将图片放到一个容器中，该容器为 `<section>`  标签，如下所示:\n\n1. 直接输入`<section>` 然后回车，如下：\n\n2. ```html\n   <section>\n   </section>\n   ```\n   \n3. 在 `<section>` 标签中插入图片，如下：\n\n```html\n   <section>\n     <!-- 想要几张图并排，就在此处插入几个 <img> 标签: <img src=\"图片的相对路径/绝对路径\"></img> -->   \n     <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-code.png\"></img>\n     <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-source.png\" style=\"width: 200px\"></img> <!-- 单独设置图片的宽度为200px -->\n     <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\"></img>\n   </section>\n```\n\n**效果预览**：\n\n<section>\n <img src=\"https://raw.gitcode.com/Li2112183373/image/blobs/22baa3d7eb76500687b96fb3f175ae03d02cf49c/mdmdt-math.png\"></img>\n <img src=\"https://raw.gitcode.com/Li2112183373/image/blobs/22baa3d7eb76500687b96fb3f175ae03d02cf49c/mdmdt-list.png\"></img>\n</section>\n\n\n---\n\n<section>\n <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-code.png\"></img>\n <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-1.png\" style=\"width: 200px\"></img>\n <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png\"></img>\n</section>\n\n\n---\n\n\n\n### 多张图其他排列方式\n\n一张大图在左，多张小图在右的图片排列，如下：\n\n```html\n<!-- 一张大图在左，多张小图在右 -->\n<section> \n  <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-1.png\"></img> <!-- 这是第1列 -->\n  <span style=\"width: 240px\">  <!-- 这是第2列 -->\n     <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-2.png\"></img>\n \t <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-code.png\"></img>\n\t <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png\"></img>\n  </span>\n</section>\n```\n**效果预览**：\n\n<section>\n <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-light.png\"></img>\n <span style=\"width: 240px\">\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-ui-1.png\"></img>\n \t<img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-code.png\"></img>\n\t<img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-dark\"></img>\n </span>\n</section>\n\n\n---\n\n一张大图在右，多张小图在左的图片排列，如下：\n\n```html\n<!-- 一张大图在右，多张小图在左 -->\n<section> \n <span style=\"width: 240px\"> <!-- 这是第1列 -->\n    <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-2.png\"></img>\n \t<img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-code.png\"></img>\n\t<img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png\"></img>\n </span>\n <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-1.png\"></img> <!-- 这是第2列 -->\n</section>\n```\n**效果预览**：\n\n<section> \n <span style=\"width: 240px\">\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-ui-1.png\"></img>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-ui-2.png\"></img>\n\t<img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdtht-dark.png\"></img>\n </span>\n <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdtht-light.png\"></img>\n</section>\n\n\n\n### 图文并排\n\n图文的个性化排列使用方式是将图片和文字放到一个容器中，该容器为 `<section>`  标签，如下所示:\n\n1. 直接输入 `<section>` 然后回车，如下：\n\n2. ```html\n   <section>\n       \n   </section>\n   ```\n\n3. 在 `<section>` 标签中插入图片和文字，如下：\n\n4. ```html\n   <!-- 图片和单段文字排列示例 -->\n   <section>\n       <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png\"></img>  <!-- 这是第1列 -->\n   \t<span>这是文字在右，图片在左，图片和文字各占总宽度的50%的图文并排的样式。</span> <!-- 这是第2列 -->\n   </section>\n   \n   \n   <!-- 图片和单段文字排列示例 -->\n   <section>\n   \t<span>这是文字在左，图片在右，图片和文字各占总宽度的50%的图文并排的样式。</span> \n       <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png\"></img>  \n   </section>\n   \n   \n   <!-- 图片和多段文字排列示例 -->\n   <section>\n       <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png\"></img> <!-- 这是第1列 -->\n       <span style=\"width: 150px\">  <!-- 这是第2列，且单独设置该列的宽度为150px -->\n           <span>这是多段文字......</span> \n           <span>这是文字在右，图片在左，图片和文字各占总宽度的50%的图文并排的样式。</span>\n           <span>这是多段文字......</span> \n   \t</span>\n   </section>\n   \n   \n   <!-- 图片居中，文字在两边的排列示例 -->\n   <section>\n       <span>这是第1列，这是图片居中，文字在两边的样式</span> <!-- 这是第1列 -->\n       <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png\"></img>  <!-- 这是第2列, 单独设置图片的宽度为200px -->\n   \t<span>这是第3列，列的宽度比第1列小</span>          <!-- 这是第3列 -->\n   </section>\n   ```\n\n**效果预览**：\n\n<section>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\"></img> \n\t<span>这是单段文字，文字在右，图片在左，图片和文字各占总宽度的50%的图文并排的样式。</span> \n</section>\n\n\n---\n\n<section>\n\t<span>这是单段文字，文字在左，图片在右，图片和文字各占总宽度的50%的图文并排的样式。</span> <!-- 这是第1列 -->\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\"></img>  <!-- 这是第2列 -->\n</section>\n\n\n---\n\n<section>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\"></img>\n    <span>\n        <span>这是多段文字......</span>\n        <span>这是文字在右，图片在左，图片和文字各占总宽度的50%的图文并排的样式。</span>\n        <span>这是多段文字......</span>\n\t</span>\n</section>\n\n\n---\n\n<section>\n    <span>这是第1列内容<br>这是图片居中，两边是文字，且两边文字设置相同宽度的样式</span> <!-- 这是第1列 -->\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdtht-dark.png\"></img> <!-- 这是第2列 -->\n\t<span>这是第3列内容<br>这是图片居中，两边是文字，且两边文字设置相同宽度的样式</span> <!-- 这是第3列 -->\n</section>\n\n\n\n\n\n<section>\n    <span>这是中间是图片，两边是文字的图文样式<br>需要注意：该列文字内容较多，且未设置宽度。<strong>列的宽度比第3列大</strong></span>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdtht-dark.png\"></img>\n\t<span>这是第3列内容</span>\n</section>\n\n\n\n---\n\n图片和文字，图片设置宽度示例：\n\n```html\n<!-- 这是文字在右，图片在左的示例 -->\n<section>\n   <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png\" style=\"width:200px\"></img>\n   <span>这是文字在右，图片在左，且设置图片的宽度（如图片宽可以设置为：200px）的图文并排的样式。</span>\n</section>\n\n<!-- 这是文字在左，图片在右的示例 -->\n<section>\n    <span>这是文字在左，图片在右，设置图片宽度为 200px 的图文并排的样式！</span>\n    <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png\" style=\"width:200px\"></img>\n</section>\n```\n**效果预览**：\n\n---\n\n<section>\n   <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\" style=\"width:400px\"></img>\n   <span>这是文字在右，图片在左，且设置图片宽度（如图片宽可以设置为：400px）的图文并排的样式。</span>\n</section>\n\n<section>\n    <span>这是文字在左，图片在右，且设置图片宽度为 200px 的图文并排的样式！</span>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\" style=\"width:200px\"></img>\n</section>\n\n\n\n\n---\n\n> [!Important]\n>\n> **注意：**\n>\n> 由于图片排列的容器 `<section>` 采用的是grid布局，会根据 `<section>` 中有几列和每列里的内容自动分配每一列的宽度。\n>\n> 在进行图片、图片和文字排列时，如果将某一列的宽度设置为 xx%的形式，则该列的实际宽度并<u>不一定是内容区宽度的 xx%</u>，而是 `<section>` 容器中当前列宽度的 xx%，且当前列的宽度还受到了里面内容的影响。\n>\n> **基于以上原因，建议在单独设置某一列宽度的时候，尽可能采用具体的值（如: style=\"width: 200px\"），不要采用 xx%（如: style=\"width: 50%\"）的形式。**\n>\n> 示例：\n>\n> ```html\n> <!-- <section> 排列图片的容器，宽度为内容区（也就是书写区）的宽度 -->\n> <section>\n>    \t<!-- 此时是2列 -->\n>    \t<img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png\"></img>\n>  \t<!-- 此处的 width:50% ，实际只有内容区宽度的25%（一共2列，每一列宽度50%，50%*50% => 25%）-->\n>      <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png\" style=\"width:50%\"></img> \n> </section>\n> \n> <section>\n>    \t<!-- 此时是3列： img, span, span -->\n>    \t<img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png\"></img>  <!-- 第1列 -->\n> \t<span>....</span>  <!-- 第2列 -->\n> \t<span>             <!-- 第3列 -->\n>    \t<span>这是其段落他文字...</span>\n>             <!-- 此处的 width:50% ，实际只有内容区宽度的16.5%（一共3列，每一列宽度33.33%，33.33%*50% => 16.65%）-->\n>             <span style=\"width:50%\">这是多段文字</span>\n>             <span>这是其段落他文字...</span>\n> \t</span>\n> </section>\n> ```\n\n除了以上展示的排列方式，更多的排列形式，还请自行探索 ......\n\n## 图表Mermaid\n\n以下是 **Mermaid图表** 部分示例，更多图表类型请参考：[Mermaid图表](https://mermaid.js.org)\n\n```mermaid\nflowchart LR\n    A[Hard edge] -->|Link text| B(Round edge)\n    B --> C{Decision}\n    C -->|One| D[Result one]\n    C -->|Two| E[Result two]\n```\n```mermaid\nstateDiagram-v2\n    [*] --> Active\n\n    state Active {\n        [*] --> NumLockOff\n        NumLockOff --> NumLockOn : EvNumLockPressed\n        NumLockOn --> NumLockOff : EvNumLockPressed\n        --\n        [*] --> CapsLockOff\n        CapsLockOff --> CapsLockOn : EvCapsLockPressed\n        CapsLockOn --> CapsLockOff : EvCapsLockPressed\n        --\n        [*] --> ScrollLockOff\n        ScrollLockOff --> ScrollLockOn : EvScrollLockPressed\n        ScrollLockOn --> ScrollLockOff : EvScrollLockPressed\n    }\n```\n\n```mermaid\ngantt\n    dateFormat  YYYY-MM-DD\n    title       Adding GANTT diagram functionality to mermaid\n    excludes    weekends\n    %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week (\"sunday\") or \"weekends\", but not the word \"weekdays\".)\n\n    section A section\n    Completed task            :done,    des1, 2014-01-06,2014-01-08\n    Active task               :active,  des2, 2014-01-09, 3d\n    Future task               :         des3, after des2, 5d\n    Future task2              :         des4, after des3, 5d\n\n    section Critical tasks\n    Completed task in the critical line :crit, done, 2014-01-06,24h\n    Implement parser and jison          :crit, done, after des1, 2d\n    Create tests for parser             :crit, active, 3d\n    Future task in critical line        :crit, 5d\n    Create tests for renderer           :2d\n    Add to mermaid                      :until isadded\n    Functionality added                 :milestone, isadded, 2014-01-25, 0d\n\n    section Documentation\n    Describe gantt syntax               :active, a1, after des1, 3d\n    Add gantt diagram to demo page      :after a1  , 20h\n    Add another diagram to demo page    :doc1, after a1  , 48h\n\n    section Last section\n    Describe gantt syntax               :after doc1, 3d\n    Add gantt diagram to demo page      :20h\n    Add another diagram to demo page    :48h\n```\n\n### Flowchart\n\n### Sequence Diagram\n\n### State Diagram\n\n\n# 一级标题1\n\n## 二级标题2\n\n### 三级标题3\n\n#### 四级标题4\n##### 五级标题5\n\n###### 六级标题6\n\n# TOC目录\n\n以下是 [TOC] 目录样式\n\n[TOC]\t\n\n","source":"_posts/主题样例/Mdmdt主题演示demo.md","raw":"---\ntitle: Markdown语法测试文章\ndate: 2025-07-06\ndescription: Markdown渲染效果测试\ncategories: 测试\ntags: [测试]\n---\n\n## 关于Mdmdt主题\n**Mdmdt **是 markdown minimalism document theme 的缩写，意为: **Markdown极简文档主题**。\n**Mdmdt**[^1]是深度定制的个性化Typora主题，其目的是打造一个**清爽极简**的文档样式。\n\n> [!NOte]\n>\n> **注意：**mdmdt.css 文件中包含了亮色和暗色两者主题，会跟随系统模式自动切换亮暗主题。 `This is a single line code style`\n>\n> **Attention:** The MDMDT.CSS file contains both light and dark themes, which will automatically switch between light and dark themes according to the system mode.\n\n## 文本\n这是一段正文内容样式，以下是不同文本样式效果：**这是加粗文本样式**, <u>这是下划线样式</u>, *这是斜体字样式*,  [这是超链接样式: https://github.com/cayxc/mdmdt](https://github.com/cayxc/mdmdt),  `This is a single line code style`,  ~~这是删除线效果样式~~,  ==这是文字高亮效果==，上下标样式: $\\LaTeX$, X^2^, H~2~O, <span style='background:var(--color-2-0-c)'> 这是鼠标选中效果 </span>,  键盘键样式：<kbd>Command+Q</kbd> 🐳 😀 🇨🇳\n\nThis is a text content style and the following are the effects of different text styles: **This is a bold text style**,  [This is a hyperlink style: https://github.com/cayxc/mdmdt](https://github.com/cayxc/mdmdt), *This is the italic font style*, ~~This is the strikethrough effect style~~, <u>This is the underline style</u>, `This is a single line code style`,  keyboard key style: <kbd>Command+Q</kbd>,  $\\text{LaTeX}$ X^2^H~2~O, ==This is the text highlighting effect==, <span style='background:var(--color-2-0-c)'>This is the mouse selection effect</span>  🐳 😀 🇨🇳\n\n<!-- 这是注释内容......, This is the annotation content -->\n\n## 数学公式\n\n直接使用公式：\n\n$$\n\\begin{aligned} I &=\\int_0^{ct}\\frac{r}{\\sqrt{c^2t^2 -r^2}}\\int_0^{2\\pi} m^2(m+n) d\\theta dr\\&=\\int_0^{ct}\\frac{r}{\\sqrt{c^2t^2 -r^2}}\\end{aligned}\n$$\n\n$$代入公式得到：$$  $$u(t,x,y) = (3x+y) c^2 t^2 + x^2(x+y)$$\n\n$$\nu(t,x,y) = \\frac{1}{2\\pi c} \\frac{\\partial}{\\partial t} \\iint\\limits_{r<ct} \\frac{m^2(m+n)}{\\sqrt{c^2t^2 -r^2 }}dmdn\n$$\n\n## 列表\n\n这些是列表样式效果:\n\n\n1. 这是有序列表 A\n2. 这是有序列表 B\n\n- This is Item 1.\n- This is Item 2.\n- [ ] Something is Not TODO.\n- [x] Something is DONE.\n\n---\n\n1. 这是有序列表 A\n2. 这是有序列表 B\n    1. 这是有序列表 A\n    2. 这是有序列表 B\n\n- This is Item 1.\n- This is Item 2.\n    - This is Item 1.\n    - This is Item 2.\n\n---\n\n这是嵌套列表样式：\n\n1. 这是有序列表 A\n2. 这是有序列表 B\n    - This is Item 1.\n    - This is Item 2.\n        - [x] Something is Not TODO.\n        - [ ] Something is DONE.\n\n- 这是有序列表 A\n- 这是有序列表 B\n    1. This is Item 1.\n    2. This is Item 2.\n        - [ ] Something is Not TODO.\n        - [x] Something is DONE.\n\n## 代码\n\n单行代码样式：`composer require --dev barryvdh/laravel-ide-helper`\n\n大段代码块样式：\n\n```javascript\n/**\n  * ----------------------------------------\n  * 设置递增的 level 编号\n  * ----------------------------------------\n  * @param tag obj 标签对象\n  */\nsetLevelNumber(tag){\n   try {\n     if ((typeof tag) != 'object') {\n       throw 'setLevelNumber() 调用时参数类型错误，必须是一个h标签的对象集合！';\n     }\n     let str = tag.id;\n     if (str.lastIndexOf('.') == -1) { //如果是一级目录形式 level-1000\n       let newValue = parseInt(str.slice(6)) + 1;\n       return 'level-' + newValue;\n     }\n   } catch (err) {\n     return err;\n   }\n}\n```\n\n## 表格样式\n\n| Left-Aligned            |                Center Aligned                | Right Aligned |\n| :---------------------- | :------------------------------------------: | ------------: |\n| This is the first line  | `this is code` some wordy text and some code |          $160 |\n| This is the second line |      some code: `this is code` centered      |      $1200.99 |\n| This is the third line  |             These are some texts             |        $125.5 |\n\n## 引用文本框\n\n> [!NOTE]\n>\n> This is a Note text box ...... `this is code style`\n> > \n> > This is a Note text box ......\n\n> [!TIP]\n>\n> - `this is code` This is a Tip text box ......\n>\n> - 代码段：\n> > ```bash\n> >   these are  codes...\n> >   ...\n> > ```\n>\n> - This is a Tip text box ......\n>\n> 1. This is itemA\n> 1. This is itemB\n> 1. This is itemC\n\n> [!IMPORTANT]\n>\n> This is a Important text box ......\n>\n\n> [!WARNING]\n>\n> This is a Warning text box ......\n\n> [!CAUTION]\n>\n> `this is  code` This is a Caution text box ......\n\n## 个性化图文布局\n### 单张图片\n\n![](https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt.png)\n\n### 多图并排\n\n图片的个性化排列使用方式是将图片放到一个容器中，该容器为 `<section>`  标签，如下所示:\n\n1. 直接输入`<section>` 然后回车，如下：\n\n2. ```html\n   <section>\n   </section>\n   ```\n   \n3. 在 `<section>` 标签中插入图片，如下：\n\n```html\n   <section>\n     <!-- 想要几张图并排，就在此处插入几个 <img> 标签: <img src=\"图片的相对路径/绝对路径\"></img> -->   \n     <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-code.png\"></img>\n     <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-source.png\" style=\"width: 200px\"></img> <!-- 单独设置图片的宽度为200px -->\n     <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\"></img>\n   </section>\n```\n\n**效果预览**：\n\n<section>\n <img src=\"https://raw.gitcode.com/Li2112183373/image/blobs/22baa3d7eb76500687b96fb3f175ae03d02cf49c/mdmdt-math.png\"></img>\n <img src=\"https://raw.gitcode.com/Li2112183373/image/blobs/22baa3d7eb76500687b96fb3f175ae03d02cf49c/mdmdt-list.png\"></img>\n</section>\n\n\n---\n\n<section>\n <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-code.png\"></img>\n <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-1.png\" style=\"width: 200px\"></img>\n <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png\"></img>\n</section>\n\n\n---\n\n\n\n### 多张图其他排列方式\n\n一张大图在左，多张小图在右的图片排列，如下：\n\n```html\n<!-- 一张大图在左，多张小图在右 -->\n<section> \n  <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-1.png\"></img> <!-- 这是第1列 -->\n  <span style=\"width: 240px\">  <!-- 这是第2列 -->\n     <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-2.png\"></img>\n \t <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-code.png\"></img>\n\t <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png\"></img>\n  </span>\n</section>\n```\n**效果预览**：\n\n<section>\n <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-light.png\"></img>\n <span style=\"width: 240px\">\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-ui-1.png\"></img>\n \t<img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-code.png\"></img>\n\t<img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-dark\"></img>\n </span>\n</section>\n\n\n---\n\n一张大图在右，多张小图在左的图片排列，如下：\n\n```html\n<!-- 一张大图在右，多张小图在左 -->\n<section> \n <span style=\"width: 240px\"> <!-- 这是第1列 -->\n    <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-2.png\"></img>\n \t<img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-code.png\"></img>\n\t<img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png\"></img>\n </span>\n <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-1.png\"></img> <!-- 这是第2列 -->\n</section>\n```\n**效果预览**：\n\n<section> \n <span style=\"width: 240px\">\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-ui-1.png\"></img>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-ui-2.png\"></img>\n\t<img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdtht-dark.png\"></img>\n </span>\n <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdtht-light.png\"></img>\n</section>\n\n\n\n### 图文并排\n\n图文的个性化排列使用方式是将图片和文字放到一个容器中，该容器为 `<section>`  标签，如下所示:\n\n1. 直接输入 `<section>` 然后回车，如下：\n\n2. ```html\n   <section>\n       \n   </section>\n   ```\n\n3. 在 `<section>` 标签中插入图片和文字，如下：\n\n4. ```html\n   <!-- 图片和单段文字排列示例 -->\n   <section>\n       <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png\"></img>  <!-- 这是第1列 -->\n   \t<span>这是文字在右，图片在左，图片和文字各占总宽度的50%的图文并排的样式。</span> <!-- 这是第2列 -->\n   </section>\n   \n   \n   <!-- 图片和单段文字排列示例 -->\n   <section>\n   \t<span>这是文字在左，图片在右，图片和文字各占总宽度的50%的图文并排的样式。</span> \n       <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png\"></img>  \n   </section>\n   \n   \n   <!-- 图片和多段文字排列示例 -->\n   <section>\n       <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png\"></img> <!-- 这是第1列 -->\n       <span style=\"width: 150px\">  <!-- 这是第2列，且单独设置该列的宽度为150px -->\n           <span>这是多段文字......</span> \n           <span>这是文字在右，图片在左，图片和文字各占总宽度的50%的图文并排的样式。</span>\n           <span>这是多段文字......</span> \n   \t</span>\n   </section>\n   \n   \n   <!-- 图片居中，文字在两边的排列示例 -->\n   <section>\n       <span>这是第1列，这是图片居中，文字在两边的样式</span> <!-- 这是第1列 -->\n       <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png\"></img>  <!-- 这是第2列, 单独设置图片的宽度为200px -->\n   \t<span>这是第3列，列的宽度比第1列小</span>          <!-- 这是第3列 -->\n   </section>\n   ```\n\n**效果预览**：\n\n<section>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\"></img> \n\t<span>这是单段文字，文字在右，图片在左，图片和文字各占总宽度的50%的图文并排的样式。</span> \n</section>\n\n\n---\n\n<section>\n\t<span>这是单段文字，文字在左，图片在右，图片和文字各占总宽度的50%的图文并排的样式。</span> <!-- 这是第1列 -->\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\"></img>  <!-- 这是第2列 -->\n</section>\n\n\n---\n\n<section>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\"></img>\n    <span>\n        <span>这是多段文字......</span>\n        <span>这是文字在右，图片在左，图片和文字各占总宽度的50%的图文并排的样式。</span>\n        <span>这是多段文字......</span>\n\t</span>\n</section>\n\n\n---\n\n<section>\n    <span>这是第1列内容<br>这是图片居中，两边是文字，且两边文字设置相同宽度的样式</span> <!-- 这是第1列 -->\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdtht-dark.png\"></img> <!-- 这是第2列 -->\n\t<span>这是第3列内容<br>这是图片居中，两边是文字，且两边文字设置相同宽度的样式</span> <!-- 这是第3列 -->\n</section>\n\n\n\n\n\n<section>\n    <span>这是中间是图片，两边是文字的图文样式<br>需要注意：该列文字内容较多，且未设置宽度。<strong>列的宽度比第3列大</strong></span>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdtht-dark.png\"></img>\n\t<span>这是第3列内容</span>\n</section>\n\n\n\n---\n\n图片和文字，图片设置宽度示例：\n\n```html\n<!-- 这是文字在右，图片在左的示例 -->\n<section>\n   <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png\" style=\"width:200px\"></img>\n   <span>这是文字在右，图片在左，且设置图片的宽度（如图片宽可以设置为：200px）的图文并排的样式。</span>\n</section>\n\n<!-- 这是文字在左，图片在右的示例 -->\n<section>\n    <span>这是文字在左，图片在右，设置图片宽度为 200px 的图文并排的样式！</span>\n    <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png\" style=\"width:200px\"></img>\n</section>\n```\n**效果预览**：\n\n---\n\n<section>\n   <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\" style=\"width:400px\"></img>\n   <span>这是文字在右，图片在左，且设置图片宽度（如图片宽可以设置为：400px）的图文并排的样式。</span>\n</section>\n\n<section>\n    <span>这是文字在左，图片在右，且设置图片宽度为 200px 的图文并排的样式！</span>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\" style=\"width:200px\"></img>\n</section>\n\n\n\n\n---\n\n> [!Important]\n>\n> **注意：**\n>\n> 由于图片排列的容器 `<section>` 采用的是grid布局，会根据 `<section>` 中有几列和每列里的内容自动分配每一列的宽度。\n>\n> 在进行图片、图片和文字排列时，如果将某一列的宽度设置为 xx%的形式，则该列的实际宽度并<u>不一定是内容区宽度的 xx%</u>，而是 `<section>` 容器中当前列宽度的 xx%，且当前列的宽度还受到了里面内容的影响。\n>\n> **基于以上原因，建议在单独设置某一列宽度的时候，尽可能采用具体的值（如: style=\"width: 200px\"），不要采用 xx%（如: style=\"width: 50%\"）的形式。**\n>\n> 示例：\n>\n> ```html\n> <!-- <section> 排列图片的容器，宽度为内容区（也就是书写区）的宽度 -->\n> <section>\n>    \t<!-- 此时是2列 -->\n>    \t<img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png\"></img>\n>  \t<!-- 此处的 width:50% ，实际只有内容区宽度的25%（一共2列，每一列宽度50%，50%*50% => 25%）-->\n>      <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png\" style=\"width:50%\"></img> \n> </section>\n> \n> <section>\n>    \t<!-- 此时是3列： img, span, span -->\n>    \t<img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png\"></img>  <!-- 第1列 -->\n> \t<span>....</span>  <!-- 第2列 -->\n> \t<span>             <!-- 第3列 -->\n>    \t<span>这是其段落他文字...</span>\n>             <!-- 此处的 width:50% ，实际只有内容区宽度的16.5%（一共3列，每一列宽度33.33%，33.33%*50% => 16.65%）-->\n>             <span style=\"width:50%\">这是多段文字</span>\n>             <span>这是其段落他文字...</span>\n> \t</span>\n> </section>\n> ```\n\n除了以上展示的排列方式，更多的排列形式，还请自行探索 ......\n\n## 图表Mermaid\n\n以下是 **Mermaid图表** 部分示例，更多图表类型请参考：[Mermaid图表](https://mermaid.js.org)\n\n```mermaid\nflowchart LR\n    A[Hard edge] -->|Link text| B(Round edge)\n    B --> C{Decision}\n    C -->|One| D[Result one]\n    C -->|Two| E[Result two]\n```\n```mermaid\nstateDiagram-v2\n    [*] --> Active\n\n    state Active {\n        [*] --> NumLockOff\n        NumLockOff --> NumLockOn : EvNumLockPressed\n        NumLockOn --> NumLockOff : EvNumLockPressed\n        --\n        [*] --> CapsLockOff\n        CapsLockOff --> CapsLockOn : EvCapsLockPressed\n        CapsLockOn --> CapsLockOff : EvCapsLockPressed\n        --\n        [*] --> ScrollLockOff\n        ScrollLockOff --> ScrollLockOn : EvScrollLockPressed\n        ScrollLockOn --> ScrollLockOff : EvScrollLockPressed\n    }\n```\n\n```mermaid\ngantt\n    dateFormat  YYYY-MM-DD\n    title       Adding GANTT diagram functionality to mermaid\n    excludes    weekends\n    %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week (\"sunday\") or \"weekends\", but not the word \"weekdays\".)\n\n    section A section\n    Completed task            :done,    des1, 2014-01-06,2014-01-08\n    Active task               :active,  des2, 2014-01-09, 3d\n    Future task               :         des3, after des2, 5d\n    Future task2              :         des4, after des3, 5d\n\n    section Critical tasks\n    Completed task in the critical line :crit, done, 2014-01-06,24h\n    Implement parser and jison          :crit, done, after des1, 2d\n    Create tests for parser             :crit, active, 3d\n    Future task in critical line        :crit, 5d\n    Create tests for renderer           :2d\n    Add to mermaid                      :until isadded\n    Functionality added                 :milestone, isadded, 2014-01-25, 0d\n\n    section Documentation\n    Describe gantt syntax               :active, a1, after des1, 3d\n    Add gantt diagram to demo page      :after a1  , 20h\n    Add another diagram to demo page    :doc1, after a1  , 48h\n\n    section Last section\n    Describe gantt syntax               :after doc1, 3d\n    Add gantt diagram to demo page      :20h\n    Add another diagram to demo page    :48h\n```\n\n### Flowchart\n\n### Sequence Diagram\n\n### State Diagram\n\n\n# 一级标题1\n\n## 二级标题2\n\n### 三级标题3\n\n#### 四级标题4\n##### 五级标题5\n\n###### 六级标题6\n\n# TOC目录\n\n以下是 [TOC] 目录样式\n\n[TOC]\t\n\n","slug":"主题样例/Mdmdt主题演示demo","published":1,"updated":"2025-09-14T02:36:11.009Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpn000e4e4pgjkfcsqt","content":"<h2 id=\"关于Mdmdt主题\">关于Mdmdt主题</h2>\n<p><strong>Mdmdt <strong>是 markdown minimalism document theme 的缩写，意为: <strong>Markdown极简文档主题</strong>。<br>\n<strong>Mdmdt</strong>[^1]是深度定制的个性化Typora主题，其目的是打造一个</strong>清爽极简</strong>的文档样式。</p>\n<blockquote>\n<p>[!NOte]</p>\n<p>**注意：**mdmdt.css 文件中包含了亮色和暗色两者主题，会跟随系统模式自动切换亮暗主题。 <code>This is a single line code style</code></p>\n<p><strong>Attention:</strong> The MDMDT.CSS file contains both light and dark themes, which will automatically switch between light and dark themes according to the system mode.</p>\n</blockquote>\n<h2 id=\"文本\">文本</h2>\n<p>这是一段正文内容样式，以下是不同文本样式效果：<strong>这是加粗文本样式</strong>, <u>这是下划线样式</u>, <em>这是斜体字样式</em>,  <a href=\"https://github.com/cayxc/mdmdt\">这是超链接样式: https://github.com/cayxc/mdmdt</a>,  <code>This is a single line code style</code>,  <s>这是删除线效果样式</s>,  <mark>这是文字高亮效果</mark>，上下标样式: $\\LaTeX$, X<sup>2</sup>, H<sub>2</sub>O, <span style='background:var(--color-2-0-c)'> 这是鼠标选中效果 </span>,  键盘键样式：<kbd>Command+Q</kbd> 🐳 😀 🇨🇳</p>\n<p>This is a text content style and the following are the effects of different text styles: <strong>This is a bold text style</strong>,  <a href=\"https://github.com/cayxc/mdmdt\">This is a hyperlink style: https://github.com/cayxc/mdmdt</a>, <em>This is the italic font style</em>, <s>This is the strikethrough effect style</s>, <u>This is the underline style</u>, <code>This is a single line code style</code>,  keyboard key style: <kbd>Command+Q</kbd>,  $\\text{LaTeX}$ X<sup>2</sup>H<sub>2</sub>O, <mark>This is the text highlighting effect</mark>, <span style='background:var(--color-2-0-c)'>This is the mouse selection effect</span>  🐳 😀 🇨🇳</p>\n<!-- 这是注释内容......, This is the annotation content -->\n<h2 id=\"数学公式\">数学公式</h2>\n<p>直接使用公式：</p>\n<p>$$<br>\n\\begin{aligned} I &amp;=\\int_0<sup>{ct}\\frac{r}{\\sqrt{c</sup>2t^2 -r<sup>2}}\\int_0</sup>{2\\pi} m^2(m+n) d\\theta dr&amp;=\\int_0<sup>{ct}\\frac{r}{\\sqrt{c</sup>2t^2 -r^2}}\\end{aligned}<br>\n$$</p>\n<p>$$代入公式得到：$$  $$u(t,x,y) = (3x+y) c^2 t^2 + x^2(x+y)$$</p>\n<p>$$<br>\nu(t,x,y) = \\frac{1}{2\\pi c} \\frac{\\partial}{\\partial t} \\iint\\limits_{r&lt;ct} \\frac{m<sup>2(m+n)}{\\sqrt{c</sup>2t^2 -r^2 }}dmdn<br>\n$$</p>\n<h2 id=\"列表\">列表</h2>\n<p>这些是列表样式效果:</p>\n<ol>\n<li>这是有序列表 A</li>\n<li>这是有序列表 B</li>\n</ol>\n<ul>\n<li>This is Item 1.</li>\n<li>This is Item 2.</li>\n<li>[ ] Something is Not TODO.</li>\n<li>[x] Something is DONE.</li>\n</ul>\n<hr>\n<ol>\n<li>这是有序列表 A</li>\n<li>这是有序列表 B\n<ol>\n<li>这是有序列表 A</li>\n<li>这是有序列表 B</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>This is Item 1.</li>\n<li>This is Item 2.\n<ul>\n<li>This is Item 1.</li>\n<li>This is Item 2.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>这是嵌套列表样式：</p>\n<ol>\n<li>这是有序列表 A</li>\n<li>这是有序列表 B\n<ul>\n<li>This is Item 1.</li>\n<li>This is Item 2.\n<ul>\n<li>[x] Something is Not TODO.</li>\n<li>[ ] Something is DONE.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>这是有序列表 A</li>\n<li>这是有序列表 B\n<ol>\n<li>This is Item 1.</li>\n<li>This is Item 2.\n<ul>\n<li>[ ] Something is Not TODO.</li>\n<li>[x] Something is DONE.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"代码\">代码</h2>\n<p>单行代码样式：<code>composer require --dev barryvdh/laravel-ide-helper</code></p>\n<p>大段代码块样式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * ----------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">  * 设置递增的 level 编号</span></span><br><span class=\"line\"><span class=\"comment\">  * ----------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> tag obj 标签对象</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"title function_\">setLevelNumber</span>(<span class=\"params\">tag</span>)&#123;</span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> ((<span class=\"keyword\">typeof</span> tag) != <span class=\"string\">&#x27;object&#x27;</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"string\">&#x27;setLevelNumber() 调用时参数类型错误，必须是一个h标签的对象集合！&#x27;</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">let</span> str = tag.<span class=\"property\">id</span>;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (str.<span class=\"title function_\">lastIndexOf</span>(<span class=\"string\">&#x27;.&#x27;</span>) == -<span class=\"number\">1</span>) &#123; <span class=\"comment\">//如果是一级目录形式 level-1000</span></span><br><span class=\"line\">       <span class=\"keyword\">let</span> newValue = <span class=\"built_in\">parseInt</span>(str.<span class=\"title function_\">slice</span>(<span class=\"number\">6</span>)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">&#x27;level-&#x27;</span> + newValue;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"表格样式\">表格样式</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Left-Aligned</th>\n<th style=\"text-align:center\">Center Aligned</th>\n<th style=\"text-align:right\">Right Aligned</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">This is the first line</td>\n<td style=\"text-align:center\"><code>this is code</code> some wordy text and some code</td>\n<td style=\"text-align:right\">$160</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">This is the second line</td>\n<td style=\"text-align:center\">some code: <code>this is code</code> centered</td>\n<td style=\"text-align:right\">$1200.99</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">This is the third line</td>\n<td style=\"text-align:center\">These are some texts</td>\n<td style=\"text-align:right\">$125.5</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"引用文本框\">引用文本框</h2>\n<blockquote>\n<p>[!NOTE]</p>\n<p>This is a Note text box … <code>this is code style</code></p>\n<blockquote>\n<p>This is a Note text box …</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>[!TIP]</p>\n<ul>\n<li>\n<p><code>this is code</code> This is a Tip text box …</p>\n</li>\n<li>\n<p>代码段：</p>\n</li>\n</ul>\n<blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">these are  codes...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li>This is a Tip text box …</li>\n</ul>\n<ol>\n<li>This is itemA</li>\n<li>This is itemB</li>\n<li>This is itemC</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>[!IMPORTANT]</p>\n<p>This is a Important text box …</p>\n</blockquote>\n<blockquote>\n<p>[!WARNING]</p>\n<p>This is a Warning text box …</p>\n</blockquote>\n<blockquote>\n<p>[!CAUTION]</p>\n<p><code>this is  code</code> This is a Caution text box …</p>\n</blockquote>\n<h2 id=\"个性化图文布局\">个性化图文布局</h2>\n<h3 id=\"单张图片\">单张图片</h3>\n<p><img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt.png\" alt=\"\"></p>\n<h3 id=\"多图并排\">多图并排</h3>\n<p>图片的个性化排列使用方式是将图片放到一个容器中，该容器为 <code>&lt;section&gt;</code>  标签，如下所示:</p>\n<ol>\n<li>\n<p>直接输入<code>&lt;section&gt;</code> 然后回车，如下：</p>\n</li>\n<li>\n<pre><code class=\"language-html\">&lt;section&gt;\n&lt;/section&gt;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   </span><br><span class=\"line\">3. 在 `&lt;section&gt;` 标签中插入图片，如下：</span><br><span class=\"line\"></span><br><span class=\"line\">```html</span><br><span class=\"line\">   &lt;section&gt;</span><br><span class=\"line\">     &lt;!-- 想要几张图并排，就在此处插入几个 &lt;img&gt; 标签: &lt;img src=&quot;图片的相对路径/绝对路径&quot;&gt;&lt;/img&gt; --&gt;   </span><br><span class=\"line\">     &lt;img src=&quot;https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-code.png&quot;&gt;&lt;/img&gt;</span><br><span class=\"line\">     &lt;img src=&quot;https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-source.png&quot; style=&quot;width: 200px&quot;&gt;&lt;/img&gt; &lt;!-- 单独设置图片的宽度为200px --&gt;</span><br><span class=\"line\">     &lt;img src=&quot;https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png&quot;&gt;&lt;/img&gt;</span><br><span class=\"line\">   &lt;/section&gt;</span><br></pre></td></tr></table></figure>\n\n</code></pre>\n</li>\n</ol>\n<p><strong>效果预览</strong>：</p>\n<section>\n <img src=\"https://raw.gitcode.com/Li2112183373/image/blobs/22baa3d7eb76500687b96fb3f175ae03d02cf49c/mdmdt-math.png\"></img>\n <img src=\"https://raw.gitcode.com/Li2112183373/image/blobs/22baa3d7eb76500687b96fb3f175ae03d02cf49c/mdmdt-list.png\"></img>\n</section>\n<hr>\n<section>\n <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-code.png\"></img>\n <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-1.png\" style=\"width: 200px\"></img>\n <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png\"></img>\n</section>\n<hr>\n<h3 id=\"多张图其他排列方式\">多张图其他排列方式</h3>\n<p>一张大图在左，多张小图在右的图片排列，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 一张大图在左，多张小图在右 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-1.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span> <span class=\"comment\">&lt;!-- 这是第1列 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;width: 240px&quot;</span>&gt;</span>  <span class=\"comment\">&lt;!-- 这是第2列 --&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-2.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\"> \t <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-code.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\">\t <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>效果预览</strong>：</p>\n<section>\n <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-light.png\"></img>\n <span style=\"width: 240px\">\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-ui-1.png\"></img>\n \t<img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-code.png\"></img>\n\t<img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-dark\"></img>\n </span>\n</section>\n<hr>\n<p>一张大图在右，多张小图在左的图片排列，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 一张大图在右，多张小图在左 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span> </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;width: 240px&quot;</span>&gt;</span> <span class=\"comment\">&lt;!-- 这是第1列 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-2.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\"> \t<span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-code.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-1.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span> <span class=\"comment\">&lt;!-- 这是第2列 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>效果预览</strong>：</p>\n<section> \n <span style=\"width: 240px\">\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-ui-1.png\"></img>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-ui-2.png\"></img>\n\t<img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdtht-dark.png\"></img>\n </span>\n <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdtht-light.png\"></img>\n</section>\n<h3 id=\"图文并排\">图文并排</h3>\n<p>图文的个性化排列使用方式是将图片和文字放到一个容器中，该容器为 <code>&lt;section&gt;</code>  标签，如下所示:</p>\n<ol>\n<li>\n<p>直接输入 <code>&lt;section&gt;</code> 然后回车，如下：</p>\n</li>\n<li>\n<pre><code class=\"language-html\">&lt;section&gt;\n    \n&lt;/section&gt;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. 在 `&lt;section&gt;` 标签中插入图片和文字，如下：</span><br><span class=\"line\"></span><br><span class=\"line\">4. ```html</span><br><span class=\"line\">   &lt;!-- 图片和单段文字排列示例 --&gt;</span><br><span class=\"line\">   &lt;section&gt;</span><br><span class=\"line\">       &lt;img src=&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png&quot;&gt;&lt;/img&gt;  &lt;!-- 这是第1列 --&gt;</span><br><span class=\"line\">   \t&lt;span&gt;这是文字在右，图片在左，图片和文字各占总宽度的50%的图文并排的样式。&lt;/span&gt; &lt;!-- 这是第2列 --&gt;</span><br><span class=\"line\">   &lt;/section&gt;</span><br><span class=\"line\">   </span><br><span class=\"line\">   </span><br><span class=\"line\">   &lt;!-- 图片和单段文字排列示例 --&gt;</span><br><span class=\"line\">   &lt;section&gt;</span><br><span class=\"line\">   \t&lt;span&gt;这是文字在左，图片在右，图片和文字各占总宽度的50%的图文并排的样式。&lt;/span&gt; </span><br><span class=\"line\">       &lt;img src=&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png&quot;&gt;&lt;/img&gt;  </span><br><span class=\"line\">   &lt;/section&gt;</span><br><span class=\"line\">   </span><br><span class=\"line\">   </span><br><span class=\"line\">   &lt;!-- 图片和多段文字排列示例 --&gt;</span><br><span class=\"line\">   &lt;section&gt;</span><br><span class=\"line\">       &lt;img src=&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png&quot;&gt;&lt;/img&gt; &lt;!-- 这是第1列 --&gt;</span><br><span class=\"line\">       &lt;span style=&quot;width: 150px&quot;&gt;  &lt;!-- 这是第2列，且单独设置该列的宽度为150px --&gt;</span><br><span class=\"line\">           &lt;span&gt;这是多段文字......&lt;/span&gt; </span><br><span class=\"line\">           &lt;span&gt;这是文字在右，图片在左，图片和文字各占总宽度的50%的图文并排的样式。&lt;/span&gt;</span><br><span class=\"line\">           &lt;span&gt;这是多段文字......&lt;/span&gt; </span><br><span class=\"line\">   \t&lt;/span&gt;</span><br><span class=\"line\">   &lt;/section&gt;</span><br><span class=\"line\">   </span><br><span class=\"line\">   </span><br><span class=\"line\">   &lt;!-- 图片居中，文字在两边的排列示例 --&gt;</span><br><span class=\"line\">   &lt;section&gt;</span><br><span class=\"line\">       &lt;span&gt;这是第1列，这是图片居中，文字在两边的样式&lt;/span&gt; &lt;!-- 这是第1列 --&gt;</span><br><span class=\"line\">       &lt;img src=&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png&quot;&gt;&lt;/img&gt;  &lt;!-- 这是第2列, 单独设置图片的宽度为200px --&gt;</span><br><span class=\"line\">   \t&lt;span&gt;这是第3列，列的宽度比第1列小&lt;/span&gt;          &lt;!-- 这是第3列 --&gt;</span><br><span class=\"line\">   &lt;/section&gt;</span><br></pre></td></tr></table></figure>\n\n</code></pre>\n</li>\n</ol>\n<p><strong>效果预览</strong>：</p>\n<section>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\"></img> \n\t<span>这是单段文字，文字在右，图片在左，图片和文字各占总宽度的50%的图文并排的样式。</span> \n</section>\n<hr>\n<section>\n\t<span>这是单段文字，文字在左，图片在右，图片和文字各占总宽度的50%的图文并排的样式。</span> <!-- 这是第1列 -->\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\"></img>  <!-- 这是第2列 -->\n</section>\n<hr>\n<section>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\"></img>\n    <span>\n        <span>这是多段文字......</span>\n        <span>这是文字在右，图片在左，图片和文字各占总宽度的50%的图文并排的样式。</span>\n        <span>这是多段文字......</span>\n\t</span>\n</section>\n<hr>\n<section>\n    <span>这是第1列内容<br>这是图片居中，两边是文字，且两边文字设置相同宽度的样式</span> <!-- 这是第1列 -->\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdtht-dark.png\"></img> <!-- 这是第2列 -->\n\t<span>这是第3列内容<br>这是图片居中，两边是文字，且两边文字设置相同宽度的样式</span> <!-- 这是第3列 -->\n</section>\n<section>\n    <span>这是中间是图片，两边是文字的图文样式<br>需要注意：该列文字内容较多，且未设置宽度。<strong>列的宽度比第3列大</strong></span>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdtht-dark.png\"></img>\n\t<span>这是第3列内容</span>\n</section>\n<hr>\n<p>图片和文字，图片设置宽度示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 这是文字在右，图片在左的示例 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;width:200px&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>这是文字在右，图片在左，且设置图片的宽度（如图片宽可以设置为：200px）的图文并排的样式。<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 这是文字在左，图片在右的示例 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>这是文字在左，图片在右，设置图片宽度为 200px 的图文并排的样式！<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;width:200px&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>效果预览</strong>：</p>\n<hr>\n<section>\n   <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\" style=\"width:400px\"></img>\n   <span>这是文字在右，图片在左，且设置图片宽度（如图片宽可以设置为：400px）的图文并排的样式。</span>\n</section>\n<section>\n    <span>这是文字在左，图片在右，且设置图片宽度为 200px 的图文并排的样式！</span>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\" style=\"width:200px\"></img>\n</section>\n<hr>\n<blockquote>\n<p>[!Important]</p>\n<p><strong>注意：</strong></p>\n<p>由于图片排列的容器 <code>&lt;section&gt;</code> 采用的是grid布局，会根据 <code>&lt;section&gt;</code> 中有几列和每列里的内容自动分配每一列的宽度。</p>\n<p>在进行图片、图片和文字排列时，如果将某一列的宽度设置为 xx%的形式，则该列的实际宽度并<u>不一定是内容区宽度的 xx%</u>，而是 <code>&lt;section&gt;</code> 容器中当前列宽度的 xx%，且当前列的宽度还受到了里面内容的影响。</p>\n<p><strong>基于以上原因，建议在单独设置某一列宽度的时候，尽可能采用具体的值（如: style=“width: 200px”），不要采用 xx%（如: style=“width: 50%”）的形式。</strong></p>\n<p>示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;section&gt; 排列图片的容器，宽度为内容区（也就是书写区）的宽度 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"comment\">&lt;!-- 此时是2列 --&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\"> \t<span class=\"comment\">&lt;!-- 此处的 width:50% ，实际只有内容区宽度的25%（一共2列，每一列宽度50%，50%*50% =&gt; 25%）--&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;width:50%&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"comment\">&lt;!-- 此时是3列： img, span, span --&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span>  <span class=\"comment\">&lt;!-- 第1列 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>....<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>  <span class=\"comment\">&lt;!-- 第2列 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>             <span class=\"comment\">&lt;!-- 第3列 --&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>这是其段落他文字...<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 此处的 width:50% ，实际只有内容区宽度的16.5%（一共3列，每一列宽度33.33%，33.33%*50% =&gt; 16.65%）--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;width:50%&quot;</span>&gt;</span>这是多段文字<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>这是其段落他文字...<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>除了以上展示的排列方式，更多的排列形式，还请自行探索 …</p>\n<h2 id=\"图表Mermaid\">图表Mermaid</h2>\n<p>以下是 <strong>Mermaid图表</strong> 部分示例，更多图表类型请参考：<a href=\"https://mermaid.js.org\">Mermaid图表</a></p>\n<pre><code class=\"highlight mermaid\">flowchart LR\n    A[Hard edge] --&gt;|Link text| B(Round edge)\n    B --&gt; C&#123;Decision&#125;\n    C --&gt;|One| D[Result one]\n    C --&gt;|Two| E[Result two]</code></pre>\n<pre><code class=\"highlight mermaid\">stateDiagram-v2\n    [*] --&gt; Active\n\n    state Active &#123;\n        [*] --&gt; NumLockOff\n        NumLockOff --&gt; NumLockOn : EvNumLockPressed\n        NumLockOn --&gt; NumLockOff : EvNumLockPressed\n        --\n        [*] --&gt; CapsLockOff\n        CapsLockOff --&gt; CapsLockOn : EvCapsLockPressed\n        CapsLockOn --&gt; CapsLockOff : EvCapsLockPressed\n        --\n        [*] --&gt; ScrollLockOff\n        ScrollLockOff --&gt; ScrollLockOn : EvScrollLockPressed\n        ScrollLockOn --&gt; ScrollLockOff : EvScrollLockPressed\n    &#125;</code></pre>\n<pre><code class=\"highlight mermaid\">gantt\n    dateFormat  YYYY-MM-DD\n    title       Adding GANTT diagram functionality to mermaid\n    excludes    weekends\n    %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week (&quot;sunday&quot;) or &quot;weekends&quot;, but not the word &quot;weekdays&quot;.)\n\n    section A section\n    Completed task            :done,    des1, 2014-01-06,2014-01-08\n    Active task               :active,  des2, 2014-01-09, 3d\n    Future task               :         des3, after des2, 5d\n    Future task2              :         des4, after des3, 5d\n\n    section Critical tasks\n    Completed task in the critical line :crit, done, 2014-01-06,24h\n    Implement parser and jison          :crit, done, after des1, 2d\n    Create tests for parser             :crit, active, 3d\n    Future task in critical line        :crit, 5d\n    Create tests for renderer           :2d\n    Add to mermaid                      :until isadded\n    Functionality added                 :milestone, isadded, 2014-01-25, 0d\n\n    section Documentation\n    Describe gantt syntax               :active, a1, after des1, 3d\n    Add gantt diagram to demo page      :after a1  , 20h\n    Add another diagram to demo page    :doc1, after a1  , 48h\n\n    section Last section\n    Describe gantt syntax               :after doc1, 3d\n    Add gantt diagram to demo page      :20h\n    Add another diagram to demo page    :48h</code></pre>\n<h3 id=\"Flowchart\">Flowchart</h3>\n<h3 id=\"Sequence-Diagram\">Sequence Diagram</h3>\n<h3 id=\"State-Diagram\">State Diagram</h3>\n<h1>一级标题1</h1>\n<h2 id=\"二级标题2\">二级标题2</h2>\n<h3 id=\"三级标题3\">三级标题3</h3>\n<h4 id=\"四级标题4\">四级标题4</h4>\n<h5 id=\"五级标题5\">五级标题5</h5>\n<h6 id=\"六级标题6\">六级标题6</h6>\n<h1>TOC目录</h1>\n<p>以下是 [TOC] 目录样式</p>\n<p>[TOC]</p>\n","excerpt":"","more":"<h2 id=\"关于Mdmdt主题\">关于Mdmdt主题</h2>\n<p><strong>Mdmdt <strong>是 markdown minimalism document theme 的缩写，意为: <strong>Markdown极简文档主题</strong>。<br>\n<strong>Mdmdt</strong>[^1]是深度定制的个性化Typora主题，其目的是打造一个</strong>清爽极简</strong>的文档样式。</p>\n<blockquote>\n<p>[!NOte]</p>\n<p>**注意：**mdmdt.css 文件中包含了亮色和暗色两者主题，会跟随系统模式自动切换亮暗主题。 <code>This is a single line code style</code></p>\n<p><strong>Attention:</strong> The MDMDT.CSS file contains both light and dark themes, which will automatically switch between light and dark themes according to the system mode.</p>\n</blockquote>\n<h2 id=\"文本\">文本</h2>\n<p>这是一段正文内容样式，以下是不同文本样式效果：<strong>这是加粗文本样式</strong>, <u>这是下划线样式</u>, <em>这是斜体字样式</em>,  <a href=\"https://github.com/cayxc/mdmdt\">这是超链接样式: https://github.com/cayxc/mdmdt</a>,  <code>This is a single line code style</code>,  <s>这是删除线效果样式</s>,  <mark>这是文字高亮效果</mark>，上下标样式: $\\LaTeX$, X<sup>2</sup>, H<sub>2</sub>O, <span style='background:var(--color-2-0-c)'> 这是鼠标选中效果 </span>,  键盘键样式：<kbd>Command+Q</kbd> 🐳 😀 🇨🇳</p>\n<p>This is a text content style and the following are the effects of different text styles: <strong>This is a bold text style</strong>,  <a href=\"https://github.com/cayxc/mdmdt\">This is a hyperlink style: https://github.com/cayxc/mdmdt</a>, <em>This is the italic font style</em>, <s>This is the strikethrough effect style</s>, <u>This is the underline style</u>, <code>This is a single line code style</code>,  keyboard key style: <kbd>Command+Q</kbd>,  $\\text{LaTeX}$ X<sup>2</sup>H<sub>2</sub>O, <mark>This is the text highlighting effect</mark>, <span style='background:var(--color-2-0-c)'>This is the mouse selection effect</span>  🐳 😀 🇨🇳</p>\n<!-- 这是注释内容......, This is the annotation content -->\n<h2 id=\"数学公式\">数学公式</h2>\n<p>直接使用公式：</p>\n<p>$$<br>\n\\begin{aligned} I &amp;=\\int_0<sup>{ct}\\frac{r}{\\sqrt{c</sup>2t^2 -r<sup>2}}\\int_0</sup>{2\\pi} m^2(m+n) d\\theta dr&amp;=\\int_0<sup>{ct}\\frac{r}{\\sqrt{c</sup>2t^2 -r^2}}\\end{aligned}<br>\n$$</p>\n<p>$$代入公式得到：$$  $$u(t,x,y) = (3x+y) c^2 t^2 + x^2(x+y)$$</p>\n<p>$$<br>\nu(t,x,y) = \\frac{1}{2\\pi c} \\frac{\\partial}{\\partial t} \\iint\\limits_{r&lt;ct} \\frac{m<sup>2(m+n)}{\\sqrt{c</sup>2t^2 -r^2 }}dmdn<br>\n$$</p>\n<h2 id=\"列表\">列表</h2>\n<p>这些是列表样式效果:</p>\n<ol>\n<li>这是有序列表 A</li>\n<li>这是有序列表 B</li>\n</ol>\n<ul>\n<li>This is Item 1.</li>\n<li>This is Item 2.</li>\n<li>[ ] Something is Not TODO.</li>\n<li>[x] Something is DONE.</li>\n</ul>\n<hr>\n<ol>\n<li>这是有序列表 A</li>\n<li>这是有序列表 B\n<ol>\n<li>这是有序列表 A</li>\n<li>这是有序列表 B</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>This is Item 1.</li>\n<li>This is Item 2.\n<ul>\n<li>This is Item 1.</li>\n<li>This is Item 2.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>这是嵌套列表样式：</p>\n<ol>\n<li>这是有序列表 A</li>\n<li>这是有序列表 B\n<ul>\n<li>This is Item 1.</li>\n<li>This is Item 2.\n<ul>\n<li>[x] Something is Not TODO.</li>\n<li>[ ] Something is DONE.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>这是有序列表 A</li>\n<li>这是有序列表 B\n<ol>\n<li>This is Item 1.</li>\n<li>This is Item 2.\n<ul>\n<li>[ ] Something is Not TODO.</li>\n<li>[x] Something is DONE.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"代码\">代码</h2>\n<p>单行代码样式：<code>composer require --dev barryvdh/laravel-ide-helper</code></p>\n<p>大段代码块样式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * ----------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">  * 设置递增的 level 编号</span></span><br><span class=\"line\"><span class=\"comment\">  * ----------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> tag obj 标签对象</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"title function_\">setLevelNumber</span>(<span class=\"params\">tag</span>)&#123;</span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> ((<span class=\"keyword\">typeof</span> tag) != <span class=\"string\">&#x27;object&#x27;</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"string\">&#x27;setLevelNumber() 调用时参数类型错误，必须是一个h标签的对象集合！&#x27;</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">let</span> str = tag.<span class=\"property\">id</span>;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (str.<span class=\"title function_\">lastIndexOf</span>(<span class=\"string\">&#x27;.&#x27;</span>) == -<span class=\"number\">1</span>) &#123; <span class=\"comment\">//如果是一级目录形式 level-1000</span></span><br><span class=\"line\">       <span class=\"keyword\">let</span> newValue = <span class=\"built_in\">parseInt</span>(str.<span class=\"title function_\">slice</span>(<span class=\"number\">6</span>)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">&#x27;level-&#x27;</span> + newValue;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"表格样式\">表格样式</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Left-Aligned</th>\n<th style=\"text-align:center\">Center Aligned</th>\n<th style=\"text-align:right\">Right Aligned</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">This is the first line</td>\n<td style=\"text-align:center\"><code>this is code</code> some wordy text and some code</td>\n<td style=\"text-align:right\">$160</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">This is the second line</td>\n<td style=\"text-align:center\">some code: <code>this is code</code> centered</td>\n<td style=\"text-align:right\">$1200.99</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">This is the third line</td>\n<td style=\"text-align:center\">These are some texts</td>\n<td style=\"text-align:right\">$125.5</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"引用文本框\">引用文本框</h2>\n<blockquote>\n<p>[!NOTE]</p>\n<p>This is a Note text box … <code>this is code style</code></p>\n<blockquote>\n<p>This is a Note text box …</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>[!TIP]</p>\n<ul>\n<li>\n<p><code>this is code</code> This is a Tip text box …</p>\n</li>\n<li>\n<p>代码段：</p>\n</li>\n</ul>\n<blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">these are  codes...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li>This is a Tip text box …</li>\n</ul>\n<ol>\n<li>This is itemA</li>\n<li>This is itemB</li>\n<li>This is itemC</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>[!IMPORTANT]</p>\n<p>This is a Important text box …</p>\n</blockquote>\n<blockquote>\n<p>[!WARNING]</p>\n<p>This is a Warning text box …</p>\n</blockquote>\n<blockquote>\n<p>[!CAUTION]</p>\n<p><code>this is  code</code> This is a Caution text box …</p>\n</blockquote>\n<h2 id=\"个性化图文布局\">个性化图文布局</h2>\n<h3 id=\"单张图片\">单张图片</h3>\n<p><img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt.png\" alt=\"\"></p>\n<h3 id=\"多图并排\">多图并排</h3>\n<p>图片的个性化排列使用方式是将图片放到一个容器中，该容器为 <code>&lt;section&gt;</code>  标签，如下所示:</p>\n<ol>\n<li>\n<p>直接输入<code>&lt;section&gt;</code> 然后回车，如下：</p>\n</li>\n<li>\n<pre><code class=\"language-html\">&lt;section&gt;\n&lt;/section&gt;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   </span><br><span class=\"line\">3. 在 `&lt;section&gt;` 标签中插入图片，如下：</span><br><span class=\"line\"></span><br><span class=\"line\">```html</span><br><span class=\"line\">   &lt;section&gt;</span><br><span class=\"line\">     &lt;!-- 想要几张图并排，就在此处插入几个 &lt;img&gt; 标签: &lt;img src=&quot;图片的相对路径/绝对路径&quot;&gt;&lt;/img&gt; --&gt;   </span><br><span class=\"line\">     &lt;img src=&quot;https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-code.png&quot;&gt;&lt;/img&gt;</span><br><span class=\"line\">     &lt;img src=&quot;https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-source.png&quot; style=&quot;width: 200px&quot;&gt;&lt;/img&gt; &lt;!-- 单独设置图片的宽度为200px --&gt;</span><br><span class=\"line\">     &lt;img src=&quot;https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png&quot;&gt;&lt;/img&gt;</span><br><span class=\"line\">   &lt;/section&gt;</span><br></pre></td></tr></table></figure>\n\n</code></pre>\n</li>\n</ol>\n<p><strong>效果预览</strong>：</p>\n<section>\n <img src=\"https://raw.gitcode.com/Li2112183373/image/blobs/22baa3d7eb76500687b96fb3f175ae03d02cf49c/mdmdt-math.png\"></img>\n <img src=\"https://raw.gitcode.com/Li2112183373/image/blobs/22baa3d7eb76500687b96fb3f175ae03d02cf49c/mdmdt-list.png\"></img>\n</section>\n<hr>\n<section>\n <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-code.png\"></img>\n <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-1.png\" style=\"width: 200px\"></img>\n <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png\"></img>\n</section>\n<hr>\n<h3 id=\"多张图其他排列方式\">多张图其他排列方式</h3>\n<p>一张大图在左，多张小图在右的图片排列，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 一张大图在左，多张小图在右 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-1.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span> <span class=\"comment\">&lt;!-- 这是第1列 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;width: 240px&quot;</span>&gt;</span>  <span class=\"comment\">&lt;!-- 这是第2列 --&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-2.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\"> \t <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-code.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\">\t <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>效果预览</strong>：</p>\n<section>\n <img src=\"https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-light.png\"></img>\n <span style=\"width: 240px\">\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-ui-1.png\"></img>\n \t<img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-code.png\"></img>\n\t<img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-dark\"></img>\n </span>\n</section>\n<hr>\n<p>一张大图在右，多张小图在左的图片排列，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 一张大图在右，多张小图在左 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span> </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;width: 240px&quot;</span>&gt;</span> <span class=\"comment\">&lt;!-- 这是第1列 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-2.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\"> \t<span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-code.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-ui-1.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span> <span class=\"comment\">&lt;!-- 这是第2列 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>效果预览</strong>：</p>\n<section> \n <span style=\"width: 240px\">\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-ui-1.png\"></img>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-ui-2.png\"></img>\n\t<img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdtht-dark.png\"></img>\n </span>\n <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdtht-light.png\"></img>\n</section>\n<h3 id=\"图文并排\">图文并排</h3>\n<p>图文的个性化排列使用方式是将图片和文字放到一个容器中，该容器为 <code>&lt;section&gt;</code>  标签，如下所示:</p>\n<ol>\n<li>\n<p>直接输入 <code>&lt;section&gt;</code> 然后回车，如下：</p>\n</li>\n<li>\n<pre><code class=\"language-html\">&lt;section&gt;\n    \n&lt;/section&gt;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. 在 `&lt;section&gt;` 标签中插入图片和文字，如下：</span><br><span class=\"line\"></span><br><span class=\"line\">4. ```html</span><br><span class=\"line\">   &lt;!-- 图片和单段文字排列示例 --&gt;</span><br><span class=\"line\">   &lt;section&gt;</span><br><span class=\"line\">       &lt;img src=&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png&quot;&gt;&lt;/img&gt;  &lt;!-- 这是第1列 --&gt;</span><br><span class=\"line\">   \t&lt;span&gt;这是文字在右，图片在左，图片和文字各占总宽度的50%的图文并排的样式。&lt;/span&gt; &lt;!-- 这是第2列 --&gt;</span><br><span class=\"line\">   &lt;/section&gt;</span><br><span class=\"line\">   </span><br><span class=\"line\">   </span><br><span class=\"line\">   &lt;!-- 图片和单段文字排列示例 --&gt;</span><br><span class=\"line\">   &lt;section&gt;</span><br><span class=\"line\">   \t&lt;span&gt;这是文字在左，图片在右，图片和文字各占总宽度的50%的图文并排的样式。&lt;/span&gt; </span><br><span class=\"line\">       &lt;img src=&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png&quot;&gt;&lt;/img&gt;  </span><br><span class=\"line\">   &lt;/section&gt;</span><br><span class=\"line\">   </span><br><span class=\"line\">   </span><br><span class=\"line\">   &lt;!-- 图片和多段文字排列示例 --&gt;</span><br><span class=\"line\">   &lt;section&gt;</span><br><span class=\"line\">       &lt;img src=&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png&quot;&gt;&lt;/img&gt; &lt;!-- 这是第1列 --&gt;</span><br><span class=\"line\">       &lt;span style=&quot;width: 150px&quot;&gt;  &lt;!-- 这是第2列，且单独设置该列的宽度为150px --&gt;</span><br><span class=\"line\">           &lt;span&gt;这是多段文字......&lt;/span&gt; </span><br><span class=\"line\">           &lt;span&gt;这是文字在右，图片在左，图片和文字各占总宽度的50%的图文并排的样式。&lt;/span&gt;</span><br><span class=\"line\">           &lt;span&gt;这是多段文字......&lt;/span&gt; </span><br><span class=\"line\">   \t&lt;/span&gt;</span><br><span class=\"line\">   &lt;/section&gt;</span><br><span class=\"line\">   </span><br><span class=\"line\">   </span><br><span class=\"line\">   &lt;!-- 图片居中，文字在两边的排列示例 --&gt;</span><br><span class=\"line\">   &lt;section&gt;</span><br><span class=\"line\">       &lt;span&gt;这是第1列，这是图片居中，文字在两边的样式&lt;/span&gt; &lt;!-- 这是第1列 --&gt;</span><br><span class=\"line\">       &lt;img src=&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png&quot;&gt;&lt;/img&gt;  &lt;!-- 这是第2列, 单独设置图片的宽度为200px --&gt;</span><br><span class=\"line\">   \t&lt;span&gt;这是第3列，列的宽度比第1列小&lt;/span&gt;          &lt;!-- 这是第3列 --&gt;</span><br><span class=\"line\">   &lt;/section&gt;</span><br></pre></td></tr></table></figure>\n\n</code></pre>\n</li>\n</ol>\n<p><strong>效果预览</strong>：</p>\n<section>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\"></img> \n\t<span>这是单段文字，文字在右，图片在左，图片和文字各占总宽度的50%的图文并排的样式。</span> \n</section>\n<hr>\n<section>\n\t<span>这是单段文字，文字在左，图片在右，图片和文字各占总宽度的50%的图文并排的样式。</span> <!-- 这是第1列 -->\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\"></img>  <!-- 这是第2列 -->\n</section>\n<hr>\n<section>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\"></img>\n    <span>\n        <span>这是多段文字......</span>\n        <span>这是文字在右，图片在左，图片和文字各占总宽度的50%的图文并排的样式。</span>\n        <span>这是多段文字......</span>\n\t</span>\n</section>\n<hr>\n<section>\n    <span>这是第1列内容<br>这是图片居中，两边是文字，且两边文字设置相同宽度的样式</span> <!-- 这是第1列 -->\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdtht-dark.png\"></img> <!-- 这是第2列 -->\n\t<span>这是第3列内容<br>这是图片居中，两边是文字，且两边文字设置相同宽度的样式</span> <!-- 这是第3列 -->\n</section>\n<section>\n    <span>这是中间是图片，两边是文字的图文样式<br>需要注意：该列文字内容较多，且未设置宽度。<strong>列的宽度比第3列大</strong></span>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdtht-dark.png\"></img>\n\t<span>这是第3列内容</span>\n</section>\n<hr>\n<p>图片和文字，图片设置宽度示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 这是文字在右，图片在左的示例 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;width:200px&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>这是文字在右，图片在左，且设置图片的宽度（如图片宽可以设置为：200px）的图文并排的样式。<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 这是文字在左，图片在右的示例 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>这是文字在左，图片在右，设置图片宽度为 200px 的图文并排的样式！<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;width:200px&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>效果预览</strong>：</p>\n<hr>\n<section>\n   <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\" style=\"width:400px\"></img>\n   <span>这是文字在右，图片在左，且设置图片宽度（如图片宽可以设置为：400px）的图文并排的样式。</span>\n</section>\n<section>\n    <span>这是文字在左，图片在右，且设置图片宽度为 200px 的图文并排的样式！</span>\n    <img src=\"https://raw.gitcode.com/Li2112183373/image/raw/main/mdmdt-title.png\" style=\"width:200px\"></img>\n</section>\n<hr>\n<blockquote>\n<p>[!Important]</p>\n<p><strong>注意：</strong></p>\n<p>由于图片排列的容器 <code>&lt;section&gt;</code> 采用的是grid布局，会根据 <code>&lt;section&gt;</code> 中有几列和每列里的内容自动分配每一列的宽度。</p>\n<p>在进行图片、图片和文字排列时，如果将某一列的宽度设置为 xx%的形式，则该列的实际宽度并<u>不一定是内容区宽度的 xx%</u>，而是 <code>&lt;section&gt;</code> 容器中当前列宽度的 xx%，且当前列的宽度还受到了里面内容的影响。</p>\n<p><strong>基于以上原因，建议在单独设置某一列宽度的时候，尽可能采用具体的值（如: style=“width: 200px”），不要采用 xx%（如: style=“width: 50%”）的形式。</strong></p>\n<p>示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;section&gt; 排列图片的容器，宽度为内容区（也就是书写区）的宽度 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"comment\">&lt;!-- 此时是2列 --&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\"> \t<span class=\"comment\">&lt;!-- 此处的 width:50% ，实际只有内容区宽度的25%（一共2列，每一列宽度50%，50%*50% =&gt; 25%）--&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdtht-dark.png&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;width:50%&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span></span><br><span class=\"line\">   \t<span class=\"comment\">&lt;!-- 此时是3列： img, span, span --&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.jsdelivr.net/gh/LiDaoKuan/image@main/note/mdmdt-title.png&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span>  <span class=\"comment\">&lt;!-- 第1列 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>....<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>  <span class=\"comment\">&lt;!-- 第2列 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>             <span class=\"comment\">&lt;!-- 第3列 --&gt;</span></span><br><span class=\"line\">   \t<span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>这是其段落他文字...<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 此处的 width:50% ，实际只有内容区宽度的16.5%（一共3列，每一列宽度33.33%，33.33%*50% =&gt; 16.65%）--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;width:50%&quot;</span>&gt;</span>这是多段文字<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>这是其段落他文字...<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>除了以上展示的排列方式，更多的排列形式，还请自行探索 …</p>\n<h2 id=\"图表Mermaid\">图表Mermaid</h2>\n<p>以下是 <strong>Mermaid图表</strong> 部分示例，更多图表类型请参考：<a href=\"https://mermaid.js.org\">Mermaid图表</a></p>\n<pre><code class=\"highlight mermaid\">flowchart LR\n    A[Hard edge] --&gt;|Link text| B(Round edge)\n    B --&gt; C&#123;Decision&#125;\n    C --&gt;|One| D[Result one]\n    C --&gt;|Two| E[Result two]</code></pre>\n<pre><code class=\"highlight mermaid\">stateDiagram-v2\n    [*] --&gt; Active\n\n    state Active &#123;\n        [*] --&gt; NumLockOff\n        NumLockOff --&gt; NumLockOn : EvNumLockPressed\n        NumLockOn --&gt; NumLockOff : EvNumLockPressed\n        --\n        [*] --&gt; CapsLockOff\n        CapsLockOff --&gt; CapsLockOn : EvCapsLockPressed\n        CapsLockOn --&gt; CapsLockOff : EvCapsLockPressed\n        --\n        [*] --&gt; ScrollLockOff\n        ScrollLockOff --&gt; ScrollLockOn : EvScrollLockPressed\n        ScrollLockOn --&gt; ScrollLockOff : EvScrollLockPressed\n    &#125;</code></pre>\n<pre><code class=\"highlight mermaid\">gantt\n    dateFormat  YYYY-MM-DD\n    title       Adding GANTT diagram functionality to mermaid\n    excludes    weekends\n    %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week (&quot;sunday&quot;) or &quot;weekends&quot;, but not the word &quot;weekdays&quot;.)\n\n    section A section\n    Completed task            :done,    des1, 2014-01-06,2014-01-08\n    Active task               :active,  des2, 2014-01-09, 3d\n    Future task               :         des3, after des2, 5d\n    Future task2              :         des4, after des3, 5d\n\n    section Critical tasks\n    Completed task in the critical line :crit, done, 2014-01-06,24h\n    Implement parser and jison          :crit, done, after des1, 2d\n    Create tests for parser             :crit, active, 3d\n    Future task in critical line        :crit, 5d\n    Create tests for renderer           :2d\n    Add to mermaid                      :until isadded\n    Functionality added                 :milestone, isadded, 2014-01-25, 0d\n\n    section Documentation\n    Describe gantt syntax               :active, a1, after des1, 3d\n    Add gantt diagram to demo page      :after a1  , 20h\n    Add another diagram to demo page    :doc1, after a1  , 48h\n\n    section Last section\n    Describe gantt syntax               :after doc1, 3d\n    Add gantt diagram to demo page      :20h\n    Add another diagram to demo page    :48h</code></pre>\n<h3 id=\"Flowchart\">Flowchart</h3>\n<h3 id=\"Sequence-Diagram\">Sequence Diagram</h3>\n<h3 id=\"State-Diagram\">State Diagram</h3>\n<h1>一级标题1</h1>\n<h2 id=\"二级标题2\">二级标题2</h2>\n<h3 id=\"三级标题3\">三级标题3</h3>\n<h4 id=\"四级标题4\">四级标题4</h4>\n<h5 id=\"五级标题5\">五级标题5</h5>\n<h6 id=\"六级标题6\">六级标题6</h6>\n<h1>TOC目录</h1>\n<p>以下是 [TOC] 目录样式</p>\n<p>[TOC]</p>\n"},{"title":"Mdmdt theme readme","date":"2025-07-05T16:00:00.000Z","_content":"\n![typora-mdmdt-theme](./img/mdmdt.png)\n# About Mdmdt theme\n\n![Languages](https://img.shields.io/badge/languages-CSS-F34B7D.svg) ![GitHub release (latest by date including pre-releases)](https://img.shields.io/github/v/release/cayxc/Mdmdt?include_prereleases&color=blue&logo=hack-the-box) ![GitHub license](https://img.shields.io/github/license/cayxc/Mdmdt.svg) ![gitee stars](https://gitee.com/cayxc/mdmdt/badge/star.svg) ![gitee forks](https://gitee.com/cayxc/mdmdt/badge/fork.svg)\n\n#### [中文文档](./readme.md)\n\n**Mdmdt** is an abbreviation for Markdown Minimalism Document Theme, meaning: Markdown Minimalism Document Theme.**Mdmdt** is a deeply customized personalized Typora theme, aimed at creating a **refreshing and minimalist** document style. The **Mdmdt** theme has now been included in the [official Typora theme library](https://theme.typoraio.cn).\n\nCompared to the default theme style, the following aspects have been mainly modified:\n1. Simple and comfortable color matching style\n2. Modify the title style\n3. Modify the table style\n4. Modify the reference box style\n5. Add rounded corner style to the image\n6. Add highlight style to code\n7. Modify file tree, outline, and document list styles\n8. Automatic follow system's light/dark theme mode (can be set separately for light/dark themes)\n9. Modify other UI styles\n\n> [!IMPORTANT]\n>\n> **Attention**: This theme has only been tested in Windows and MacOS environments, and has not been tested in Linux environments. Please be aware when using it!\n\n# Preview\n\n![mdmdt-text](./img/mdmdt-text.png)\n![mdmdt-source](./img/mdmdt-source.png)\n![mdmdt-code](./img/mdmdt-code.png)\n![mdmdt-list](./img/mdmdt-list.png)\n![mdmdt-math](./img/mdmdt-math.png)\n![mdmdt-blockquote](./img/mdmdt-blockquote.png)\n![mdmdt-mermaid](./img/mdmdt-mermaid.png)\n![mdmdt-title](./img/mdmdt-title.png)\n\n---\n\n![mdmdt-ui-1](./img/mdmdt-ui-1.png)\n![mdmdt-ui-2](./img/mdmdt-ui-2.png)\n![mdmdt-ui-3](./img/mdmdt-ui-3.png)\n![mdmdt-ui-4](./img/mdmdt-ui-4.png)\n\n# Personalized graphic layout\n\nThis theme provides some personalized graphic and text layout solutions. For specific usage methods, please refer to the \"<u>个性化图文布局</u>\" chapter in the \"**Mdmdt主题演示demo.md**\".\n\n**Personalized graphic layout preview:**\n\n![性化图文排列](./img/mdmdt-layout.png)\n\n# Usage\n\nUsing custom themes is very simple, as follows:\n\n1. Open `Preferences` -> `Appearance` -> `Open Theme Folder`\n2. Copy the downloaded `mdmdt.css`  file to the theme folder.\n3. **Exit Typora and reopen**，In the `Menu Bar` -> `Themes`, Select **Mdmdt** theme and complete the theme switch.\n\n> [!NOTE]\n>\n> **Note:** The mdmdt.css file contains both bright and dark themes, which will automatically switch between bright and dark themes according to the system mode.\n\n##### Use separate Light/Dark theme\n\nIf you only want to use a separate bright or dark theme, the method is as follows:\n1. Open `Preferences` -> `Appearance` -> `Open Theme Folder`\n2. Copy `mdmdt-light.css` or `mdmdt-dark.css ` to the theme folder.\n3. **Exit Typora and reopen**，In the `Menu Bar` -> `Themes`, Select **Mdmdt Light** or **Mdmdt Dark** theme and complete the theme switch.\n\n# Modify font\nIf you are not satisfied with the font, you can refer to the following methods to modify the corresponding font:\n\n1. Modify the text font and find: `font-family: \"PingFang SC\", \"Microsoft YaHei UI\", \"Microsoft YaHei\", Arial, \"Helvetica Neue\", Helvetica, sans-serif;` ,  Then add the font you want to use in the first position after \"font-family:\",  such as: `font-family:  \"The font name you want to use\", \"PingFang SC\", ..., sans-serif;`; Modify the font of the text in the Windows environment and find: ` body.os-windows{...}`, Modify according to the previous method.\n\n2. Modify the code font and find: `--monospace: \"JetBrains Mono\", \"Source Code Pro\", \"Fira Code\", Consolas, Inconsolata, \"Cascadia Code\", Monaco, \"Ubuntu Mono\", monospace;`，Then add the font you want to use in its first position,  such as: `--monospace:  \"The font name you want to use\", \"JetBrains Mono\", ..., monospace;`\n\n**Attention: The prerequisite for changing the font is that the corresponding font is installed on your computer, otherwise the modification is invalid;** If you are not familiar with the \"font-family\" property of CSS, you can refer to it here: https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family\n\n# Export HTML\n\nTo export an HTML file, you can directly select the current theme to export HTML\n**If you want to export HTML files with customizable styles, you can use the Mdtht plugin:**\n\nPlugin homepage address:  [Mdtht-Github-address](https://github.com/cayxc/Mdtht)  [Mdtht-Gitee-address]( https://gitee.com/cayxc/mdtht )\nThis plugin provides the following rich features:\n\n1. Follow the system to automatically switch between bright and dark color modes.\n2. Manually switch between light and dark color modes.\n3. Automatically generate table of contents numbers and body area title indexes.\n4. You can choose to convert the first title into an article title and center the title.\n5. Automatically correct the directory hierarchy based on the position of the titles in the main text.\n6. Show/hide directory index numbers.\n7. Switch between three types of directory button styles.\n8. Automatically track the current reading area location to the current directory and upper level directory.\n9. Expand the screwdriver directory with one click.\n10. One click expand and collapse the sidebar.\n11. Catalog search.\n12. Code highlighting.\n13. Text Shadow Mode.\n\nPlease refer to the plugin homepage for specific details of **mdtht.js** plugin.\n\n\n**Export mdtht.js as an HTML rendering (Light theme)**\n\n---\n\n<img src=\"./img/mdtht-light.png\" alt=\"mdtht-light\" style=\"zoom:50%;\" />**Export mdtht.js as an HTML rendering (Dark theme)**\n\n---\n\n<img src=\"./img/mdtht-dark.png\" alt=\"mdtht-dark\" style=\"zoom:50%;\" />\n\n---\n🐳 If you like the style of this document, please provide a star 😄， If there are any issues during use, please submit them in a timely manner and I will handle them as soon as I see them.\n\n","source":"_posts/主题样例/readme.en.md","raw":"---\ntitle: Mdmdt theme readme\ndate: 2025-07-06\n---\n\n![typora-mdmdt-theme](./img/mdmdt.png)\n# About Mdmdt theme\n\n![Languages](https://img.shields.io/badge/languages-CSS-F34B7D.svg) ![GitHub release (latest by date including pre-releases)](https://img.shields.io/github/v/release/cayxc/Mdmdt?include_prereleases&color=blue&logo=hack-the-box) ![GitHub license](https://img.shields.io/github/license/cayxc/Mdmdt.svg) ![gitee stars](https://gitee.com/cayxc/mdmdt/badge/star.svg) ![gitee forks](https://gitee.com/cayxc/mdmdt/badge/fork.svg)\n\n#### [中文文档](./readme.md)\n\n**Mdmdt** is an abbreviation for Markdown Minimalism Document Theme, meaning: Markdown Minimalism Document Theme.**Mdmdt** is a deeply customized personalized Typora theme, aimed at creating a **refreshing and minimalist** document style. The **Mdmdt** theme has now been included in the [official Typora theme library](https://theme.typoraio.cn).\n\nCompared to the default theme style, the following aspects have been mainly modified:\n1. Simple and comfortable color matching style\n2. Modify the title style\n3. Modify the table style\n4. Modify the reference box style\n5. Add rounded corner style to the image\n6. Add highlight style to code\n7. Modify file tree, outline, and document list styles\n8. Automatic follow system's light/dark theme mode (can be set separately for light/dark themes)\n9. Modify other UI styles\n\n> [!IMPORTANT]\n>\n> **Attention**: This theme has only been tested in Windows and MacOS environments, and has not been tested in Linux environments. Please be aware when using it!\n\n# Preview\n\n![mdmdt-text](./img/mdmdt-text.png)\n![mdmdt-source](./img/mdmdt-source.png)\n![mdmdt-code](./img/mdmdt-code.png)\n![mdmdt-list](./img/mdmdt-list.png)\n![mdmdt-math](./img/mdmdt-math.png)\n![mdmdt-blockquote](./img/mdmdt-blockquote.png)\n![mdmdt-mermaid](./img/mdmdt-mermaid.png)\n![mdmdt-title](./img/mdmdt-title.png)\n\n---\n\n![mdmdt-ui-1](./img/mdmdt-ui-1.png)\n![mdmdt-ui-2](./img/mdmdt-ui-2.png)\n![mdmdt-ui-3](./img/mdmdt-ui-3.png)\n![mdmdt-ui-4](./img/mdmdt-ui-4.png)\n\n# Personalized graphic layout\n\nThis theme provides some personalized graphic and text layout solutions. For specific usage methods, please refer to the \"<u>个性化图文布局</u>\" chapter in the \"**Mdmdt主题演示demo.md**\".\n\n**Personalized graphic layout preview:**\n\n![性化图文排列](./img/mdmdt-layout.png)\n\n# Usage\n\nUsing custom themes is very simple, as follows:\n\n1. Open `Preferences` -> `Appearance` -> `Open Theme Folder`\n2. Copy the downloaded `mdmdt.css`  file to the theme folder.\n3. **Exit Typora and reopen**，In the `Menu Bar` -> `Themes`, Select **Mdmdt** theme and complete the theme switch.\n\n> [!NOTE]\n>\n> **Note:** The mdmdt.css file contains both bright and dark themes, which will automatically switch between bright and dark themes according to the system mode.\n\n##### Use separate Light/Dark theme\n\nIf you only want to use a separate bright or dark theme, the method is as follows:\n1. Open `Preferences` -> `Appearance` -> `Open Theme Folder`\n2. Copy `mdmdt-light.css` or `mdmdt-dark.css ` to the theme folder.\n3. **Exit Typora and reopen**，In the `Menu Bar` -> `Themes`, Select **Mdmdt Light** or **Mdmdt Dark** theme and complete the theme switch.\n\n# Modify font\nIf you are not satisfied with the font, you can refer to the following methods to modify the corresponding font:\n\n1. Modify the text font and find: `font-family: \"PingFang SC\", \"Microsoft YaHei UI\", \"Microsoft YaHei\", Arial, \"Helvetica Neue\", Helvetica, sans-serif;` ,  Then add the font you want to use in the first position after \"font-family:\",  such as: `font-family:  \"The font name you want to use\", \"PingFang SC\", ..., sans-serif;`; Modify the font of the text in the Windows environment and find: ` body.os-windows{...}`, Modify according to the previous method.\n\n2. Modify the code font and find: `--monospace: \"JetBrains Mono\", \"Source Code Pro\", \"Fira Code\", Consolas, Inconsolata, \"Cascadia Code\", Monaco, \"Ubuntu Mono\", monospace;`，Then add the font you want to use in its first position,  such as: `--monospace:  \"The font name you want to use\", \"JetBrains Mono\", ..., monospace;`\n\n**Attention: The prerequisite for changing the font is that the corresponding font is installed on your computer, otherwise the modification is invalid;** If you are not familiar with the \"font-family\" property of CSS, you can refer to it here: https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family\n\n# Export HTML\n\nTo export an HTML file, you can directly select the current theme to export HTML\n**If you want to export HTML files with customizable styles, you can use the Mdtht plugin:**\n\nPlugin homepage address:  [Mdtht-Github-address](https://github.com/cayxc/Mdtht)  [Mdtht-Gitee-address]( https://gitee.com/cayxc/mdtht )\nThis plugin provides the following rich features:\n\n1. Follow the system to automatically switch between bright and dark color modes.\n2. Manually switch between light and dark color modes.\n3. Automatically generate table of contents numbers and body area title indexes.\n4. You can choose to convert the first title into an article title and center the title.\n5. Automatically correct the directory hierarchy based on the position of the titles in the main text.\n6. Show/hide directory index numbers.\n7. Switch between three types of directory button styles.\n8. Automatically track the current reading area location to the current directory and upper level directory.\n9. Expand the screwdriver directory with one click.\n10. One click expand and collapse the sidebar.\n11. Catalog search.\n12. Code highlighting.\n13. Text Shadow Mode.\n\nPlease refer to the plugin homepage for specific details of **mdtht.js** plugin.\n\n\n**Export mdtht.js as an HTML rendering (Light theme)**\n\n---\n\n<img src=\"./img/mdtht-light.png\" alt=\"mdtht-light\" style=\"zoom:50%;\" />**Export mdtht.js as an HTML rendering (Dark theme)**\n\n---\n\n<img src=\"./img/mdtht-dark.png\" alt=\"mdtht-dark\" style=\"zoom:50%;\" />\n\n---\n🐳 If you like the style of this document, please provide a star 😄， If there are any issues during use, please submit them in a timely manner and I will handle them as soon as I see them.\n\n","slug":"主题样例/readme.en","published":1,"updated":"2025-09-14T02:36:11.047Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpn000f4e4pbqwf680e","content":"<p><img src=\"/./img/mdmdt.png\" alt=\"typora-mdmdt-theme\"></p>\n<h1>About Mdmdt theme</h1>\n<p><img src=\"https://img.shields.io/badge/languages-CSS-F34B7D.svg\" alt=\"Languages\"> <img src=\"https://img.shields.io/github/v/release/cayxc/Mdmdt?include_prereleases&amp;color=blue&amp;logo=hack-the-box\" alt=\"GitHub release (latest by date including pre-releases)\"> <img src=\"https://img.shields.io/github/license/cayxc/Mdmdt.svg\" alt=\"GitHub license\"> <img src=\"https://gitee.com/cayxc/mdmdt/badge/star.svg\" alt=\"gitee stars\"> <img src=\"https://gitee.com/cayxc/mdmdt/badge/fork.svg\" alt=\"gitee forks\"></p>\n<h4 id=\"中文文档\"><a href=\"./readme.md\">中文文档</a></h4>\n<p><strong>Mdmdt</strong> is an abbreviation for Markdown Minimalism Document Theme, meaning: Markdown Minimalism Document Theme.<strong>Mdmdt</strong> is a deeply customized personalized Typora theme, aimed at creating a <strong>refreshing and minimalist</strong> document style. The <strong>Mdmdt</strong> theme has now been included in the <a href=\"https://theme.typoraio.cn\">official Typora theme library</a>.</p>\n<p>Compared to the default theme style, the following aspects have been mainly modified:</p>\n<ol>\n<li>Simple and comfortable color matching style</li>\n<li>Modify the title style</li>\n<li>Modify the table style</li>\n<li>Modify the reference box style</li>\n<li>Add rounded corner style to the image</li>\n<li>Add highlight style to code</li>\n<li>Modify file tree, outline, and document list styles</li>\n<li>Automatic follow system’s light/dark theme mode (can be set separately for light/dark themes)</li>\n<li>Modify other UI styles</li>\n</ol>\n<blockquote>\n<p>[!IMPORTANT]</p>\n<p><strong>Attention</strong>: This theme has only been tested in Windows and MacOS environments, and has not been tested in Linux environments. Please be aware when using it!</p>\n</blockquote>\n<h1>Preview</h1>\n<p><img src=\"/./img/mdmdt-text.png\" alt=\"mdmdt-text\"><br>\n<img src=\"/./img/mdmdt-source.png\" alt=\"mdmdt-source\"><br>\n<img src=\"/./img/mdmdt-code.png\" alt=\"mdmdt-code\"><br>\n<img src=\"/./img/mdmdt-list.png\" alt=\"mdmdt-list\"><br>\n<img src=\"/./img/mdmdt-math.png\" alt=\"mdmdt-math\"><br>\n<img src=\"/./img/mdmdt-blockquote.png\" alt=\"mdmdt-blockquote\"><br>\n<img src=\"/./img/mdmdt-mermaid.png\" alt=\"mdmdt-mermaid\"><br>\n<img src=\"/./img/mdmdt-title.png\" alt=\"mdmdt-title\"></p>\n<hr>\n<p><img src=\"/./img/mdmdt-ui-1.png\" alt=\"mdmdt-ui-1\"><br>\n<img src=\"/./img/mdmdt-ui-2.png\" alt=\"mdmdt-ui-2\"><br>\n<img src=\"/./img/mdmdt-ui-3.png\" alt=\"mdmdt-ui-3\"><br>\n<img src=\"/./img/mdmdt-ui-4.png\" alt=\"mdmdt-ui-4\"></p>\n<h1>Personalized graphic layout</h1>\n<p>This theme provides some personalized graphic and text layout solutions. For specific usage methods, please refer to the “<u>个性化图文布局</u>” chapter in the “<strong><a href=\"http://xn--Mdmdtdemo-up6nt400a0pzash9f.md\">Mdmdt主题演示demo.md</a></strong>”.</p>\n<p><strong>Personalized graphic layout preview:</strong></p>\n<p><img src=\"/./img/mdmdt-layout.png\" alt=\"性化图文排列\"></p>\n<h1>Usage</h1>\n<p>Using custom themes is very simple, as follows:</p>\n<ol>\n<li>Open <code>Preferences</code> -&gt; <code>Appearance</code> -&gt; <code>Open Theme Folder</code></li>\n<li>Copy the downloaded <code>mdmdt.css</code>  file to the theme folder.</li>\n<li><strong>Exit Typora and reopen</strong>，In the <code>Menu Bar</code> -&gt; <code>Themes</code>, Select <strong>Mdmdt</strong> theme and complete the theme switch.</li>\n</ol>\n<blockquote>\n<p>[!NOTE]</p>\n<p><strong>Note:</strong> The mdmdt.css file contains both bright and dark themes, which will automatically switch between bright and dark themes according to the system mode.</p>\n</blockquote>\n<h5 id=\"Use-separate-Light-Dark-theme\">Use separate Light/Dark theme</h5>\n<p>If you only want to use a separate bright or dark theme, the method is as follows:</p>\n<ol>\n<li>Open <code>Preferences</code> -&gt; <code>Appearance</code> -&gt; <code>Open Theme Folder</code></li>\n<li>Copy <code>mdmdt-light.css</code> or <code>mdmdt-dark.css </code> to the theme folder.</li>\n<li><strong>Exit Typora and reopen</strong>，In the <code>Menu Bar</code> -&gt; <code>Themes</code>, Select <strong>Mdmdt Light</strong> or <strong>Mdmdt Dark</strong> theme and complete the theme switch.</li>\n</ol>\n<h1>Modify font</h1>\n<p>If you are not satisfied with the font, you can refer to the following methods to modify the corresponding font:</p>\n<ol>\n<li>\n<p>Modify the text font and find: <code>font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, &quot;Helvetica Neue&quot;, Helvetica, sans-serif;</code> ,  Then add the font you want to use in the first position after “font-family:”,  such as: <code>font-family:  &quot;The font name you want to use&quot;, &quot;PingFang SC&quot;, ..., sans-serif;</code>; Modify the font of the text in the Windows environment and find: <code> body.os-windows&#123;...&#125;</code>, Modify according to the previous method.</p>\n</li>\n<li>\n<p>Modify the code font and find: <code>--monospace: &quot;JetBrains Mono&quot;, &quot;Source Code Pro&quot;, &quot;Fira Code&quot;, Consolas, Inconsolata, &quot;Cascadia Code&quot;, Monaco, &quot;Ubuntu Mono&quot;, monospace;</code>，Then add the font you want to use in its first position,  such as: <code>--monospace:  &quot;The font name you want to use&quot;, &quot;JetBrains Mono&quot;, ..., monospace;</code></p>\n</li>\n</ol>\n<p><strong>Attention: The prerequisite for changing the font is that the corresponding font is installed on your computer, otherwise the modification is invalid;</strong> If you are not familiar with the “font-family” property of CSS, you can refer to it here: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family</a></p>\n<h1>Export HTML</h1>\n<p>To export an HTML file, you can directly select the current theme to export HTML<br>\n<strong>If you want to export HTML files with customizable styles, you can use the Mdtht plugin:</strong></p>\n<p>Plugin homepage address:  <a href=\"https://github.com/cayxc/Mdtht\">Mdtht-Github-address</a>  <a href=\"https://gitee.com/cayxc/mdtht\">Mdtht-Gitee-address</a><br>\nThis plugin provides the following rich features:</p>\n<ol>\n<li>Follow the system to automatically switch between bright and dark color modes.</li>\n<li>Manually switch between light and dark color modes.</li>\n<li>Automatically generate table of contents numbers and body area title indexes.</li>\n<li>You can choose to convert the first title into an article title and center the title.</li>\n<li>Automatically correct the directory hierarchy based on the position of the titles in the main text.</li>\n<li>Show/hide directory index numbers.</li>\n<li>Switch between three types of directory button styles.</li>\n<li>Automatically track the current reading area location to the current directory and upper level directory.</li>\n<li>Expand the screwdriver directory with one click.</li>\n<li>One click expand and collapse the sidebar.</li>\n<li>Catalog search.</li>\n<li>Code highlighting.</li>\n<li>Text Shadow Mode.</li>\n</ol>\n<p>Please refer to the plugin homepage for specific details of <strong>mdtht.js</strong> plugin.</p>\n<p><strong>Export mdtht.js as an HTML rendering (Light theme)</strong></p>\n<hr>\n<p><img src=\"./img/mdtht-light.png\" alt=\"mdtht-light\" style=\"zoom:50%;\" /><strong>Export mdtht.js as an HTML rendering (Dark theme)</strong></p>\n<hr>\n<img src=\"./img/mdtht-dark.png\" alt=\"mdtht-dark\" style=\"zoom:50%;\" />\n<hr>\n<p>🐳 If you like the style of this document, please provide a star 😄， If there are any issues during use, please submit them in a timely manner and I will handle them as soon as I see them.</p>\n","excerpt":"","more":"<p><img src=\"/./img/mdmdt.png\" alt=\"typora-mdmdt-theme\"></p>\n<h1>About Mdmdt theme</h1>\n<p><img src=\"https://img.shields.io/badge/languages-CSS-F34B7D.svg\" alt=\"Languages\"> <img src=\"https://img.shields.io/github/v/release/cayxc/Mdmdt?include_prereleases&amp;color=blue&amp;logo=hack-the-box\" alt=\"GitHub release (latest by date including pre-releases)\"> <img src=\"https://img.shields.io/github/license/cayxc/Mdmdt.svg\" alt=\"GitHub license\"> <img src=\"https://gitee.com/cayxc/mdmdt/badge/star.svg\" alt=\"gitee stars\"> <img src=\"https://gitee.com/cayxc/mdmdt/badge/fork.svg\" alt=\"gitee forks\"></p>\n<h4 id=\"中文文档\"><a href=\"./readme.md\">中文文档</a></h4>\n<p><strong>Mdmdt</strong> is an abbreviation for Markdown Minimalism Document Theme, meaning: Markdown Minimalism Document Theme.<strong>Mdmdt</strong> is a deeply customized personalized Typora theme, aimed at creating a <strong>refreshing and minimalist</strong> document style. The <strong>Mdmdt</strong> theme has now been included in the <a href=\"https://theme.typoraio.cn\">official Typora theme library</a>.</p>\n<p>Compared to the default theme style, the following aspects have been mainly modified:</p>\n<ol>\n<li>Simple and comfortable color matching style</li>\n<li>Modify the title style</li>\n<li>Modify the table style</li>\n<li>Modify the reference box style</li>\n<li>Add rounded corner style to the image</li>\n<li>Add highlight style to code</li>\n<li>Modify file tree, outline, and document list styles</li>\n<li>Automatic follow system’s light/dark theme mode (can be set separately for light/dark themes)</li>\n<li>Modify other UI styles</li>\n</ol>\n<blockquote>\n<p>[!IMPORTANT]</p>\n<p><strong>Attention</strong>: This theme has only been tested in Windows and MacOS environments, and has not been tested in Linux environments. Please be aware when using it!</p>\n</blockquote>\n<h1>Preview</h1>\n<p><img src=\"/./img/mdmdt-text.png\" alt=\"mdmdt-text\"><br>\n<img src=\"/./img/mdmdt-source.png\" alt=\"mdmdt-source\"><br>\n<img src=\"/./img/mdmdt-code.png\" alt=\"mdmdt-code\"><br>\n<img src=\"/./img/mdmdt-list.png\" alt=\"mdmdt-list\"><br>\n<img src=\"/./img/mdmdt-math.png\" alt=\"mdmdt-math\"><br>\n<img src=\"/./img/mdmdt-blockquote.png\" alt=\"mdmdt-blockquote\"><br>\n<img src=\"/./img/mdmdt-mermaid.png\" alt=\"mdmdt-mermaid\"><br>\n<img src=\"/./img/mdmdt-title.png\" alt=\"mdmdt-title\"></p>\n<hr>\n<p><img src=\"/./img/mdmdt-ui-1.png\" alt=\"mdmdt-ui-1\"><br>\n<img src=\"/./img/mdmdt-ui-2.png\" alt=\"mdmdt-ui-2\"><br>\n<img src=\"/./img/mdmdt-ui-3.png\" alt=\"mdmdt-ui-3\"><br>\n<img src=\"/./img/mdmdt-ui-4.png\" alt=\"mdmdt-ui-4\"></p>\n<h1>Personalized graphic layout</h1>\n<p>This theme provides some personalized graphic and text layout solutions. For specific usage methods, please refer to the “<u>个性化图文布局</u>” chapter in the “<strong><a href=\"http://xn--Mdmdtdemo-up6nt400a0pzash9f.md\">Mdmdt主题演示demo.md</a></strong>”.</p>\n<p><strong>Personalized graphic layout preview:</strong></p>\n<p><img src=\"/./img/mdmdt-layout.png\" alt=\"性化图文排列\"></p>\n<h1>Usage</h1>\n<p>Using custom themes is very simple, as follows:</p>\n<ol>\n<li>Open <code>Preferences</code> -&gt; <code>Appearance</code> -&gt; <code>Open Theme Folder</code></li>\n<li>Copy the downloaded <code>mdmdt.css</code>  file to the theme folder.</li>\n<li><strong>Exit Typora and reopen</strong>，In the <code>Menu Bar</code> -&gt; <code>Themes</code>, Select <strong>Mdmdt</strong> theme and complete the theme switch.</li>\n</ol>\n<blockquote>\n<p>[!NOTE]</p>\n<p><strong>Note:</strong> The mdmdt.css file contains both bright and dark themes, which will automatically switch between bright and dark themes according to the system mode.</p>\n</blockquote>\n<h5 id=\"Use-separate-Light-Dark-theme\">Use separate Light/Dark theme</h5>\n<p>If you only want to use a separate bright or dark theme, the method is as follows:</p>\n<ol>\n<li>Open <code>Preferences</code> -&gt; <code>Appearance</code> -&gt; <code>Open Theme Folder</code></li>\n<li>Copy <code>mdmdt-light.css</code> or <code>mdmdt-dark.css </code> to the theme folder.</li>\n<li><strong>Exit Typora and reopen</strong>，In the <code>Menu Bar</code> -&gt; <code>Themes</code>, Select <strong>Mdmdt Light</strong> or <strong>Mdmdt Dark</strong> theme and complete the theme switch.</li>\n</ol>\n<h1>Modify font</h1>\n<p>If you are not satisfied with the font, you can refer to the following methods to modify the corresponding font:</p>\n<ol>\n<li>\n<p>Modify the text font and find: <code>font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, &quot;Helvetica Neue&quot;, Helvetica, sans-serif;</code> ,  Then add the font you want to use in the first position after “font-family:”,  such as: <code>font-family:  &quot;The font name you want to use&quot;, &quot;PingFang SC&quot;, ..., sans-serif;</code>; Modify the font of the text in the Windows environment and find: <code> body.os-windows&#123;...&#125;</code>, Modify according to the previous method.</p>\n</li>\n<li>\n<p>Modify the code font and find: <code>--monospace: &quot;JetBrains Mono&quot;, &quot;Source Code Pro&quot;, &quot;Fira Code&quot;, Consolas, Inconsolata, &quot;Cascadia Code&quot;, Monaco, &quot;Ubuntu Mono&quot;, monospace;</code>，Then add the font you want to use in its first position,  such as: <code>--monospace:  &quot;The font name you want to use&quot;, &quot;JetBrains Mono&quot;, ..., monospace;</code></p>\n</li>\n</ol>\n<p><strong>Attention: The prerequisite for changing the font is that the corresponding font is installed on your computer, otherwise the modification is invalid;</strong> If you are not familiar with the “font-family” property of CSS, you can refer to it here: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family</a></p>\n<h1>Export HTML</h1>\n<p>To export an HTML file, you can directly select the current theme to export HTML<br>\n<strong>If you want to export HTML files with customizable styles, you can use the Mdtht plugin:</strong></p>\n<p>Plugin homepage address:  <a href=\"https://github.com/cayxc/Mdtht\">Mdtht-Github-address</a>  <a href=\"https://gitee.com/cayxc/mdtht\">Mdtht-Gitee-address</a><br>\nThis plugin provides the following rich features:</p>\n<ol>\n<li>Follow the system to automatically switch between bright and dark color modes.</li>\n<li>Manually switch between light and dark color modes.</li>\n<li>Automatically generate table of contents numbers and body area title indexes.</li>\n<li>You can choose to convert the first title into an article title and center the title.</li>\n<li>Automatically correct the directory hierarchy based on the position of the titles in the main text.</li>\n<li>Show/hide directory index numbers.</li>\n<li>Switch between three types of directory button styles.</li>\n<li>Automatically track the current reading area location to the current directory and upper level directory.</li>\n<li>Expand the screwdriver directory with one click.</li>\n<li>One click expand and collapse the sidebar.</li>\n<li>Catalog search.</li>\n<li>Code highlighting.</li>\n<li>Text Shadow Mode.</li>\n</ol>\n<p>Please refer to the plugin homepage for specific details of <strong>mdtht.js</strong> plugin.</p>\n<p><strong>Export mdtht.js as an HTML rendering (Light theme)</strong></p>\n<hr>\n<p><img src=\"./img/mdtht-light.png\" alt=\"mdtht-light\" style=\"zoom:50%;\" /><strong>Export mdtht.js as an HTML rendering (Dark theme)</strong></p>\n<hr>\n<img src=\"./img/mdtht-dark.png\" alt=\"mdtht-dark\" style=\"zoom:50%;\" />\n<hr>\n<p>🐳 If you like the style of this document, please provide a star 😄， If there are any issues during use, please submit them in a timely manner and I will handle them as soon as I see them.</p>\n"},{"title":"Mdmdt主题","date":"2025-07-05T16:00:00.000Z","_content":"\n![typora-mdmdt-theme](./img/mdmdt.png)\n# 关于Mdmdt主题\n![Languages](https://img.shields.io/badge/languages-CSS-F34B7D.svg) ![GitHub release (latest by date including pre-releases)](https://img.shields.io/github/v/release/cayxc/Mdmdt?include_prereleases&color=blue&logo=hack-the-box) ![GitHub license](https://img.shields.io/github/license/cayxc/Mdmdt.svg) ![gitee stars](https://gitee.com/cayxc/mdmdt/badge/star.svg) ![gitee forks](https://gitee.com/cayxc/mdmdt/badge/fork.svg)\n\n#### [English Document](./readme.en.md)\n\n**Mdmdt** 是 markdown minimalism document theme 的缩写，意为：**Markdown极简文档主题**。\n**Mdmdt** 是深度定制的个性化Typora主题，其目的是打造一个 **清爽极简** 的文档样式。**Mdmdt** 主题现已收录至 [Typora官方主题库https://theme.typoraio.cn](https://theme.typoraio.cn/).\n\n相比于默认主题风格主要修改了以下几个方面：\n1. 简洁舒适的配色风格\n2. 修改标题样式\n3. 修改表格样式\n4. 修改引用框样式\n5. 为图片添加圆角样式\n6. 代码添加高亮样式\n7. 修改文件树、大纲和文档列表样式\n8. 自动跟随系统的亮色/暗色主题模式（可单独设置亮/暗主题)\n9. 修改其他UI样式\n\n> [!IMPORTANT]\n>\n> **注意：**该主题只在 Windows 和 MacOS 环境下测试过，Linux环境下未做测试，使用时还请注意！\n\n# 预览\n\n![mdmdt-text](./img/mdmdt-text.png)\n![mdmdt-source](./img/mdmdt-source.png)\n![mdmdt-code](./img/mdmdt-code.png)\n![mdmdt-list](./img/mdmdt-list.png)\n![mdmdt-math](./img/mdmdt-math.png)\n![mdmdt-blockquote](./img/mdmdt-blockquote.png)\n![mdmdt-mermaid](./img/mdmdt-mermaid.png)\n![mdmdt-title](./img/mdmdt-title.png)\n\n---\n\n![mdmdt-ui-1](./img/mdmdt-ui-1.png)\n![mdmdt-ui-2](./img/mdmdt-ui-2.png)\n![mdmdt-ui-3](./img/mdmdt-ui-3.png)\n![mdmdt-ui-4](./img/mdmdt-ui-4.png)\n\n# 个性化图文布局\n\n本主题提供了一些个性化图文布局方案，具体使用方法请参考 “**Mdmdt主题演示demo.md**” 中的“<u>个性化图文布局</u>”章节相关内容。\n\n**个性化图文布局预览:**\n\n![性化图文排列](./img/mdmdt-layout.png)\n\n# 如何使用\n\n使用自定义主题非常简单，方法如下：\n1. 打开 `偏好设置` -> `外观` -> `打开主题文件夹`\n2. 将下载好的 `mdmdt.css文件` 复制到主题文件夹下\n3. **退出 Typora 重新打开**，在 `菜单栏` -> `主题` 选择 **Mdmdt** 主题，完成主题切换。\n\n> [!NOTE]\n>\n> **注意：**mdmdt.css 文件中包含了亮色和暗色两者主题，会跟随系统模式自动切换亮暗主题。\n\n##### 使用单独的亮色/暗色主题\n\n如果只想使用单独的亮色或暗色主题，方法如下：\n1. 打开 `偏好设置` -> `外观` -> `打开主题文件夹`\n2. 复制 `mdmdt-light.css` 或者 `mdmdt-dark.css` 到 `主题文件夹下`\n3. 重新打开Typora，在 `菜单栏` -> `主题` 选择 **Mdmdt Ligh** 或者 **mdmdt Dark** 主题，完成主题切换。\n\n# 修改字体\n\n如果您对字体不满意，可以参照如下方法修改相应的字体：\n\n1. 修改正文字体，找到：`font-family: \"PingFang SC\", \"Microsoft YaHei UI\", \"Microsoft YaHei\", Arial, \"Helvetica Neue\", Helvetica, sans-serif;` 在 “font-family:” 后第一个位置添加你想使用的字体，如：`font-family: \"想使用的字体名称\", \"PingFang SC\", ..., sans-serif;`；Windows环境下修改正文字体，找到：`body.os-windows{...}`，按照前面方式修改。\n2. 修改代码字体，找到：`--monospace: \"JetBrains Mono\", \"Source Code Pro\", \"Fira Code\", Consolas, Inconsolata, \"Cascadia Code\", Monaco, \"Ubuntu Mono\", monospace;`， 然后在其第一个位置添加你想使用的字体，如：`--monospace: \"想使用的字体名称\", \"JetBrains Mono\", ..., monospace;`\n\n**注意：更换字体的前提是你电脑上要安装有相应的字体，否则修改无效**。如果您不了解 CSS 的 \"font-family\" 属性，可以参考这里：https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family\n\n# 导出html\n\n想要导出 html 文件可以直接选择当前主题导出 html\n\n**如果想要导出的 html 文件能自定义更多样式，可以使用 Mdtht 插件：**\n\n插件主页地址：[Mdtht-Gitub地址](https://github.com/cayxc/Mdtht)   [Mdtht-Gitee地址](https://gitee.com/cayxc/mdtht)\n\n该插件提供了如下丰富功能：\n\n1. 跟随系统自动切换亮色/暗色模式。\n2. 手动切换亮色/暗色模式。\n3. 自动生成目录编号和正文区标题索引。\n4. 可选择将第一个标题转换为文章标题，并将标题居中。\n5. 根据正文中标题的位置自动纠正目录层级。\n6. 显示/隐藏目录索引编号。\n7. 3种目录按钮样式切换。\n8. 根据当前阅读区位置自动追踪到所在目录和上层目录。\n9. 一键展开收起子目录。\n10. 一键展开收起侧边栏。\n11. 目录搜索。\n12. 代码高亮。\n13. 文字阴影模式。\n\n **mdtht.js** 插件具体详情请参考插件主页。\n\n**mdtht.js导出为 html 效果图（亮色）**\n\n---\n\n<img src=\"./img/mdtht-light.png\" alt=\"mdmdt-light\" style=\"zoom:50%;\" /> **mdtht.js导出为 html 效果图（暗色）**\n\n---\n\n<img src=\"./img/mdtht-dark.png\" alt=\"mdmdt-dark\" style=\"zoom:50%;\" />\n\n---\n\n🐳 如果您喜欢该文档样式风格，还请给一个 star 😄，使用过程中有什么问题请及时提交 issues，看到后我会第一时间处理。\n\n\n\n","source":"_posts/主题样例/readme.md","raw":"---\ntitle: Mdmdt主题\ndate: 2025-07-06\n---\n\n![typora-mdmdt-theme](./img/mdmdt.png)\n# 关于Mdmdt主题\n![Languages](https://img.shields.io/badge/languages-CSS-F34B7D.svg) ![GitHub release (latest by date including pre-releases)](https://img.shields.io/github/v/release/cayxc/Mdmdt?include_prereleases&color=blue&logo=hack-the-box) ![GitHub license](https://img.shields.io/github/license/cayxc/Mdmdt.svg) ![gitee stars](https://gitee.com/cayxc/mdmdt/badge/star.svg) ![gitee forks](https://gitee.com/cayxc/mdmdt/badge/fork.svg)\n\n#### [English Document](./readme.en.md)\n\n**Mdmdt** 是 markdown minimalism document theme 的缩写，意为：**Markdown极简文档主题**。\n**Mdmdt** 是深度定制的个性化Typora主题，其目的是打造一个 **清爽极简** 的文档样式。**Mdmdt** 主题现已收录至 [Typora官方主题库https://theme.typoraio.cn](https://theme.typoraio.cn/).\n\n相比于默认主题风格主要修改了以下几个方面：\n1. 简洁舒适的配色风格\n2. 修改标题样式\n3. 修改表格样式\n4. 修改引用框样式\n5. 为图片添加圆角样式\n6. 代码添加高亮样式\n7. 修改文件树、大纲和文档列表样式\n8. 自动跟随系统的亮色/暗色主题模式（可单独设置亮/暗主题)\n9. 修改其他UI样式\n\n> [!IMPORTANT]\n>\n> **注意：**该主题只在 Windows 和 MacOS 环境下测试过，Linux环境下未做测试，使用时还请注意！\n\n# 预览\n\n![mdmdt-text](./img/mdmdt-text.png)\n![mdmdt-source](./img/mdmdt-source.png)\n![mdmdt-code](./img/mdmdt-code.png)\n![mdmdt-list](./img/mdmdt-list.png)\n![mdmdt-math](./img/mdmdt-math.png)\n![mdmdt-blockquote](./img/mdmdt-blockquote.png)\n![mdmdt-mermaid](./img/mdmdt-mermaid.png)\n![mdmdt-title](./img/mdmdt-title.png)\n\n---\n\n![mdmdt-ui-1](./img/mdmdt-ui-1.png)\n![mdmdt-ui-2](./img/mdmdt-ui-2.png)\n![mdmdt-ui-3](./img/mdmdt-ui-3.png)\n![mdmdt-ui-4](./img/mdmdt-ui-4.png)\n\n# 个性化图文布局\n\n本主题提供了一些个性化图文布局方案，具体使用方法请参考 “**Mdmdt主题演示demo.md**” 中的“<u>个性化图文布局</u>”章节相关内容。\n\n**个性化图文布局预览:**\n\n![性化图文排列](./img/mdmdt-layout.png)\n\n# 如何使用\n\n使用自定义主题非常简单，方法如下：\n1. 打开 `偏好设置` -> `外观` -> `打开主题文件夹`\n2. 将下载好的 `mdmdt.css文件` 复制到主题文件夹下\n3. **退出 Typora 重新打开**，在 `菜单栏` -> `主题` 选择 **Mdmdt** 主题，完成主题切换。\n\n> [!NOTE]\n>\n> **注意：**mdmdt.css 文件中包含了亮色和暗色两者主题，会跟随系统模式自动切换亮暗主题。\n\n##### 使用单独的亮色/暗色主题\n\n如果只想使用单独的亮色或暗色主题，方法如下：\n1. 打开 `偏好设置` -> `外观` -> `打开主题文件夹`\n2. 复制 `mdmdt-light.css` 或者 `mdmdt-dark.css` 到 `主题文件夹下`\n3. 重新打开Typora，在 `菜单栏` -> `主题` 选择 **Mdmdt Ligh** 或者 **mdmdt Dark** 主题，完成主题切换。\n\n# 修改字体\n\n如果您对字体不满意，可以参照如下方法修改相应的字体：\n\n1. 修改正文字体，找到：`font-family: \"PingFang SC\", \"Microsoft YaHei UI\", \"Microsoft YaHei\", Arial, \"Helvetica Neue\", Helvetica, sans-serif;` 在 “font-family:” 后第一个位置添加你想使用的字体，如：`font-family: \"想使用的字体名称\", \"PingFang SC\", ..., sans-serif;`；Windows环境下修改正文字体，找到：`body.os-windows{...}`，按照前面方式修改。\n2. 修改代码字体，找到：`--monospace: \"JetBrains Mono\", \"Source Code Pro\", \"Fira Code\", Consolas, Inconsolata, \"Cascadia Code\", Monaco, \"Ubuntu Mono\", monospace;`， 然后在其第一个位置添加你想使用的字体，如：`--monospace: \"想使用的字体名称\", \"JetBrains Mono\", ..., monospace;`\n\n**注意：更换字体的前提是你电脑上要安装有相应的字体，否则修改无效**。如果您不了解 CSS 的 \"font-family\" 属性，可以参考这里：https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family\n\n# 导出html\n\n想要导出 html 文件可以直接选择当前主题导出 html\n\n**如果想要导出的 html 文件能自定义更多样式，可以使用 Mdtht 插件：**\n\n插件主页地址：[Mdtht-Gitub地址](https://github.com/cayxc/Mdtht)   [Mdtht-Gitee地址](https://gitee.com/cayxc/mdtht)\n\n该插件提供了如下丰富功能：\n\n1. 跟随系统自动切换亮色/暗色模式。\n2. 手动切换亮色/暗色模式。\n3. 自动生成目录编号和正文区标题索引。\n4. 可选择将第一个标题转换为文章标题，并将标题居中。\n5. 根据正文中标题的位置自动纠正目录层级。\n6. 显示/隐藏目录索引编号。\n7. 3种目录按钮样式切换。\n8. 根据当前阅读区位置自动追踪到所在目录和上层目录。\n9. 一键展开收起子目录。\n10. 一键展开收起侧边栏。\n11. 目录搜索。\n12. 代码高亮。\n13. 文字阴影模式。\n\n **mdtht.js** 插件具体详情请参考插件主页。\n\n**mdtht.js导出为 html 效果图（亮色）**\n\n---\n\n<img src=\"./img/mdtht-light.png\" alt=\"mdmdt-light\" style=\"zoom:50%;\" /> **mdtht.js导出为 html 效果图（暗色）**\n\n---\n\n<img src=\"./img/mdtht-dark.png\" alt=\"mdmdt-dark\" style=\"zoom:50%;\" />\n\n---\n\n🐳 如果您喜欢该文档样式风格，还请给一个 star 😄，使用过程中有什么问题请及时提交 issues，看到后我会第一时间处理。\n\n\n\n","slug":"主题样例/readme","published":1,"updated":"2025-09-14T02:36:11.047Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpo000j4e4p8fpo1l7f","content":"<p><img src=\"/./img/mdmdt.png\" alt=\"typora-mdmdt-theme\"></p>\n<h1>关于Mdmdt主题</h1>\n<p><img src=\"https://img.shields.io/badge/languages-CSS-F34B7D.svg\" alt=\"Languages\"> <img src=\"https://img.shields.io/github/v/release/cayxc/Mdmdt?include_prereleases&amp;color=blue&amp;logo=hack-the-box\" alt=\"GitHub release (latest by date including pre-releases)\"> <img src=\"https://img.shields.io/github/license/cayxc/Mdmdt.svg\" alt=\"GitHub license\"> <img src=\"https://gitee.com/cayxc/mdmdt/badge/star.svg\" alt=\"gitee stars\"> <img src=\"https://gitee.com/cayxc/mdmdt/badge/fork.svg\" alt=\"gitee forks\"></p>\n<h4 id=\"English-Document\"><a href=\"./readme.en.md\">English Document</a></h4>\n<p><strong>Mdmdt</strong> 是 markdown minimalism document theme 的缩写，意为：<strong>Markdown极简文档主题</strong>。<br>\n<strong>Mdmdt</strong> 是深度定制的个性化Typora主题，其目的是打造一个 <strong>清爽极简</strong> 的文档样式。<strong>Mdmdt</strong> 主题现已收录至 <a href=\"https://theme.typoraio.cn/\">Typora官方主题库https://theme.typoraio.cn</a>.</p>\n<p>相比于默认主题风格主要修改了以下几个方面：</p>\n<ol>\n<li>简洁舒适的配色风格</li>\n<li>修改标题样式</li>\n<li>修改表格样式</li>\n<li>修改引用框样式</li>\n<li>为图片添加圆角样式</li>\n<li>代码添加高亮样式</li>\n<li>修改文件树、大纲和文档列表样式</li>\n<li>自动跟随系统的亮色/暗色主题模式（可单独设置亮/暗主题)</li>\n<li>修改其他UI样式</li>\n</ol>\n<blockquote>\n<p>[!IMPORTANT]</p>\n<p>**注意：**该主题只在 Windows 和 MacOS 环境下测试过，Linux环境下未做测试，使用时还请注意！</p>\n</blockquote>\n<h1>预览</h1>\n<p><img src=\"/./img/mdmdt-text.png\" alt=\"mdmdt-text\"><br>\n<img src=\"/./img/mdmdt-source.png\" alt=\"mdmdt-source\"><br>\n<img src=\"/./img/mdmdt-code.png\" alt=\"mdmdt-code\"><br>\n<img src=\"/./img/mdmdt-list.png\" alt=\"mdmdt-list\"><br>\n<img src=\"/./img/mdmdt-math.png\" alt=\"mdmdt-math\"><br>\n<img src=\"/./img/mdmdt-blockquote.png\" alt=\"mdmdt-blockquote\"><br>\n<img src=\"/./img/mdmdt-mermaid.png\" alt=\"mdmdt-mermaid\"><br>\n<img src=\"/./img/mdmdt-title.png\" alt=\"mdmdt-title\"></p>\n<hr>\n<p><img src=\"/./img/mdmdt-ui-1.png\" alt=\"mdmdt-ui-1\"><br>\n<img src=\"/./img/mdmdt-ui-2.png\" alt=\"mdmdt-ui-2\"><br>\n<img src=\"/./img/mdmdt-ui-3.png\" alt=\"mdmdt-ui-3\"><br>\n<img src=\"/./img/mdmdt-ui-4.png\" alt=\"mdmdt-ui-4\"></p>\n<h1>个性化图文布局</h1>\n<p>本主题提供了一些个性化图文布局方案，具体使用方法请参考 “<strong><a href=\"http://xn--Mdmdtdemo-up6nt400a0pzash9f.md\">Mdmdt主题演示demo.md</a></strong>” 中的“<u>个性化图文布局</u>”章节相关内容。</p>\n<p><strong>个性化图文布局预览:</strong></p>\n<p><img src=\"/./img/mdmdt-layout.png\" alt=\"性化图文排列\"></p>\n<h1>如何使用</h1>\n<p>使用自定义主题非常简单，方法如下：</p>\n<ol>\n<li>打开 <code>偏好设置</code> -&gt; <code>外观</code> -&gt; <code>打开主题文件夹</code></li>\n<li>将下载好的 <code>mdmdt.css文件</code> 复制到主题文件夹下</li>\n<li><strong>退出 Typora 重新打开</strong>，在 <code>菜单栏</code> -&gt; <code>主题</code> 选择 <strong>Mdmdt</strong> 主题，完成主题切换。</li>\n</ol>\n<blockquote>\n<p>[!NOTE]</p>\n<p>**注意：**mdmdt.css 文件中包含了亮色和暗色两者主题，会跟随系统模式自动切换亮暗主题。</p>\n</blockquote>\n<h5 id=\"使用单独的亮色-暗色主题\">使用单独的亮色/暗色主题</h5>\n<p>如果只想使用单独的亮色或暗色主题，方法如下：</p>\n<ol>\n<li>打开 <code>偏好设置</code> -&gt; <code>外观</code> -&gt; <code>打开主题文件夹</code></li>\n<li>复制 <code>mdmdt-light.css</code> 或者 <code>mdmdt-dark.css</code> 到 <code>主题文件夹下</code></li>\n<li>重新打开Typora，在 <code>菜单栏</code> -&gt; <code>主题</code> 选择 <strong>Mdmdt Ligh</strong> 或者 <strong>mdmdt Dark</strong> 主题，完成主题切换。</li>\n</ol>\n<h1>修改字体</h1>\n<p>如果您对字体不满意，可以参照如下方法修改相应的字体：</p>\n<ol>\n<li>修改正文字体，找到：<code>font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, &quot;Helvetica Neue&quot;, Helvetica, sans-serif;</code> 在 “font-family:” 后第一个位置添加你想使用的字体，如：<code>font-family: &quot;想使用的字体名称&quot;, &quot;PingFang SC&quot;, ..., sans-serif;</code>；Windows环境下修改正文字体，找到：<code>body.os-windows&#123;...&#125;</code>，按照前面方式修改。</li>\n<li>修改代码字体，找到：<code>--monospace: &quot;JetBrains Mono&quot;, &quot;Source Code Pro&quot;, &quot;Fira Code&quot;, Consolas, Inconsolata, &quot;Cascadia Code&quot;, Monaco, &quot;Ubuntu Mono&quot;, monospace;</code>， 然后在其第一个位置添加你想使用的字体，如：<code>--monospace: &quot;想使用的字体名称&quot;, &quot;JetBrains Mono&quot;, ..., monospace;</code></li>\n</ol>\n<p><strong>注意：更换字体的前提是你电脑上要安装有相应的字体，否则修改无效</strong>。如果您不了解 CSS 的 “font-family” 属性，可以参考这里：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family</a></p>\n<h1>导出html</h1>\n<p>想要导出 html 文件可以直接选择当前主题导出 html</p>\n<p><strong>如果想要导出的 html 文件能自定义更多样式，可以使用 Mdtht 插件：</strong></p>\n<p>插件主页地址：<a href=\"https://github.com/cayxc/Mdtht\">Mdtht-Gitub地址</a>   <a href=\"https://gitee.com/cayxc/mdtht\">Mdtht-Gitee地址</a></p>\n<p>该插件提供了如下丰富功能：</p>\n<ol>\n<li>跟随系统自动切换亮色/暗色模式。</li>\n<li>手动切换亮色/暗色模式。</li>\n<li>自动生成目录编号和正文区标题索引。</li>\n<li>可选择将第一个标题转换为文章标题，并将标题居中。</li>\n<li>根据正文中标题的位置自动纠正目录层级。</li>\n<li>显示/隐藏目录索引编号。</li>\n<li>3种目录按钮样式切换。</li>\n<li>根据当前阅读区位置自动追踪到所在目录和上层目录。</li>\n<li>一键展开收起子目录。</li>\n<li>一键展开收起侧边栏。</li>\n<li>目录搜索。</li>\n<li>代码高亮。</li>\n<li>文字阴影模式。</li>\n</ol>\n<p><strong>mdtht.js</strong> 插件具体详情请参考插件主页。</p>\n<p><strong>mdtht.js导出为 html 效果图（亮色）</strong></p>\n<hr>\n<p><img src=\"./img/mdtht-light.png\" alt=\"mdmdt-light\" style=\"zoom:50%;\" /> <strong>mdtht.js导出为 html 效果图（暗色）</strong></p>\n<hr>\n<img src=\"./img/mdtht-dark.png\" alt=\"mdmdt-dark\" style=\"zoom:50%;\" />\n<hr>\n<p>🐳 如果您喜欢该文档样式风格，还请给一个 star 😄，使用过程中有什么问题请及时提交 issues，看到后我会第一时间处理。</p>\n","excerpt":"","more":"<p><img src=\"/./img/mdmdt.png\" alt=\"typora-mdmdt-theme\"></p>\n<h1>关于Mdmdt主题</h1>\n<p><img src=\"https://img.shields.io/badge/languages-CSS-F34B7D.svg\" alt=\"Languages\"> <img src=\"https://img.shields.io/github/v/release/cayxc/Mdmdt?include_prereleases&amp;color=blue&amp;logo=hack-the-box\" alt=\"GitHub release (latest by date including pre-releases)\"> <img src=\"https://img.shields.io/github/license/cayxc/Mdmdt.svg\" alt=\"GitHub license\"> <img src=\"https://gitee.com/cayxc/mdmdt/badge/star.svg\" alt=\"gitee stars\"> <img src=\"https://gitee.com/cayxc/mdmdt/badge/fork.svg\" alt=\"gitee forks\"></p>\n<h4 id=\"English-Document\"><a href=\"./readme.en.md\">English Document</a></h4>\n<p><strong>Mdmdt</strong> 是 markdown minimalism document theme 的缩写，意为：<strong>Markdown极简文档主题</strong>。<br>\n<strong>Mdmdt</strong> 是深度定制的个性化Typora主题，其目的是打造一个 <strong>清爽极简</strong> 的文档样式。<strong>Mdmdt</strong> 主题现已收录至 <a href=\"https://theme.typoraio.cn/\">Typora官方主题库https://theme.typoraio.cn</a>.</p>\n<p>相比于默认主题风格主要修改了以下几个方面：</p>\n<ol>\n<li>简洁舒适的配色风格</li>\n<li>修改标题样式</li>\n<li>修改表格样式</li>\n<li>修改引用框样式</li>\n<li>为图片添加圆角样式</li>\n<li>代码添加高亮样式</li>\n<li>修改文件树、大纲和文档列表样式</li>\n<li>自动跟随系统的亮色/暗色主题模式（可单独设置亮/暗主题)</li>\n<li>修改其他UI样式</li>\n</ol>\n<blockquote>\n<p>[!IMPORTANT]</p>\n<p>**注意：**该主题只在 Windows 和 MacOS 环境下测试过，Linux环境下未做测试，使用时还请注意！</p>\n</blockquote>\n<h1>预览</h1>\n<p><img src=\"/./img/mdmdt-text.png\" alt=\"mdmdt-text\"><br>\n<img src=\"/./img/mdmdt-source.png\" alt=\"mdmdt-source\"><br>\n<img src=\"/./img/mdmdt-code.png\" alt=\"mdmdt-code\"><br>\n<img src=\"/./img/mdmdt-list.png\" alt=\"mdmdt-list\"><br>\n<img src=\"/./img/mdmdt-math.png\" alt=\"mdmdt-math\"><br>\n<img src=\"/./img/mdmdt-blockquote.png\" alt=\"mdmdt-blockquote\"><br>\n<img src=\"/./img/mdmdt-mermaid.png\" alt=\"mdmdt-mermaid\"><br>\n<img src=\"/./img/mdmdt-title.png\" alt=\"mdmdt-title\"></p>\n<hr>\n<p><img src=\"/./img/mdmdt-ui-1.png\" alt=\"mdmdt-ui-1\"><br>\n<img src=\"/./img/mdmdt-ui-2.png\" alt=\"mdmdt-ui-2\"><br>\n<img src=\"/./img/mdmdt-ui-3.png\" alt=\"mdmdt-ui-3\"><br>\n<img src=\"/./img/mdmdt-ui-4.png\" alt=\"mdmdt-ui-4\"></p>\n<h1>个性化图文布局</h1>\n<p>本主题提供了一些个性化图文布局方案，具体使用方法请参考 “<strong><a href=\"http://xn--Mdmdtdemo-up6nt400a0pzash9f.md\">Mdmdt主题演示demo.md</a></strong>” 中的“<u>个性化图文布局</u>”章节相关内容。</p>\n<p><strong>个性化图文布局预览:</strong></p>\n<p><img src=\"/./img/mdmdt-layout.png\" alt=\"性化图文排列\"></p>\n<h1>如何使用</h1>\n<p>使用自定义主题非常简单，方法如下：</p>\n<ol>\n<li>打开 <code>偏好设置</code> -&gt; <code>外观</code> -&gt; <code>打开主题文件夹</code></li>\n<li>将下载好的 <code>mdmdt.css文件</code> 复制到主题文件夹下</li>\n<li><strong>退出 Typora 重新打开</strong>，在 <code>菜单栏</code> -&gt; <code>主题</code> 选择 <strong>Mdmdt</strong> 主题，完成主题切换。</li>\n</ol>\n<blockquote>\n<p>[!NOTE]</p>\n<p>**注意：**mdmdt.css 文件中包含了亮色和暗色两者主题，会跟随系统模式自动切换亮暗主题。</p>\n</blockquote>\n<h5 id=\"使用单独的亮色-暗色主题\">使用单独的亮色/暗色主题</h5>\n<p>如果只想使用单独的亮色或暗色主题，方法如下：</p>\n<ol>\n<li>打开 <code>偏好设置</code> -&gt; <code>外观</code> -&gt; <code>打开主题文件夹</code></li>\n<li>复制 <code>mdmdt-light.css</code> 或者 <code>mdmdt-dark.css</code> 到 <code>主题文件夹下</code></li>\n<li>重新打开Typora，在 <code>菜单栏</code> -&gt; <code>主题</code> 选择 <strong>Mdmdt Ligh</strong> 或者 <strong>mdmdt Dark</strong> 主题，完成主题切换。</li>\n</ol>\n<h1>修改字体</h1>\n<p>如果您对字体不满意，可以参照如下方法修改相应的字体：</p>\n<ol>\n<li>修改正文字体，找到：<code>font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, &quot;Helvetica Neue&quot;, Helvetica, sans-serif;</code> 在 “font-family:” 后第一个位置添加你想使用的字体，如：<code>font-family: &quot;想使用的字体名称&quot;, &quot;PingFang SC&quot;, ..., sans-serif;</code>；Windows环境下修改正文字体，找到：<code>body.os-windows&#123;...&#125;</code>，按照前面方式修改。</li>\n<li>修改代码字体，找到：<code>--monospace: &quot;JetBrains Mono&quot;, &quot;Source Code Pro&quot;, &quot;Fira Code&quot;, Consolas, Inconsolata, &quot;Cascadia Code&quot;, Monaco, &quot;Ubuntu Mono&quot;, monospace;</code>， 然后在其第一个位置添加你想使用的字体，如：<code>--monospace: &quot;想使用的字体名称&quot;, &quot;JetBrains Mono&quot;, ..., monospace;</code></li>\n</ol>\n<p><strong>注意：更换字体的前提是你电脑上要安装有相应的字体，否则修改无效</strong>。如果您不了解 CSS 的 “font-family” 属性，可以参考这里：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family</a></p>\n<h1>导出html</h1>\n<p>想要导出 html 文件可以直接选择当前主题导出 html</p>\n<p><strong>如果想要导出的 html 文件能自定义更多样式，可以使用 Mdtht 插件：</strong></p>\n<p>插件主页地址：<a href=\"https://github.com/cayxc/Mdtht\">Mdtht-Gitub地址</a>   <a href=\"https://gitee.com/cayxc/mdtht\">Mdtht-Gitee地址</a></p>\n<p>该插件提供了如下丰富功能：</p>\n<ol>\n<li>跟随系统自动切换亮色/暗色模式。</li>\n<li>手动切换亮色/暗色模式。</li>\n<li>自动生成目录编号和正文区标题索引。</li>\n<li>可选择将第一个标题转换为文章标题，并将标题居中。</li>\n<li>根据正文中标题的位置自动纠正目录层级。</li>\n<li>显示/隐藏目录索引编号。</li>\n<li>3种目录按钮样式切换。</li>\n<li>根据当前阅读区位置自动追踪到所在目录和上层目录。</li>\n<li>一键展开收起子目录。</li>\n<li>一键展开收起侧边栏。</li>\n<li>目录搜索。</li>\n<li>代码高亮。</li>\n<li>文字阴影模式。</li>\n</ol>\n<p><strong>mdtht.js</strong> 插件具体详情请参考插件主页。</p>\n<p><strong>mdtht.js导出为 html 效果图（亮色）</strong></p>\n<hr>\n<p><img src=\"./img/mdtht-light.png\" alt=\"mdmdt-light\" style=\"zoom:50%;\" /> <strong>mdtht.js导出为 html 效果图（暗色）</strong></p>\n<hr>\n<img src=\"./img/mdtht-dark.png\" alt=\"mdmdt-dark\" style=\"zoom:50%;\" />\n<hr>\n<p>🐳 如果您喜欢该文档样式风格，还请给一个 star 😄，使用过程中有什么问题请及时提交 issues，看到后我会第一时间处理。</p>\n"},{"title":"C++ string分割","date":"2025-07-05T16:00:00.000Z","_content":"\n### string分割\n\n#### 方法一：使用`find()`和`substr()`.\n\n##### 用字符分割字符串：\n\n```cpp\n// 使用字符分割\nvoid Stringsplit(const string& str, const char split, vector<string>& res)\n{\n    if (str == \"\"){\n        return\n    };\n    //在字符串末尾也加入分隔符，方便截取最后一段\n    string strs = str + split;\n    size_t pos = strs.find(split);\n    \n    // 若找不到内容则字符串搜索函数返回 npos\n    while (pos != strs.npos)\n    {\n        string temp = strs.substr(0, pos);\n        res.push_back(temp);\n        //去掉已分割的字符串,在剩下的字符串中进行分割\n        strs = strs.substr(pos + 1, strs.size());\n        pos = strs.find(split);\n    }\n}\n```\n\n##### 用字符串分割字符串\n\n> 整个字符串`splits`作为分隔符。\n\n```cpp\n// 使用字符串分割\nvoid Stringsplit(const string& str, const string& splits, vector<string>& res)\n{\n\tif (str == \"\")\t\treturn;\n\t//在字符串末尾也加入分隔符，方便截取最后一段\n\tstring strs = str + splits;\n\tsize_t pos = strs.find(splits);\n\tint step = splits.size();\n\n\t// 若找不到内容则字符串搜索函数返回 npos\n\twhile (pos != strs.npos)\n\t{\n\t\tstring temp = strs.substr(0, pos);\n\t\tres.push_back(temp);\n\t\t//去掉已分割的字符串,在剩下的字符串中进行分割\n\t\tstrs = strs.substr(pos + step, strs.size());\n\t\tpos = strs.find(splits);\n\t}\n}\n```\n\n#### 方法二：使用`istringstream`.\n\n","source":"_posts/程序/string分割.md","raw":"---\ntitle: C++ string分割\ndate: 2025-07-06\ncategories: 实用代码段\ntags: [C++, string, 实用代码]\n---\n\n### string分割\n\n#### 方法一：使用`find()`和`substr()`.\n\n##### 用字符分割字符串：\n\n```cpp\n// 使用字符分割\nvoid Stringsplit(const string& str, const char split, vector<string>& res)\n{\n    if (str == \"\"){\n        return\n    };\n    //在字符串末尾也加入分隔符，方便截取最后一段\n    string strs = str + split;\n    size_t pos = strs.find(split);\n    \n    // 若找不到内容则字符串搜索函数返回 npos\n    while (pos != strs.npos)\n    {\n        string temp = strs.substr(0, pos);\n        res.push_back(temp);\n        //去掉已分割的字符串,在剩下的字符串中进行分割\n        strs = strs.substr(pos + 1, strs.size());\n        pos = strs.find(split);\n    }\n}\n```\n\n##### 用字符串分割字符串\n\n> 整个字符串`splits`作为分隔符。\n\n```cpp\n// 使用字符串分割\nvoid Stringsplit(const string& str, const string& splits, vector<string>& res)\n{\n\tif (str == \"\")\t\treturn;\n\t//在字符串末尾也加入分隔符，方便截取最后一段\n\tstring strs = str + splits;\n\tsize_t pos = strs.find(splits);\n\tint step = splits.size();\n\n\t// 若找不到内容则字符串搜索函数返回 npos\n\twhile (pos != strs.npos)\n\t{\n\t\tstring temp = strs.substr(0, pos);\n\t\tres.push_back(temp);\n\t\t//去掉已分割的字符串,在剩下的字符串中进行分割\n\t\tstrs = strs.substr(pos + step, strs.size());\n\t\tpos = strs.find(splits);\n\t}\n}\n```\n\n#### 方法二：使用`istringstream`.\n\n","slug":"程序/string分割","published":1,"updated":"2025-09-14T02:36:11.048Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpo000k4e4pavk08f2c","content":"<h3 id=\"string分割\">string分割</h3>\n<h4 id=\"方法一：使用find-和substr\">方法一：使用<code>find()</code>和<code>substr()</code>.</h4>\n<h5 id=\"用字符分割字符串：\">用字符分割字符串：</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用字符分割</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Stringsplit</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; str, <span class=\"type\">const</span> <span class=\"type\">char</span> split, vector&lt;string&gt;&amp; res)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str == <span class=\"string\">&quot;&quot;</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">//在字符串末尾也加入分隔符，方便截取最后一段</span></span><br><span class=\"line\">    string strs = str + split;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> pos = strs.<span class=\"built_in\">find</span>(split);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 若找不到内容则字符串搜索函数返回 npos</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (pos != strs.npos)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        string temp = strs.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, pos);</span><br><span class=\"line\">        res.<span class=\"built_in\">push_back</span>(temp);</span><br><span class=\"line\">        <span class=\"comment\">//去掉已分割的字符串,在剩下的字符串中进行分割</span></span><br><span class=\"line\">        strs = strs.<span class=\"built_in\">substr</span>(pos + <span class=\"number\">1</span>, strs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">        pos = strs.<span class=\"built_in\">find</span>(split);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"用字符串分割字符串\">用字符串分割字符串</h5>\n<blockquote>\n<p>整个字符串<code>splits</code>作为分隔符。</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用字符串分割</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Stringsplit</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; str, <span class=\"type\">const</span> string&amp; splits, vector&lt;string&gt;&amp; res)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (str == <span class=\"string\">&quot;&quot;</span>)\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//在字符串末尾也加入分隔符，方便截取最后一段</span></span><br><span class=\"line\">\tstring strs = str + splits;</span><br><span class=\"line\">\t<span class=\"type\">size_t</span> pos = strs.<span class=\"built_in\">find</span>(splits);</span><br><span class=\"line\">\t<span class=\"type\">int</span> step = splits.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 若找不到内容则字符串搜索函数返回 npos</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pos != strs.npos)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstring temp = strs.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, pos);</span><br><span class=\"line\">\t\tres.<span class=\"built_in\">push_back</span>(temp);</span><br><span class=\"line\">\t\t<span class=\"comment\">//去掉已分割的字符串,在剩下的字符串中进行分割</span></span><br><span class=\"line\">\t\tstrs = strs.<span class=\"built_in\">substr</span>(pos + step, strs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">\t\tpos = strs.<span class=\"built_in\">find</span>(splits);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二：使用istringstream\">方法二：使用<code>istringstream</code>.</h4>\n","excerpt":"","more":"<h3 id=\"string分割\">string分割</h3>\n<h4 id=\"方法一：使用find-和substr\">方法一：使用<code>find()</code>和<code>substr()</code>.</h4>\n<h5 id=\"用字符分割字符串：\">用字符分割字符串：</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用字符分割</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Stringsplit</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; str, <span class=\"type\">const</span> <span class=\"type\">char</span> split, vector&lt;string&gt;&amp; res)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str == <span class=\"string\">&quot;&quot;</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">//在字符串末尾也加入分隔符，方便截取最后一段</span></span><br><span class=\"line\">    string strs = str + split;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> pos = strs.<span class=\"built_in\">find</span>(split);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 若找不到内容则字符串搜索函数返回 npos</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (pos != strs.npos)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        string temp = strs.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, pos);</span><br><span class=\"line\">        res.<span class=\"built_in\">push_back</span>(temp);</span><br><span class=\"line\">        <span class=\"comment\">//去掉已分割的字符串,在剩下的字符串中进行分割</span></span><br><span class=\"line\">        strs = strs.<span class=\"built_in\">substr</span>(pos + <span class=\"number\">1</span>, strs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">        pos = strs.<span class=\"built_in\">find</span>(split);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"用字符串分割字符串\">用字符串分割字符串</h5>\n<blockquote>\n<p>整个字符串<code>splits</code>作为分隔符。</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用字符串分割</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Stringsplit</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; str, <span class=\"type\">const</span> string&amp; splits, vector&lt;string&gt;&amp; res)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (str == <span class=\"string\">&quot;&quot;</span>)\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//在字符串末尾也加入分隔符，方便截取最后一段</span></span><br><span class=\"line\">\tstring strs = str + splits;</span><br><span class=\"line\">\t<span class=\"type\">size_t</span> pos = strs.<span class=\"built_in\">find</span>(splits);</span><br><span class=\"line\">\t<span class=\"type\">int</span> step = splits.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 若找不到内容则字符串搜索函数返回 npos</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pos != strs.npos)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstring temp = strs.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, pos);</span><br><span class=\"line\">\t\tres.<span class=\"built_in\">push_back</span>(temp);</span><br><span class=\"line\">\t\t<span class=\"comment\">//去掉已分割的字符串,在剩下的字符串中进行分割</span></span><br><span class=\"line\">\t\tstrs = strs.<span class=\"built_in\">substr</span>(pos + step, strs.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">\t\tpos = strs.<span class=\"built_in\">find</span>(splits);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二：使用istringstream\">方法二：使用<code>istringstream</code>.</h4>\n"},{"title":"C++ 获取文件大小","date":"2025-07-05T16:00:00.000Z","_content":"\n### 获取文件大小\n\n```cpp\n#include <sys/stat.h>\n\n// 通过stat结构体 获得文件大小，单位字节\nsize_t getFileSize(const char *fileName) {\n\n    if (fileName == nullptr) {\n        return 0;\n    }\n\n    // 这是一个存储文件(夹)信息的结构体，其中有文件大小和创建时间、访问时间、修改时间等\n    struct stat statbuf;\n\n    // 提供文件名字符串，获得文件属性结构体\n    stat(fileName, &statbuf);\n\n    // 获取文件大小\n    size_t filesize = statbuf.st_size;\n\n    return filesize;\n}\n```\n\n","source":"_posts/程序/获取文件大小.md","raw":"---\ntitle: C++ 获取文件大小\ndate: 2025-07-06\ncategories: 实用代码段\ntags: [C++, 文件操作, 实用代码]\n---\n\n### 获取文件大小\n\n```cpp\n#include <sys/stat.h>\n\n// 通过stat结构体 获得文件大小，单位字节\nsize_t getFileSize(const char *fileName) {\n\n    if (fileName == nullptr) {\n        return 0;\n    }\n\n    // 这是一个存储文件(夹)信息的结构体，其中有文件大小和创建时间、访问时间、修改时间等\n    struct stat statbuf;\n\n    // 提供文件名字符串，获得文件属性结构体\n    stat(fileName, &statbuf);\n\n    // 获取文件大小\n    size_t filesize = statbuf.st_size;\n\n    return filesize;\n}\n```\n\n","slug":"程序/获取文件大小","published":1,"updated":"2025-09-14T02:36:11.049Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpp000l4e4p428gb0ok","content":"<h3 id=\"获取文件大小\">获取文件大小</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过stat结构体 获得文件大小，单位字节</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">getFileSize</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *fileName)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fileName == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这是一个存储文件(夹)信息的结构体，其中有文件大小和创建时间、访问时间、修改时间等</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">stat</span> statbuf;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 提供文件名字符串，获得文件属性结构体</span></span><br><span class=\"line\">    <span class=\"built_in\">stat</span>(fileName, &amp;statbuf);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取文件大小</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> filesize = statbuf.st_size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> filesize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"获取文件大小\">获取文件大小</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过stat结构体 获得文件大小，单位字节</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">getFileSize</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *fileName)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fileName == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这是一个存储文件(夹)信息的结构体，其中有文件大小和创建时间、访问时间、修改时间等</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">stat</span> statbuf;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 提供文件名字符串，获得文件属性结构体</span></span><br><span class=\"line\">    <span class=\"built_in\">stat</span>(fileName, &amp;statbuf);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取文件大小</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> filesize = statbuf.st_size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> filesize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"排序算法","date":"2025-07-09T16:00:00.000Z","_content":"\n## 排序算法\n\n经典的排序算法总共有十种。分别是：**冒泡、选择、插入、希尔、归并、快排、堆排、计数、桶排、基数**。他们都是**内部排序**。\n\n> 关于内部排序和外部排序：\n>\n> - 内部排序：待排序列数据记录完全存放在内存中\n> - 外部排序：排序的数据很大，一次不能容纳全部的排序记录，在排序过程中还需要访问外部存储器\n\n### 1. 冒泡排序\n\n### 2. 选择排序\n\n### 3. 插入排序\n\n### 4. 希尔排序\n\n### 5. 归并排序\n\n### 6. 快速排序\n\n\n\n### 7. 桶排序\n\n### 8. 堆排序\n\n### 9. 基数排序\n\n### 10. 计数排序\n\n","source":"_posts/算法/SortAlgorithem.md","raw":"---\ntitle: 排序算法\ndate: 2025-07-10\ntags: [算法, C++, 排序]\ncategories: 算法\n---\n\n## 排序算法\n\n经典的排序算法总共有十种。分别是：**冒泡、选择、插入、希尔、归并、快排、堆排、计数、桶排、基数**。他们都是**内部排序**。\n\n> 关于内部排序和外部排序：\n>\n> - 内部排序：待排序列数据记录完全存放在内存中\n> - 外部排序：排序的数据很大，一次不能容纳全部的排序记录，在排序过程中还需要访问外部存储器\n\n### 1. 冒泡排序\n\n### 2. 选择排序\n\n### 3. 插入排序\n\n### 4. 希尔排序\n\n### 5. 归并排序\n\n### 6. 快速排序\n\n\n\n### 7. 桶排序\n\n### 8. 堆排序\n\n### 9. 基数排序\n\n### 10. 计数排序\n\n","slug":"算法/SortAlgorithem","published":1,"updated":"2025-09-14T02:36:11.049Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpq000p4e4p0v23c3tl","content":"<h2 id=\"排序算法\">排序算法</h2>\n<p>经典的排序算法总共有十种。分别是：<strong>冒泡、选择、插入、希尔、归并、快排、堆排、计数、桶排、基数</strong>。他们都是<strong>内部排序</strong>。</p>\n<blockquote>\n<p>关于内部排序和外部排序：</p>\n<ul>\n<li>内部排序：待排序列数据记录完全存放在内存中</li>\n<li>外部排序：排序的数据很大，一次不能容纳全部的排序记录，在排序过程中还需要访问外部存储器</li>\n</ul>\n</blockquote>\n<h3 id=\"1-冒泡排序\">1. 冒泡排序</h3>\n<h3 id=\"2-选择排序\">2. 选择排序</h3>\n<h3 id=\"3-插入排序\">3. 插入排序</h3>\n<h3 id=\"4-希尔排序\">4. 希尔排序</h3>\n<h3 id=\"5-归并排序\">5. 归并排序</h3>\n<h3 id=\"6-快速排序\">6. 快速排序</h3>\n<h3 id=\"7-桶排序\">7. 桶排序</h3>\n<h3 id=\"8-堆排序\">8. 堆排序</h3>\n<h3 id=\"9-基数排序\">9. 基数排序</h3>\n<h3 id=\"10-计数排序\">10. 计数排序</h3>\n","excerpt":"","more":"<h2 id=\"排序算法\">排序算法</h2>\n<p>经典的排序算法总共有十种。分别是：<strong>冒泡、选择、插入、希尔、归并、快排、堆排、计数、桶排、基数</strong>。他们都是<strong>内部排序</strong>。</p>\n<blockquote>\n<p>关于内部排序和外部排序：</p>\n<ul>\n<li>内部排序：待排序列数据记录完全存放在内存中</li>\n<li>外部排序：排序的数据很大，一次不能容纳全部的排序记录，在排序过程中还需要访问外部存储器</li>\n</ul>\n</blockquote>\n<h3 id=\"1-冒泡排序\">1. 冒泡排序</h3>\n<h3 id=\"2-选择排序\">2. 选择排序</h3>\n<h3 id=\"3-插入排序\">3. 插入排序</h3>\n<h3 id=\"4-希尔排序\">4. 希尔排序</h3>\n<h3 id=\"5-归并排序\">5. 归并排序</h3>\n<h3 id=\"6-快速排序\">6. 快速排序</h3>\n<h3 id=\"7-桶排序\">7. 桶排序</h3>\n<h3 id=\"8-堆排序\">8. 堆排序</h3>\n<h3 id=\"9-基数排序\">9. 基数排序</h3>\n<h3 id=\"10-计数排序\">10. 计数排序</h3>\n"},{"title":"Linux的IO多路复用","date":"2025-08-09T16:00:00.000Z","_content":"\n### 基础知识\n\n- 用户空间和内核空间\n- 文件描述符\n- 缓存IO和直接IO\n- 同步和异步\n- 阻塞和非阻塞\n\n### IO多路复用\n\n#### `select`\n\n#### `poll`\n\n#### `epoll`\n","source":"_posts/网络编程/Linux的IO多路复用.md","raw":"---\ntitle: Linux的IO多路复用\ndate: 2025-08-10\ntags: [epoll, socket, Linux, IO多路复用]\ncategories: 网络编程\n---\n\n### 基础知识\n\n- 用户空间和内核空间\n- 文件描述符\n- 缓存IO和直接IO\n- 同步和异步\n- 阻塞和非阻塞\n\n### IO多路复用\n\n#### `select`\n\n#### `poll`\n\n#### `epoll`\n","slug":"网络编程/Linux的IO多路复用","published":1,"updated":"2025-09-14T02:36:11.049Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpq000q4e4pedfi4ffq","content":"<h3 id=\"基础知识\">基础知识</h3>\n<ul>\n<li>用户空间和内核空间</li>\n<li>文件描述符</li>\n<li>缓存IO和直接IO</li>\n<li>同步和异步</li>\n<li>阻塞和非阻塞</li>\n</ul>\n<h3 id=\"IO多路复用\">IO多路复用</h3>\n<h4 id=\"select\"><code>select</code></h4>\n<h4 id=\"poll\"><code>poll</code></h4>\n<h4 id=\"epoll\"><code>epoll</code></h4>\n","excerpt":"","more":"<h3 id=\"基础知识\">基础知识</h3>\n<ul>\n<li>用户空间和内核空间</li>\n<li>文件描述符</li>\n<li>缓存IO和直接IO</li>\n<li>同步和异步</li>\n<li>阻塞和非阻塞</li>\n</ul>\n<h3 id=\"IO多路复用\">IO多路复用</h3>\n<h4 id=\"select\"><code>select</code></h4>\n<h4 id=\"poll\"><code>poll</code></h4>\n<h4 id=\"epoll\"><code>epoll</code></h4>\n"},{"title":"TCP和UDP协议","date":"2025-07-05T16:00:00.000Z","_content":"\n\n### `TCP`协议\n\n\n\n### `UDP`协议","source":"_posts/网络编程/TCP协议和UDP协议.md","raw":"---\ntitle: TCP和UDP协议\ndate: 2025-07-06\ntags: [网络协议]\ncategories: 网络编程\n---\n\n\n### `TCP`协议\n\n\n\n### `UDP`协议","slug":"网络编程/TCP协议和UDP协议","published":1,"updated":"2025-09-14T02:36:11.049Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpr000s4e4p36zj460g","content":"<h3 id=\"TCP协议\"><code>TCP</code>协议</h3>\n<h3 id=\"UDP协议\"><code>UDP</code>协议</h3>\n","excerpt":"","more":"<h3 id=\"TCP协议\"><code>TCP</code>协议</h3>\n<h3 id=\"UDP协议\"><code>UDP</code>协议</h3>\n"},{"title":"epoll的LT模式和ET模式","date":"2025-08-09T16:00:00.000Z","_content":"\n### epoll\n\nepoll是Linux特有的IO复用函数，关于epoll的原理，参见：[Linux的IO多路复用](./Linux的IO多路复用)\n\n### LT模式\n\n`epoll`的默认模式，这种情况下`epoll`相当于一个效率较高的`poll`。\n\n对于采用`LT`工作模式的文件描述符，当`epoll_wait`检测到其上有事件发生并且将此事件通知给应用程序后，应用程序还可以<mark>不立即</mark>处理该事件。这样，当应用程序下一次调用`epoll_wait`时，`epoll_wait`还会再次同志应用程序，直到该事件被处理。\n\n### ET模式\n\n当往`epoll内核事件表`中注册一个文件描述符上的`EPOLLET`事件时，`epoll`将以`ET`模式来操作该文件描述符。`ET`模式是`epoll`的高效工作模式。\n\n对于采用`ET`模式的文件描述符，当`epoll_wait`检测到其上有事件发生并将此事件通知给应用程序后，应用程序必须立即处理该事件，因为后续的`epoll_wait`调用将不再向应用程序通知这一事件。\n\n可见，`ET`模式和大程度上降低了同一个`epoll`事件被重复触发的次数。\n\n### 具体实现\n\n```cpp\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <assert.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <sys/epoll.h>\n#include <pthread.h>\n#include <libgen.h>\n\n#define MAX_EVENT_NUMBER 1024\n#define BUFFER_SIZE 10\n\n/**\n * @brief 将文件描述符设置为非阻塞的\n */\nint setnonblocking(int fd) {\n    int old_option = fcntl(fd, F_GETFL); // 读取当前文件状态标志\n    int new_option = old_option | O_NONBLOCK; // 设置非阻塞\n    fcntl(fd, F_SETFL, old_option); // 写入新的文件状态标志\n    return old_option;\n}\n\n/**\n * @brief 注册EPOLLIN事件到epoll内核事件表\n * @param epollfd 内核事件表对应的文件描述符\n * @param fd 要注册EPOLLIN的文件描述符\n * @param enable_et 是否对fd启用ET模式\n */\nvoid addfd(int epollfd, int fd, bool enable_et) {\n    epoll_event event;\n    event.data.fd = fd;\n    event.events = EPOLLIN;\n    if (enable_et) {\n        event.events |= EPOLLET; // 通过按位或，增加EPOLLET属性\n    }\n    // 注意此处的event作为一个局部变量竟然传入了地址（使用epoll_ctl该参数是指针），\n    // 推测是因为传指针可以避免拷贝，速度更快\n    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &event);\n    setnonblocking(fd); // 设置文件描述符为非阻塞\n}\n\n/**\n * @brief LT模式工作流程\n * @param events 已经就绪的事件的数组\n * @param number 已就绪事件的数量\n * @param epollfd 内核事件表的文件描述符\n * @param listenfd 要处理的事件\n */\nvoid LT(epoll_event *events, int number, int epollfd, int listenfd) {\n    char buf[BUFFER_SIZE];\n    // 用循环遍历所有已经就绪的事件的列表(events)\n    for (int i = 0; i < number; ++i) {\n        int sockfd = events[i].data.fd; // 通常不用event.data的fd成员\n        if (sockfd == listenfd) { // 连接未受理。执行accept进行受理。注意此处可以用==判断相等！\n            sockaddr_in client_address;\n            socklen_t client_addrlength = sizeof(client_address);\n            // 受理连接。注意accept的后两个参数都需要取地址\n            int connfd = accept(listenfd, (struct sockaddr *)&client_address, &client_addrlength);\n            // 将受理后的连接加入内核事件表，监听后续客户端的消息\n            addfd(epollfd, connfd, false); // 对connfd禁用ET模式\n        } else if (events[i].events & EPOLLIN) { // 连接已经受理并且有数据可读（数据未被全部读出）\n            // 只要socket读缓存中还有未读出的数据，这段代码就会触发\n            printf(\"enevt trigger once\\n\");\n            memset(buf, '\\0', BUFFER_SIZE);\n            // 读出数据。注意recv的第三个参数是 BUFFERE_SIZE - 1。不是BUFFER_SIZE\n            int ret = recv(sockfd, buf, BUFFER_SIZE - 1, 0);\n            if (ret < 0) {\n                close(sockfd);\n                continue;\n            }\n            printf(\"get %d bytes of content: %s\\n\", ret, buf);\n        } else {\n            printf(\"something else happened \\n\");\n        }\n    }\n}\n\n/**\n * @brief ET模式工作流程\n * @param\n */\nvoid ET(epoll_event *events, int number, int epollfd, int listenfd) {\n    char buf[BUFFER_SIZE];\n    for (int i = 0; i < number; ++i) {\n        int sockfd = events[i].data.fd;\n        if (sockfd == listenfd) { // 未受理的连接。调用accept受理该连接\n            sockaddr_in client_address;\n            socklen_t client_addrlength = sizeof(client_address);\n            int connfd = accept(listenfd, (sockaddr *)&client_address, &client_addrlength);\n            addfd(epollfd, connfd, true); // 对connfd开启ET模式\n        } else if (events[i].events & EPOLLIN) {\n            printf(\"event trigger once\\n\");\n            /**\n             * else if 中的这段代码不会被重复触发，所以我们循环读取数据，以确保把socket读缓存中的所有数据读出\n             */\n            while (1) {\n                memset(buf, '\\0', BUFFER_SIZE);\n                // 读出数据\n                int ret = recv(sockfd, buf, BUFFER_SIZE - 1, 0);\n                if (ret < 0) {\n                    /**\n                     * 对于非阻塞IO，下面的条件成立则表示数据已经被全部读取完毕。\n                     * 此后epoll就能再次触发sockfd上的EPOLLIN事件，以驱动下一次读操作\n                     */\n                    if ((errno == EAGAIN) || (errno == EWOULDBLOCK)) {\n                        printf(\"read later\\n\");\n                        break;\n                    }\n                    close(sockfd);\n                    break;\n                } else if (ret == 0) {\n                    close(sockfd);\n                } else {\n                    printf(\"get %d bytes of content: %s\\n\", ret, buf);\n                }\n            }\n        } else {\n            printf(\"something else happened \\n\");\n        }\n    }\n}\n\nint main(int argc, char *argv[]) {\n    if (argc <= 2) {\n        // 参数不够\n        printf(\"usage: %s ip_address port_number\\n\", basename(argv[0]));\n        return 1;\n    }\n    const char *ip = argv[1];\n    int port = atoi(argv[2]);\n\n    int ret = 0;\n    sockaddr_in address;\n    memset(&address, 0, sizeof(address));\n    address.sin_family = AF_INET;\n    inet_pton(AF_INET, ip, &address.sin_addr); // 将标准文本表示形式的IPv4或IPv6地址转换为网络字节序\n    address.sin_port = htons(port); // 将主机字节序(host)的port转换为网络字节序(net)\n\n    int listenfd = socket(PF_INET, SOCK_STREAM, 0); // 创建socket\n    assert(listenfd >= 0);\n\n    // bind函数的第二个参数可以直接强转\n    ret = bind(listenfd, (struct sockaddr *)&address, sizeof(address));\n    assert(ret != -1);\n\n    ret = listen(listenfd, 5);\n    assert(ret != -1);\n\n    epoll_event events[MAX_EVENT_NUMBER];\n    int epollfd = epoll_create(5); // 创建内核事件表\n    assert(epollfd != -1); // 确保创建成功\n    addfd(epollfd, listenfd, true); // 添加socket文件描述符到内核事件表。注意此处是开启ET模式的！\n\n    while (1) {\n        // 第三个参数为-1, 则epoll_wait将永远阻塞，直到某个事件发生\n        int ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1);\n        if (ret < 0) {\n            printf(\"epoll failure\\n\");\n            break;\n        }\n\n        LT(events, ret, epollfd, listenfd); // 使用LT模式\n        // ET(events, ret, epollfd, listenfd); // 使用ET模式\n    }\n\n    close(listenfd);\n    return 0;\n}\n\n```\n\n","source":"_posts/网络编程/epoll的LT模式和ET模式.md","raw":"---\ntitle: epoll的LT模式和ET模式\ndate: 2025-08-10\ntags: [epoll, socket]\ncategories: 网络编程\n---\n\n### epoll\n\nepoll是Linux特有的IO复用函数，关于epoll的原理，参见：[Linux的IO多路复用](./Linux的IO多路复用)\n\n### LT模式\n\n`epoll`的默认模式，这种情况下`epoll`相当于一个效率较高的`poll`。\n\n对于采用`LT`工作模式的文件描述符，当`epoll_wait`检测到其上有事件发生并且将此事件通知给应用程序后，应用程序还可以<mark>不立即</mark>处理该事件。这样，当应用程序下一次调用`epoll_wait`时，`epoll_wait`还会再次同志应用程序，直到该事件被处理。\n\n### ET模式\n\n当往`epoll内核事件表`中注册一个文件描述符上的`EPOLLET`事件时，`epoll`将以`ET`模式来操作该文件描述符。`ET`模式是`epoll`的高效工作模式。\n\n对于采用`ET`模式的文件描述符，当`epoll_wait`检测到其上有事件发生并将此事件通知给应用程序后，应用程序必须立即处理该事件，因为后续的`epoll_wait`调用将不再向应用程序通知这一事件。\n\n可见，`ET`模式和大程度上降低了同一个`epoll`事件被重复触发的次数。\n\n### 具体实现\n\n```cpp\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <assert.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <sys/epoll.h>\n#include <pthread.h>\n#include <libgen.h>\n\n#define MAX_EVENT_NUMBER 1024\n#define BUFFER_SIZE 10\n\n/**\n * @brief 将文件描述符设置为非阻塞的\n */\nint setnonblocking(int fd) {\n    int old_option = fcntl(fd, F_GETFL); // 读取当前文件状态标志\n    int new_option = old_option | O_NONBLOCK; // 设置非阻塞\n    fcntl(fd, F_SETFL, old_option); // 写入新的文件状态标志\n    return old_option;\n}\n\n/**\n * @brief 注册EPOLLIN事件到epoll内核事件表\n * @param epollfd 内核事件表对应的文件描述符\n * @param fd 要注册EPOLLIN的文件描述符\n * @param enable_et 是否对fd启用ET模式\n */\nvoid addfd(int epollfd, int fd, bool enable_et) {\n    epoll_event event;\n    event.data.fd = fd;\n    event.events = EPOLLIN;\n    if (enable_et) {\n        event.events |= EPOLLET; // 通过按位或，增加EPOLLET属性\n    }\n    // 注意此处的event作为一个局部变量竟然传入了地址（使用epoll_ctl该参数是指针），\n    // 推测是因为传指针可以避免拷贝，速度更快\n    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &event);\n    setnonblocking(fd); // 设置文件描述符为非阻塞\n}\n\n/**\n * @brief LT模式工作流程\n * @param events 已经就绪的事件的数组\n * @param number 已就绪事件的数量\n * @param epollfd 内核事件表的文件描述符\n * @param listenfd 要处理的事件\n */\nvoid LT(epoll_event *events, int number, int epollfd, int listenfd) {\n    char buf[BUFFER_SIZE];\n    // 用循环遍历所有已经就绪的事件的列表(events)\n    for (int i = 0; i < number; ++i) {\n        int sockfd = events[i].data.fd; // 通常不用event.data的fd成员\n        if (sockfd == listenfd) { // 连接未受理。执行accept进行受理。注意此处可以用==判断相等！\n            sockaddr_in client_address;\n            socklen_t client_addrlength = sizeof(client_address);\n            // 受理连接。注意accept的后两个参数都需要取地址\n            int connfd = accept(listenfd, (struct sockaddr *)&client_address, &client_addrlength);\n            // 将受理后的连接加入内核事件表，监听后续客户端的消息\n            addfd(epollfd, connfd, false); // 对connfd禁用ET模式\n        } else if (events[i].events & EPOLLIN) { // 连接已经受理并且有数据可读（数据未被全部读出）\n            // 只要socket读缓存中还有未读出的数据，这段代码就会触发\n            printf(\"enevt trigger once\\n\");\n            memset(buf, '\\0', BUFFER_SIZE);\n            // 读出数据。注意recv的第三个参数是 BUFFERE_SIZE - 1。不是BUFFER_SIZE\n            int ret = recv(sockfd, buf, BUFFER_SIZE - 1, 0);\n            if (ret < 0) {\n                close(sockfd);\n                continue;\n            }\n            printf(\"get %d bytes of content: %s\\n\", ret, buf);\n        } else {\n            printf(\"something else happened \\n\");\n        }\n    }\n}\n\n/**\n * @brief ET模式工作流程\n * @param\n */\nvoid ET(epoll_event *events, int number, int epollfd, int listenfd) {\n    char buf[BUFFER_SIZE];\n    for (int i = 0; i < number; ++i) {\n        int sockfd = events[i].data.fd;\n        if (sockfd == listenfd) { // 未受理的连接。调用accept受理该连接\n            sockaddr_in client_address;\n            socklen_t client_addrlength = sizeof(client_address);\n            int connfd = accept(listenfd, (sockaddr *)&client_address, &client_addrlength);\n            addfd(epollfd, connfd, true); // 对connfd开启ET模式\n        } else if (events[i].events & EPOLLIN) {\n            printf(\"event trigger once\\n\");\n            /**\n             * else if 中的这段代码不会被重复触发，所以我们循环读取数据，以确保把socket读缓存中的所有数据读出\n             */\n            while (1) {\n                memset(buf, '\\0', BUFFER_SIZE);\n                // 读出数据\n                int ret = recv(sockfd, buf, BUFFER_SIZE - 1, 0);\n                if (ret < 0) {\n                    /**\n                     * 对于非阻塞IO，下面的条件成立则表示数据已经被全部读取完毕。\n                     * 此后epoll就能再次触发sockfd上的EPOLLIN事件，以驱动下一次读操作\n                     */\n                    if ((errno == EAGAIN) || (errno == EWOULDBLOCK)) {\n                        printf(\"read later\\n\");\n                        break;\n                    }\n                    close(sockfd);\n                    break;\n                } else if (ret == 0) {\n                    close(sockfd);\n                } else {\n                    printf(\"get %d bytes of content: %s\\n\", ret, buf);\n                }\n            }\n        } else {\n            printf(\"something else happened \\n\");\n        }\n    }\n}\n\nint main(int argc, char *argv[]) {\n    if (argc <= 2) {\n        // 参数不够\n        printf(\"usage: %s ip_address port_number\\n\", basename(argv[0]));\n        return 1;\n    }\n    const char *ip = argv[1];\n    int port = atoi(argv[2]);\n\n    int ret = 0;\n    sockaddr_in address;\n    memset(&address, 0, sizeof(address));\n    address.sin_family = AF_INET;\n    inet_pton(AF_INET, ip, &address.sin_addr); // 将标准文本表示形式的IPv4或IPv6地址转换为网络字节序\n    address.sin_port = htons(port); // 将主机字节序(host)的port转换为网络字节序(net)\n\n    int listenfd = socket(PF_INET, SOCK_STREAM, 0); // 创建socket\n    assert(listenfd >= 0);\n\n    // bind函数的第二个参数可以直接强转\n    ret = bind(listenfd, (struct sockaddr *)&address, sizeof(address));\n    assert(ret != -1);\n\n    ret = listen(listenfd, 5);\n    assert(ret != -1);\n\n    epoll_event events[MAX_EVENT_NUMBER];\n    int epollfd = epoll_create(5); // 创建内核事件表\n    assert(epollfd != -1); // 确保创建成功\n    addfd(epollfd, listenfd, true); // 添加socket文件描述符到内核事件表。注意此处是开启ET模式的！\n\n    while (1) {\n        // 第三个参数为-1, 则epoll_wait将永远阻塞，直到某个事件发生\n        int ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1);\n        if (ret < 0) {\n            printf(\"epoll failure\\n\");\n            break;\n        }\n\n        LT(events, ret, epollfd, listenfd); // 使用LT模式\n        // ET(events, ret, epollfd, listenfd); // 使用ET模式\n    }\n\n    close(listenfd);\n    return 0;\n}\n\n```\n\n","slug":"网络编程/epoll的LT模式和ET模式","published":1,"updated":"2025-09-14T02:36:11.049Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lps000v4e4pajp21yzz","content":"<h3 id=\"epoll\">epoll</h3>\n<p>epoll是Linux特有的IO复用函数，关于epoll的原理，参见：<a href=\"./Linux%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8\">Linux的IO多路复用</a></p>\n<h3 id=\"LT模式\">LT模式</h3>\n<p><code>epoll</code>的默认模式，这种情况下<code>epoll</code>相当于一个效率较高的<code>poll</code>。</p>\n<p>对于采用<code>LT</code>工作模式的文件描述符，当<code>epoll_wait</code>检测到其上有事件发生并且将此事件通知给应用程序后，应用程序还可以<mark>不立即</mark>处理该事件。这样，当应用程序下一次调用<code>epoll_wait</code>时，<code>epoll_wait</code>还会再次同志应用程序，直到该事件被处理。</p>\n<h3 id=\"ET模式\">ET模式</h3>\n<p>当往<code>epoll内核事件表</code>中注册一个文件描述符上的<code>EPOLLET</code>事件时，<code>epoll</code>将以<code>ET</code>模式来操作该文件描述符。<code>ET</code>模式是<code>epoll</code>的高效工作模式。</p>\n<p>对于采用<code>ET</code>模式的文件描述符，当<code>epoll_wait</code>检测到其上有事件发生并将此事件通知给应用程序后，应用程序必须立即处理该事件，因为后续的<code>epoll_wait</code>调用将不再向应用程序通知这一事件。</p>\n<p>可见，<code>ET</code>模式和大程度上降低了同一个<code>epoll</code>事件被重复触发的次数。</p>\n<h3 id=\"具体实现\">具体实现</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/epoll.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;libgen.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BUFFER_SIZE 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 将文件描述符设置为非阻塞的</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">setnonblocking</span><span class=\"params\">(<span class=\"type\">int</span> fd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> old_option = <span class=\"built_in\">fcntl</span>(fd, F_GETFL); <span class=\"comment\">// 读取当前文件状态标志</span></span><br><span class=\"line\">    <span class=\"type\">int</span> new_option = old_option | O_NONBLOCK; <span class=\"comment\">// 设置非阻塞</span></span><br><span class=\"line\">    <span class=\"built_in\">fcntl</span>(fd, F_SETFL, old_option); <span class=\"comment\">// 写入新的文件状态标志</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> old_option;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 注册EPOLLIN事件到epoll内核事件表</span></span><br><span class=\"line\"><span class=\"comment\"> * @param epollfd 内核事件表对应的文件描述符</span></span><br><span class=\"line\"><span class=\"comment\"> * @param fd 要注册EPOLLIN的文件描述符</span></span><br><span class=\"line\"><span class=\"comment\"> * @param enable_et 是否对fd启用ET模式</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addfd</span><span class=\"params\">(<span class=\"type\">int</span> epollfd, <span class=\"type\">int</span> fd, <span class=\"type\">bool</span> enable_et)</span> </span>&#123;</span><br><span class=\"line\">    epoll_event event;</span><br><span class=\"line\">    event.data.fd = fd;</span><br><span class=\"line\">    event.events = EPOLLIN;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (enable_et) &#123;</span><br><span class=\"line\">        event.events |= EPOLLET; <span class=\"comment\">// 通过按位或，增加EPOLLET属性</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注意此处的event作为一个局部变量竟然传入了地址（使用epoll_ctl该参数是指针），</span></span><br><span class=\"line\">    <span class=\"comment\">// 推测是因为传指针可以避免拷贝，速度更快</span></span><br><span class=\"line\">    <span class=\"built_in\">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class=\"line\">    <span class=\"built_in\">setnonblocking</span>(fd); <span class=\"comment\">// 设置文件描述符为非阻塞</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief LT模式工作流程</span></span><br><span class=\"line\"><span class=\"comment\"> * @param events 已经就绪的事件的数组</span></span><br><span class=\"line\"><span class=\"comment\"> * @param number 已就绪事件的数量</span></span><br><span class=\"line\"><span class=\"comment\"> * @param epollfd 内核事件表的文件描述符</span></span><br><span class=\"line\"><span class=\"comment\"> * @param listenfd 要处理的事件</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">LT</span><span class=\"params\">(epoll_event *events, <span class=\"type\">int</span> number, <span class=\"type\">int</span> epollfd, <span class=\"type\">int</span> listenfd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[BUFFER_SIZE];</span><br><span class=\"line\">    <span class=\"comment\">// 用循环遍历所有已经就绪的事件的列表(events)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; number; ++i) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sockfd = events[i].data.fd; <span class=\"comment\">// 通常不用event.data的fd成员</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sockfd == listenfd) &#123; <span class=\"comment\">// 连接未受理。执行accept进行受理。注意此处可以用==判断相等！</span></span><br><span class=\"line\">            sockaddr_in client_address;</span><br><span class=\"line\">            <span class=\"type\">socklen_t</span> client_addrlength = <span class=\"built_in\">sizeof</span>(client_address);</span><br><span class=\"line\">            <span class=\"comment\">// 受理连接。注意accept的后两个参数都需要取地址</span></span><br><span class=\"line\">            <span class=\"type\">int</span> connfd = <span class=\"built_in\">accept</span>(listenfd, (<span class=\"keyword\">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class=\"line\">            <span class=\"comment\">// 将受理后的连接加入内核事件表，监听后续客户端的消息</span></span><br><span class=\"line\">            <span class=\"built_in\">addfd</span>(epollfd, connfd, <span class=\"literal\">false</span>); <span class=\"comment\">// 对connfd禁用ET模式</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (events[i].events &amp; EPOLLIN) &#123; <span class=\"comment\">// 连接已经受理并且有数据可读（数据未被全部读出）</span></span><br><span class=\"line\">            <span class=\"comment\">// 只要socket读缓存中还有未读出的数据，这段代码就会触发</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;enevt trigger once\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"built_in\">memset</span>(buf, <span class=\"string\">&#x27;\\0&#x27;</span>, BUFFER_SIZE);</span><br><span class=\"line\">            <span class=\"comment\">// 读出数据。注意recv的第三个参数是 BUFFERE_SIZE - 1。不是BUFFER_SIZE</span></span><br><span class=\"line\">            <span class=\"type\">int</span> ret = <span class=\"built_in\">recv</span>(sockfd, buf, BUFFER_SIZE - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;get %d bytes of content: %s\\n&quot;</span>, ret, buf);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;something else happened \\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief ET模式工作流程</span></span><br><span class=\"line\"><span class=\"comment\"> * @param</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ET</span><span class=\"params\">(epoll_event *events, <span class=\"type\">int</span> number, <span class=\"type\">int</span> epollfd, <span class=\"type\">int</span> listenfd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[BUFFER_SIZE];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; number; ++i) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sockfd = events[i].data.fd;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sockfd == listenfd) &#123; <span class=\"comment\">// 未受理的连接。调用accept受理该连接</span></span><br><span class=\"line\">            sockaddr_in client_address;</span><br><span class=\"line\">            <span class=\"type\">socklen_t</span> client_addrlength = <span class=\"built_in\">sizeof</span>(client_address);</span><br><span class=\"line\">            <span class=\"type\">int</span> connfd = <span class=\"built_in\">accept</span>(listenfd, (sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class=\"line\">            <span class=\"built_in\">addfd</span>(epollfd, connfd, <span class=\"literal\">true</span>); <span class=\"comment\">// 对connfd开启ET模式</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;event trigger once\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * else if 中的这段代码不会被重复触发，所以我们循环读取数据，以确保把socket读缓存中的所有数据读出</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">memset</span>(buf, <span class=\"string\">&#x27;\\0&#x27;</span>, BUFFER_SIZE);</span><br><span class=\"line\">                <span class=\"comment\">// 读出数据</span></span><br><span class=\"line\">                <span class=\"type\">int</span> ret = <span class=\"built_in\">recv</span>(sockfd, buf, BUFFER_SIZE - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">                     * 对于非阻塞IO，下面的条件成立则表示数据已经被全部读取完毕。</span></span><br><span class=\"line\"><span class=\"comment\">                     * 此后epoll就能再次触发sockfd上的EPOLLIN事件，以驱动下一次读操作</span></span><br><span class=\"line\"><span class=\"comment\">                     */</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;read later\\n&quot;</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ret == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;get %d bytes of content: %s\\n&quot;</span>, ret, buf);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;something else happened \\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &lt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 参数不够</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;usage: %s ip_address port_number\\n&quot;</span>, <span class=\"built_in\">basename</span>(argv[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *ip = argv[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> port = <span class=\"built_in\">atoi</span>(argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    sockaddr_in address;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;address, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(address));</span><br><span class=\"line\">    address.sin_family = AF_INET;</span><br><span class=\"line\">    <span class=\"built_in\">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr); <span class=\"comment\">// 将标准文本表示形式的IPv4或IPv6地址转换为网络字节序</span></span><br><span class=\"line\">    address.sin_port = <span class=\"built_in\">htons</span>(port); <span class=\"comment\">// 将主机字节序(host)的port转换为网络字节序(net)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> listenfd = <span class=\"built_in\">socket</span>(PF_INET, SOCK_STREAM, <span class=\"number\">0</span>); <span class=\"comment\">// 创建socket</span></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(listenfd &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// bind函数的第二个参数可以直接强转</span></span><br><span class=\"line\">    ret = <span class=\"built_in\">bind</span>(listenfd, (<span class=\"keyword\">struct</span> sockaddr *)&amp;address, <span class=\"built_in\">sizeof</span>(address));</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(ret != <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">listen</span>(listenfd, <span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(ret != <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    epoll_event events[MAX_EVENT_NUMBER];</span><br><span class=\"line\">    <span class=\"type\">int</span> epollfd = <span class=\"built_in\">epoll_create</span>(<span class=\"number\">5</span>); <span class=\"comment\">// 创建内核事件表</span></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(epollfd != <span class=\"number\">-1</span>); <span class=\"comment\">// 确保创建成功</span></span><br><span class=\"line\">    <span class=\"built_in\">addfd</span>(epollfd, listenfd, <span class=\"literal\">true</span>); <span class=\"comment\">// 添加socket文件描述符到内核事件表。注意此处是开启ET模式的！</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第三个参数为-1, 则epoll_wait将永远阻塞，直到某个事件发生</span></span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"built_in\">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;epoll failure\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">LT</span>(events, ret, epollfd, listenfd); <span class=\"comment\">// 使用LT模式</span></span><br><span class=\"line\">        <span class=\"comment\">// ET(events, ret, epollfd, listenfd); // 使用ET模式</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">close</span>(listenfd);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"epoll\">epoll</h3>\n<p>epoll是Linux特有的IO复用函数，关于epoll的原理，参见：<a href=\"./Linux%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8\">Linux的IO多路复用</a></p>\n<h3 id=\"LT模式\">LT模式</h3>\n<p><code>epoll</code>的默认模式，这种情况下<code>epoll</code>相当于一个效率较高的<code>poll</code>。</p>\n<p>对于采用<code>LT</code>工作模式的文件描述符，当<code>epoll_wait</code>检测到其上有事件发生并且将此事件通知给应用程序后，应用程序还可以<mark>不立即</mark>处理该事件。这样，当应用程序下一次调用<code>epoll_wait</code>时，<code>epoll_wait</code>还会再次同志应用程序，直到该事件被处理。</p>\n<h3 id=\"ET模式\">ET模式</h3>\n<p>当往<code>epoll内核事件表</code>中注册一个文件描述符上的<code>EPOLLET</code>事件时，<code>epoll</code>将以<code>ET</code>模式来操作该文件描述符。<code>ET</code>模式是<code>epoll</code>的高效工作模式。</p>\n<p>对于采用<code>ET</code>模式的文件描述符，当<code>epoll_wait</code>检测到其上有事件发生并将此事件通知给应用程序后，应用程序必须立即处理该事件，因为后续的<code>epoll_wait</code>调用将不再向应用程序通知这一事件。</p>\n<p>可见，<code>ET</code>模式和大程度上降低了同一个<code>epoll</code>事件被重复触发的次数。</p>\n<h3 id=\"具体实现\">具体实现</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/epoll.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;libgen.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BUFFER_SIZE 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 将文件描述符设置为非阻塞的</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">setnonblocking</span><span class=\"params\">(<span class=\"type\">int</span> fd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> old_option = <span class=\"built_in\">fcntl</span>(fd, F_GETFL); <span class=\"comment\">// 读取当前文件状态标志</span></span><br><span class=\"line\">    <span class=\"type\">int</span> new_option = old_option | O_NONBLOCK; <span class=\"comment\">// 设置非阻塞</span></span><br><span class=\"line\">    <span class=\"built_in\">fcntl</span>(fd, F_SETFL, old_option); <span class=\"comment\">// 写入新的文件状态标志</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> old_option;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 注册EPOLLIN事件到epoll内核事件表</span></span><br><span class=\"line\"><span class=\"comment\"> * @param epollfd 内核事件表对应的文件描述符</span></span><br><span class=\"line\"><span class=\"comment\"> * @param fd 要注册EPOLLIN的文件描述符</span></span><br><span class=\"line\"><span class=\"comment\"> * @param enable_et 是否对fd启用ET模式</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addfd</span><span class=\"params\">(<span class=\"type\">int</span> epollfd, <span class=\"type\">int</span> fd, <span class=\"type\">bool</span> enable_et)</span> </span>&#123;</span><br><span class=\"line\">    epoll_event event;</span><br><span class=\"line\">    event.data.fd = fd;</span><br><span class=\"line\">    event.events = EPOLLIN;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (enable_et) &#123;</span><br><span class=\"line\">        event.events |= EPOLLET; <span class=\"comment\">// 通过按位或，增加EPOLLET属性</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注意此处的event作为一个局部变量竟然传入了地址（使用epoll_ctl该参数是指针），</span></span><br><span class=\"line\">    <span class=\"comment\">// 推测是因为传指针可以避免拷贝，速度更快</span></span><br><span class=\"line\">    <span class=\"built_in\">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class=\"line\">    <span class=\"built_in\">setnonblocking</span>(fd); <span class=\"comment\">// 设置文件描述符为非阻塞</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief LT模式工作流程</span></span><br><span class=\"line\"><span class=\"comment\"> * @param events 已经就绪的事件的数组</span></span><br><span class=\"line\"><span class=\"comment\"> * @param number 已就绪事件的数量</span></span><br><span class=\"line\"><span class=\"comment\"> * @param epollfd 内核事件表的文件描述符</span></span><br><span class=\"line\"><span class=\"comment\"> * @param listenfd 要处理的事件</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">LT</span><span class=\"params\">(epoll_event *events, <span class=\"type\">int</span> number, <span class=\"type\">int</span> epollfd, <span class=\"type\">int</span> listenfd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[BUFFER_SIZE];</span><br><span class=\"line\">    <span class=\"comment\">// 用循环遍历所有已经就绪的事件的列表(events)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; number; ++i) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sockfd = events[i].data.fd; <span class=\"comment\">// 通常不用event.data的fd成员</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sockfd == listenfd) &#123; <span class=\"comment\">// 连接未受理。执行accept进行受理。注意此处可以用==判断相等！</span></span><br><span class=\"line\">            sockaddr_in client_address;</span><br><span class=\"line\">            <span class=\"type\">socklen_t</span> client_addrlength = <span class=\"built_in\">sizeof</span>(client_address);</span><br><span class=\"line\">            <span class=\"comment\">// 受理连接。注意accept的后两个参数都需要取地址</span></span><br><span class=\"line\">            <span class=\"type\">int</span> connfd = <span class=\"built_in\">accept</span>(listenfd, (<span class=\"keyword\">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class=\"line\">            <span class=\"comment\">// 将受理后的连接加入内核事件表，监听后续客户端的消息</span></span><br><span class=\"line\">            <span class=\"built_in\">addfd</span>(epollfd, connfd, <span class=\"literal\">false</span>); <span class=\"comment\">// 对connfd禁用ET模式</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (events[i].events &amp; EPOLLIN) &#123; <span class=\"comment\">// 连接已经受理并且有数据可读（数据未被全部读出）</span></span><br><span class=\"line\">            <span class=\"comment\">// 只要socket读缓存中还有未读出的数据，这段代码就会触发</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;enevt trigger once\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"built_in\">memset</span>(buf, <span class=\"string\">&#x27;\\0&#x27;</span>, BUFFER_SIZE);</span><br><span class=\"line\">            <span class=\"comment\">// 读出数据。注意recv的第三个参数是 BUFFERE_SIZE - 1。不是BUFFER_SIZE</span></span><br><span class=\"line\">            <span class=\"type\">int</span> ret = <span class=\"built_in\">recv</span>(sockfd, buf, BUFFER_SIZE - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;get %d bytes of content: %s\\n&quot;</span>, ret, buf);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;something else happened \\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief ET模式工作流程</span></span><br><span class=\"line\"><span class=\"comment\"> * @param</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ET</span><span class=\"params\">(epoll_event *events, <span class=\"type\">int</span> number, <span class=\"type\">int</span> epollfd, <span class=\"type\">int</span> listenfd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[BUFFER_SIZE];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; number; ++i) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sockfd = events[i].data.fd;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sockfd == listenfd) &#123; <span class=\"comment\">// 未受理的连接。调用accept受理该连接</span></span><br><span class=\"line\">            sockaddr_in client_address;</span><br><span class=\"line\">            <span class=\"type\">socklen_t</span> client_addrlength = <span class=\"built_in\">sizeof</span>(client_address);</span><br><span class=\"line\">            <span class=\"type\">int</span> connfd = <span class=\"built_in\">accept</span>(listenfd, (sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class=\"line\">            <span class=\"built_in\">addfd</span>(epollfd, connfd, <span class=\"literal\">true</span>); <span class=\"comment\">// 对connfd开启ET模式</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;event trigger once\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * else if 中的这段代码不会被重复触发，所以我们循环读取数据，以确保把socket读缓存中的所有数据读出</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">memset</span>(buf, <span class=\"string\">&#x27;\\0&#x27;</span>, BUFFER_SIZE);</span><br><span class=\"line\">                <span class=\"comment\">// 读出数据</span></span><br><span class=\"line\">                <span class=\"type\">int</span> ret = <span class=\"built_in\">recv</span>(sockfd, buf, BUFFER_SIZE - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">                     * 对于非阻塞IO，下面的条件成立则表示数据已经被全部读取完毕。</span></span><br><span class=\"line\"><span class=\"comment\">                     * 此后epoll就能再次触发sockfd上的EPOLLIN事件，以驱动下一次读操作</span></span><br><span class=\"line\"><span class=\"comment\">                     */</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;read later\\n&quot;</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ret == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;get %d bytes of content: %s\\n&quot;</span>, ret, buf);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;something else happened \\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &lt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 参数不够</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;usage: %s ip_address port_number\\n&quot;</span>, <span class=\"built_in\">basename</span>(argv[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *ip = argv[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> port = <span class=\"built_in\">atoi</span>(argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    sockaddr_in address;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;address, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(address));</span><br><span class=\"line\">    address.sin_family = AF_INET;</span><br><span class=\"line\">    <span class=\"built_in\">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr); <span class=\"comment\">// 将标准文本表示形式的IPv4或IPv6地址转换为网络字节序</span></span><br><span class=\"line\">    address.sin_port = <span class=\"built_in\">htons</span>(port); <span class=\"comment\">// 将主机字节序(host)的port转换为网络字节序(net)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> listenfd = <span class=\"built_in\">socket</span>(PF_INET, SOCK_STREAM, <span class=\"number\">0</span>); <span class=\"comment\">// 创建socket</span></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(listenfd &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// bind函数的第二个参数可以直接强转</span></span><br><span class=\"line\">    ret = <span class=\"built_in\">bind</span>(listenfd, (<span class=\"keyword\">struct</span> sockaddr *)&amp;address, <span class=\"built_in\">sizeof</span>(address));</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(ret != <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">listen</span>(listenfd, <span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(ret != <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    epoll_event events[MAX_EVENT_NUMBER];</span><br><span class=\"line\">    <span class=\"type\">int</span> epollfd = <span class=\"built_in\">epoll_create</span>(<span class=\"number\">5</span>); <span class=\"comment\">// 创建内核事件表</span></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(epollfd != <span class=\"number\">-1</span>); <span class=\"comment\">// 确保创建成功</span></span><br><span class=\"line\">    <span class=\"built_in\">addfd</span>(epollfd, listenfd, <span class=\"literal\">true</span>); <span class=\"comment\">// 添加socket文件描述符到内核事件表。注意此处是开启ET模式的！</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第三个参数为-1, 则epoll_wait将永远阻塞，直到某个事件发生</span></span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"built_in\">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;epoll failure\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">LT</span>(events, ret, epollfd, listenfd); <span class=\"comment\">// 使用LT模式</span></span><br><span class=\"line\">        <span class=\"comment\">// ET(events, ret, epollfd, listenfd); // 使用ET模式</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">close</span>(listenfd);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"socket编程","date":"2025-07-05T16:00:00.000Z","_content":"\n### 基本函数和结构体\n\n1. 创建socket\n    `int socket(int domain, int type, int protocol)`\n        成功返回`0`；失败返回`-1`，同时设置错误代码`errno`。\n        单个进程能够创建`socket`连接的数量受系统参数`open files`的限制（使用`ulimit -a`查看）。因为`socket`在`Linux`中也是文件\n    - `domain`:通信协议族\n        - `PF_INET`:`ipv4`协议族\n        - `PF_INET6`:`ipv6`协议族\n        - `PF_LOCAL`:本地通信的协议族\n        - `PF_PACKET`:内核底层的协议族\n        - `PF_IPX`:`IPX Novel`协议族\n        - 其余协议族不常用\n    - `type`:数据传输的类型\n        - `SOCK_STREAM`:面向连接的`socket`，\n            - 数据不会丢失\n            - 数据顺序不会错乱\n            - 双向通道\n        - `SOCK_DGRAM`:无连接的`socket`，\n            - 传输效率更高\n            - 数据可能丢失\n            - 数据顺序可能错乱\n    - `protocal`:最终使用的协议\n        - 在`ipv4`协议族中，数据传输方式为`SOCK_STREAM`的协议只有`IPPROTO_TCP`，数据传输方式为`SOCK_DGRAM`的协议只有`IPPROTO_UDP`.\n        - 该参数也可以为0\n\n2. `TCP`和`UDP`.[[TCP协议和UDP协议]]\n\n3. 主机字节序和网络字节序\n    - 主机字节序：分为**大端序**和**小端序**。\n        每个地址内放`1Byte`（`8bit`），大端序和小端序讨论多个字节(`Byte`)的地址高低问题\n        - 大端序：<mark>低高高低</mark>.\n            ==低位==`Byte`存放在==高位==，==高位==`Byte`存放在==低位==.\n        - 小端序：<mark>低低高高</mark>.\n            ==低位==`Byte`存放在==低位==，==高位==`Byte`存放在==高位==.\n            <img src=\"image/Pasted_image_20250610210518.png\" alt=\"image\" style=\"zoom:80%;\" />\n            总结：**大端序按照原来顺序存储，小端序按字节颠倒顺序存储**。\n        - 造成的问题：同样的数据，大端序的计算机和小端序的计算机解析方式不同，那么得到的内容也不一样。在网络传输中，容易出现问题。\n    - **网络字节序（大端序）**：解决不同字节序的计算机之间传输数据的问题\n        C语言提供了四个函数用于网络字节序和主机字节序的转换：\n        - `uint16_t htons(uint16_t hostshort)`:将16位的整数从*主机字节序*转换为*网络字节序*。\n        - `uint32_t htonl(uint32_t hostlong)`:将32位的整数从*主机字节序*转换为*网络字节序*。\n        - `uint16_t stohs(uint16_t netshort)`:将16位的整数从*网络字节序*转换为*主机在字节序*。\n        - `uint32_t stohl(uint32_t netlong)`:将32位的整数从*网络字节序*转换为*主机字节序*。\n            `h: host`主机\n            `n: net`网络\n            `s: short`2字节，16位的整数\n            `l: long`4字节，32位的整数\n\n4. ` ip`地址和通讯端口`port`.\n    `ipv4`地址用4字节(`32bit`)的整数存放，`port`用2字节(`16bit`)的整数存放（0～65535）。\n    为什么不用字符串？\n        因为`192.168.190.134`用字符串存储需要15字节，而用整数存储只需要4个字节：3232284294。（**思考`ipv4`地址最大只能到`255.255.255.255`**）\n\n5. 万恶的结构体\n        因为平时用到的`ip`地址都是字符串类型的，而程序中存储的是`int`类型那么就需要将字符串类型的ip转换为int型ip。主要涉及三个结构体和一个函数\n    \n    1. `sockaddr`结构体\n        存储协议族、端口、地址信息。客户端的`connetc`函数和服务端的`bind`函数都要用到这个结构体。其定义类似下图：\n        \n        ```cpp\n        struct sockaddr{\n            unsigned short int sa_family;   // 协议族\n            unsigned char sa_data[14];  // 14字节的端口和地址\n        }\n        ```\n        \n    2. `sockaddr_in`结构体\n        上方的`sockaddr`是为了统一地址结构的表示方法，统一接口函数。但是很难用，操作不方便。所以定义了等价的`sockaddr_in`结构体，其大小与`sockaddr`相同，可以强制转换。\n        ```cpp\n        struct sockaddr_in{\n            unsigned short int sa_family;   // 协议族\n            unsigned short sin_port;  // 16bit端口号\n            struct in_addr sin_addr;  // 32bit的地址(只能存储ipv4的地址，不能存储ipv6。sockaddr中14个字节的char数组就是预留了ip地址扩展的空间)\n            unsigned char sin_zero[8];// 未使用，为了保持与sockaddr长度相同而添加。\n        }\n        struct in_addr{\n            unsigned int s_addr; // 32bit的ip地址，大端序\n        }\n        ```\n        \n    3. `gethostbyname()`函数\n        根据域名、主机名、字符串`ip`地址获取大端存储的`int32`类型`ip`.\n        ```cpp\n        struct hostent* gethostbyname(const char* name);\n        ```\n        \n    4. `hostent`结构体\n        ```cpp\n        struct hostent{\n            char* h_name; // 主机名\n            char** h_aliases; // 主机所有别名构成的的字符串数组。（同一个ip可以绑定多个域名）\n            short h_addrtype; // 主机ip地址的类型，如ipv4(AF_INET)还是ipv6\n            short h_length; // 主机ip地址长度，ipv4为4(字节),ipv6为16(字节)\n            char** h_addr_list; // 主机的ip地址，以网络字节序存储\n        }\n        ```\n        获取`hostent`后，使用以下代码把大端序的地址复制到`sockaddr_in`结构体的`sin_addr`成员中\n        ```cpp\n        sockaddr_in serveraddr;\n        struct hostent* h = gethostbyname(\"192.168.1.2\"); \n        memcpy(&serveraddr.sin_addr, h->h_addr_list, h->h_length);\n        ```\n    \n6. 字符串`ip`转大端序`ip`.\n    C语言提供了几个库函数，用于字符串`ip`和大端序`ip`的相互转换。通常用于网络通讯的服务端程序中。\n    ``` cpp\n    typedef unsigned int uint32;\n    \n    // 把字符串格式的ip转换成大端序的ip，转换后的ip应该赋值给 sockaddr_in.in_addr.s_addr。不能传入域名\n    uint_32 inet_addr(const char* cp);\n    \n    // 将字符串格式的ip转换为大端序的ip，转换后的ip直接填充到sockaddr_in.in_addr成员（不需要手动填充）。不能传入域名 \n    int inet_aton(const char* cp, struct int_addr * inp);\n    \n    // 将大端序ip转换为字符串格式的ip。用于在服务器程序中解析客户端的ip地址  \n    char* inet_ntoa(struct in_addr in);\n    ```\n\n7. `bind`函数\n    绑定服务端的`ip`和端口，失败返回-1\n\n    ```cpp\n    struct sockaddr server_addr;\n    bind(listenfd, (struct sockaddr *)&server_addr, sizeof(server_addr))\n    ```\n\n8. `lieten`函数\n    把socket设置为可连接(监听)的状态，失败返回-1\n    `listen(listenfd, 5)`\n\n### 封装socket客户端\n``` cpp\n#include <iostream>\n\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <memory.h>\n#include <netdb.h>\n\nusing namespace std;\n\nclass tcpClient {\npublic:\n    int client_sock;        // 客户端socket，-1表示未连接或者已断开。>=0表示有效的socket\n    string ip;              // 服务端的ip或域名\n    unsigned short port;    // 通讯端口\n\n    tcpClient() : client_sock(-1), port(-1) {}\n\n    ~tcpClient() {\n        if (client_sock != -1) {\n            close();\n        }\n    }\n\n    /**\n     * @param in_ip 客户端ip/域名\n     * @param in_port 端口号\n     * @return 成功返回true，失败返回false\n     */\n    bool connect_to(const string &in_ip, const unsigned short in_port) {\n        if (client_sock != -1) {\n            cout << \"ERROR: sock connect is already exist\" << endl;\n            return false;\n        }\n        // 保存服务端ip和端口号\n        ip = in_ip;\n        port = in_port;\n\n        // 创建客户端Socket\n        client_sock = socket(AF_INET, SOCK_STREAM, 0);\n        if (client_sock == -1) {\n            cout << \"创建Socket失败\" << endl;\n            return false;\n        }\n\n        // 配置服务器地址\n        sockaddr_in server_addr{};\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        // server_addr.sin_addr.s_addr = inet_addr(in_ip.c_str());      // 该方法只能用ip，不能用域名\n\n        struct hostent *h;          // 用于存放服务端的大端序ip的结构体的指针\n        if ((h = gethostbyname(ip.c_str())) == nullptr)      // 把域名、主机名、字符串格式的ip转换为结构体，存储在h中\n        {\n            ::close(client_sock);     // 关闭sock连接\n            client_sock = -1;\n            return false;\n        }\n\n        memcpy(&server_addr.sin_addr, h->h_addr, h->h_length);\n\n        // 连接服务器\n        if (connect(client_sock, (sockaddr *) &server_addr, sizeof(server_addr)) == -1) {\n            cout << \"连接服务器失败\" << endl;\n            ::close(client_sock);\n            return false;\n        }\n\n        return true;\n    }\n\n    bool send(const string &msg) const {\n        // 参数使用string，不使用const char*，因为const char*\n        if (client_sock == -1) {\n            cout << \"ERROR: not connected\" << endl;\n            return false;\n        }\n\n        // 或者：if (send(client_sock, msg.c_str(), msg.length(), 0))      // 语义不准确：buffer可以是string，也可以是一块内存\n        if (::send(client_sock, msg.data(), msg.size(), 0) == -1) {\n            cout << \"ERROR: send failed\" << endl;\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     *\n     * @param msg 存放接收到的内容\n     * @param maxLen 接收的最大长度\n     * @return\n     */\n    bool receive(string &msg, const size_t maxLen) const {\n        if (client_sock == -1) {\n            cout << \"ERROR: not connected\" << endl;\n            return false;\n        }\n\n        msg.clear();        // 清空容器\n        msg.resize(maxLen);     // 设置容器大小\n        /*\n         * 如果直接操作string对象的内存，需要保证两点：\n         *      1. 不能越界\n         *      2. 操作后需要手动设置string的大小（resize函数）。(因为直接操作string对象的内存后，string对象自动管理内存的功能就会失效)\n         *\n         * 传地址除了使用msg[0]，还可以使用msg.c_str()，msg.data()。\n         * 但是后两种获取到的都是const类型，无法修改，而recv函数需要将收到的数据写入msg中\n         */\n        int read_byte_number = ::recv(client_sock, &msg[0], msg.size(), 0); // 返回接收数据的大小，-1表示失败，0表示sock已断开\n        if (read_byte_number <= 0) {\n            cout << \"ERROR: receive failed\" << endl;\n            msg.clear();\n            return false;\n        }\n        msg.resize(read_byte_number);\n\n        return true;\n    }\n\n    bool close() {\n        if (client_sock == -1) {\n            cout << \"ERROR: not connected\" << endl;\n        }\n        ::close(client_sock);\n\n        client_sock = -1;\n        return true;\n    }\n};\n\nint main() {\n    cout << \"------------------- client start -------------------\" << endl;\n    tcpClient tcp_client;\n    string ip = \"127.0.0.1\";\n    string port = \"5005\";\n    if (!tcp_client.connect_to(ip, atoi(port.c_str()))) {\n        perror((\"connect to \" + ip + \":\" + port + \" failed\").c_str());\n        return -1;\n    }\n    char msg[1024];\n\n    for (int i = 0; i < 10; ++i) {\n        int iret;\n        memset(msg, 0, sizeof(msg));\n        sprintf(msg, \"test message %d\", i + 1);\n\n        // 向服务端发送请求报文\n        if (!tcp_client.send(msg)) {\n            char errormsg[32];\n            sprintf(errormsg, \"message %d send failed\", i + 1);\n            perror(errormsg);\n        }\n        cout << \"send: \" << msg << endl;\n\n        string received_message;\n        if (!tcp_client.receive(received_message, 1024)) {\n            perror(\"received failed\");\n        }\n        cout << \"received: \" << received_message << endl;\n        sleep(1);\n    }\n\n    return 0;\n}\n```\n### 封装socket服务端\n\n#### 单进程单线程服务端\n\n```cpp\n#include <iostream>\n\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <memory.h>\n\nusing namespace std;\n\nclass tcpServer {\npublic:\n    int listen_sock;            // 用于监听的socket。-1表示未初始化\n    int client_sock;            // 客户端连上的的socket，用于和客户端通信。-1表示客户端未连接。\n    string client_ip;           // 客户端的ip\n    unsigned short port;        // 服务端用于通讯的端口\n\n    tcpServer() : listen_sock(-1), client_sock(-1) {}\n\n    ~tcpServer() {\n        if (listen_sock == -1) {\n            closeListen();\n        }\n        if (client_sock == -1) {\n            closeClient();\n        }\n    }\n\n    bool initServer(const unsigned short &in_port) {\n        // 初始化服务端用于监听的socket\n        if ((listen_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n            cout << \"ERROR socket init failed\" << endl;\n            return false;\n        }\n\n        port = in_port;\n\n        // 将服务端用于通信的ip和端口绑定到socket上\n        struct sockaddr_in server_addr;\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;                       // 协议\n        server_addr.sin_port = htons(port);                     // 指定服务端的通信端口\n        server_addr.sin_addr.s_addr = htonl(INADDR_ANY);        // 如果操作系统有多个ip，则多个ip都可以用于通信\n\n        // 为socket绑定ip和端口\n        if (bind(listen_sock, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {\n            cout << \"ERROR socket bind failed\" << endl;\n            close(listen_sock);\n            listen_sock = -1;\n            return false;\n        }\n\n        if (listen(listen_sock, 5)) {\n            cout << \"ERROR listening start failed\" << endl;\n            return false;\n        }\n        return true;\n    }\n\n    bool accept() {\n        struct sockaddr_in client_addr;             // 客户端的地址信息\n        socklen_t addrlen = sizeof(client_addr);    // struct sockaddr_in的大小\n        // 注意accept函数的第三个参数是指针：因为accept函数需要将实际接收到的消息长度写回addrlen\n        if ((client_sock = ::accept(listen_sock, (struct sockaddr *) &client_addr, &addrlen)) == -1) {\n            perror(\"accept failed\");\n            return false;\n        }\n\n        client_ip = inet_ntoa(client_addr.sin_addr);          // 将客户端的代码从大端序转换为字符串\n\n        return true;\n    }\n\n    bool send(const string &msg) {\n        if (client_sock == -1) {\n            perror(\"socket no connected\");\n            return false;\n        }\n\n        if ((::send(client_sock, msg.data(), msg.size(), 0) <= 0)) {\n            perror(\"send message failed\");\n            return false;\n        }\n\n        return true;\n    }\n\n    bool recv(string &msg, const size_t maxLen) {\n        msg.clear();\n        msg.resize(maxLen);\n        int read_byte_number = ::recv(client_sock, &msg[0], msg.size(), 0);\n        if (read_byte_number <= 0) {\n            msg.clear();\n            perror(\"receive failed\");\n            return false;\n        }\n        msg.resize(read_byte_number);\n        return true;\n    }\n\n    bool closeListen() {\n        if (listen_sock == -1) {\n            perror(\"not listening\");\n            return false;\n        }\n        close(listen_sock);\n        listen_sock = -1;\n        return true;\n    }\n\n    bool closeClient() {\n        if (client_sock == -1) {\n            perror(\"not listening\");\n            return false;\n        }\n        close(client_sock);\n        client_sock = -1;\n        return true;\n    }\n\n    // 获取string格式的ip地址\n    [[nodiscard]] const string &clientip() const {\n        return client_ip;\n    }\n};\n\nint main() {\n    tcpServer tcp_server;\n    if (!tcp_server.initServer(5005)) {\n        perror(\"initsServer() failed\");\n        return -1;\n    }\n\n    if (!tcp_server.accept()) {\n        perror(\"accept failed\");\n        return -1;\n    }\n    cout << \"client connected\" << endl;\n\n    string msg;\n    while (true) {\n        // 接收客户端发来的报文，如果客户端没有发来报文，recv将阻塞等待\n        if (!tcp_server.recv(msg, 1024)) {\n            perror(\"receive failed\");\n        }\n        cout << \"received: \" << msg << endl;\n\n        msg = \"OK\";\n        // 向客户端发送报文\n        if (!tcp_server.send(msg)) {\n            perror(\"send failed\");\n        }\n        cout << \"send: \" << msg << endl;\n        sleep(1);\n    }\n\n    return 0;\n}\n```\n\n#### 多进程服务端\n\n```cpp\n#include <iostream>\n\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <memory.h>\n\n#include <csignal>\n\nusing namespace std;\n\nclass tcpServer {\npublic:\n    int listen_sock;            // 用于监听的socket。-1表示未初始化\n    int client_sock;            // 客户端连上的的socket，用于和客户端通信。-1表示客户端未连接。\n    string client_ip;           // 客户端的ip\n    unsigned short port;        // 服务端用于通讯的端口\n\n    tcpServer() : listen_sock(-1), client_sock(-1) {}\n\n    ~tcpServer() {\n        if (listen_sock == -1) {\n            closeListen();\n        }\n        if (client_sock == -1) {\n            closeClient();\n        }\n    }\n\n    bool initServer(const unsigned short &in_port) {\n        // 初始化服务端用于监听的socket\n        if ((listen_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n            cout << \"ERROR socket init failed\" << endl;\n            return false;\n        }\n\n        port = in_port;\n\n        // 将服务端用于通信的ip和端口绑定到socket上\n        struct sockaddr_in server_addr;\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;                       // 协议\n        server_addr.sin_port = htons(port);                     // 指定服务端的通信端口\n        server_addr.sin_addr.s_addr = htonl(INADDR_ANY);        // 如果操作系统有多个ip，则多个ip都可以用于通信\n\n        // 为socket绑定ip和端口\n        if (bind(listen_sock, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {\n            cout << \"ERROR socket bind failed\" << endl;\n            close(listen_sock);\n            listen_sock = -1;\n            return false;\n        }\n\n        if (listen(listen_sock, 5)) {\n            cout << \"ERROR listening start failed\" << endl;\n            return false;\n        }\n        return true;\n    }\n\n    bool accept() {\n        struct sockaddr_in client_addr;             // 客户端的地址信息\n        socklen_t addrlen = sizeof(client_addr);    // struct sockaddr_in的大小\n        // 注意accept函数的第三个参数是指针：因为accept函数需要将实际接收到的消息长度写回addrlen\n        if ((client_sock = ::accept(listen_sock, (struct sockaddr *) &client_addr, &addrlen)) == -1) {\n            perror(\"accept failed\");\n            return false;\n        }\n\n        client_ip = inet_ntoa(client_addr.sin_addr);          // 将客户端的代码从大端序转换为字符串\n\n        return true;\n    }\n\n    bool send(const string &msg) {\n        if (client_sock == -1) {\n            perror(\"socket no connected\");\n            return false;\n        }\n\n        if ((::send(client_sock, msg.data(), msg.size(), 0) <= 0)) {\n            perror(\"send message failed\");\n            return false;\n        }\n\n        return true;\n    }\n\n    bool recv(string &msg, const size_t maxLen) {\n        msg.clear();\n        msg.resize(maxLen);\n        int read_byte_number = ::recv(client_sock, &msg[0], msg.size(), 0);\n        if (read_byte_number <= 0) {\n            msg.clear();\n            perror(\"receive failed\");\n            return false;\n        }\n        msg.resize(read_byte_number);\n        return true;\n    }\n\n    bool closeListen() {\n        if (listen_sock == -1) {\n            perror(\"not listening\");\n            return false;\n        }\n        close(listen_sock);\n        listen_sock = -1;\n        return true;\n    }\n\n    bool closeClient() {\n        if (client_sock == -1) {\n            perror(\"not listening\");\n            return false;\n        }\n        close(client_sock);\n        client_sock = -1;\n        return true;\n    }\n\n    // 获取string格式的ip地址\n    [[nodiscard]] const string &clientip() const {\n        return client_ip;\n    }\n};\n\ntcpServer tcp_server;\n\nvoid fatherEXIT(int sig) {\n    // 以下代码是为了防止信号处理函数在执行过程中再次被信号中断\n    signal(SIGINT, SIG_IGN);\n    signal(SIGTERM, SIG_IGN);\n\n    cout << \"父进程退出： \" << sig << endl;\n\n    kill(0, SIGTERM);\n\n    // ---------------在这里增加释放资源的代码---------------\n    tcp_server.closeListen();\n    // --------------------------------------------------\n\n    exit(0);\n}\n\nvoid childEXIT(int sig) {\n    signal(SIGINT, SIG_IGN);\n    signal(SIGTERM, SIG_IGN);\n\n    cout << \"子进程退出： \" << sig << endl;\n\n    // ------在这里增加释放资源的代码（只释放子进程的资源）------\n    tcp_server.closeClient();       // 信号处理函数中只能访问全局对象，tcp_server必须定义为全局变量\n    // --------------------------------------------------\n\n    exit(0);\n}\n\nint main() {\n    if (!tcp_server.initServer(5005)) {\n        perror(\"initsServer() failed\");\n        return -1;\n    }\n\n    // 忽略全部信号，不希望被打扰。顺便解决僵尸进程的问题\n    for (int i = 0; i < 64; ++i) {\n        signal(i, SIG_IGN);\n    }\n    // 设置信号，在shell下可以用 'kill 进程号' 和 'Ctrl+C' 正常终止这些线程\n    // 但请不要用 'kill -9 进程号' 强行终止线程\n    signal(SIGTERM, fatherEXIT);\n    signal(SIGINT, fatherEXIT);\n\n    while (true) {\n        // 受理(监听)客户端的连接，从已连接的客户端中取出一个客户端\n        // 如果没有已连接的客户端，accept函数将阻塞等待\n        if (!tcp_server.accept()) {\n            perror(\"accept failed\");\n            return -1;\n        }\n        cout << \"client connected\" << endl;\n\n        int pid = fork();\n        // 系统资源不足\n        if (pid == -1) {\n            perror(\"fork\");\n            return -1;\n        }\n        if (pid > 0) {\n            tcp_server.closeClient();           // 多进程下，服务器父进程不需要客户端的socket，关闭\n            continue;           // 父进程返回循环开始位置，继续受理客户端连接\n        }\n\n        tcp_server.closeListen();           // 子进程不需要监听socket，关闭\n        // 子进程需要重新设置信号\n        signal(SIGTERM, childEXIT);         // 使用kill命令终止进程时，会产生SIGTERM信号，执行childEXIT函数\n        signal(SIGINT, childEXIT);          // 按下ctrl+c会触发SIGINT信号，执行childEXIT函数\n\n        // 子进程负责与客户端进行通讯\n        string msg;\n        while (true) {\n            // 接收客户端发来的报文，如果客户端没有发来报文，recv将阻塞等待\n            if (!tcp_server.recv(msg, 1024)) {\n                perror(\"receive failed\");\n            } else {\n                cout << \"received: \" << msg << \"------thread id: \" << getpid() << endl;\n            }\n\n            msg = \"OK\";\n            // 向客户端发送报文\n            if (!tcp_server.send(msg)) {\n                perror(\"send failed\");\n            } else {\n                cout << \"send: \" << msg << endl;\n            }\n\n            sleep(1);\n        }\n\n        return 0;           // 子进程通信完成后一定要退出，否则就会回到accept()函数的位置\n    }\n\n    return 0;\n}\n```\n\n#### 文件传输\n\n##### 客户端\n\n```cpp\n#include <iostream>\n#include <fstream>\n\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <memory.h>\n#include <netdb.h>\n#include <sys/stat.h>\n\nusing namespace std;\n\nclass tcpClient {\npublic:\n    int client_sock;        // 客户端socket，-1表示未连接或者已断开。>=0表示有效的socket\n    string ip;              // 服务端的ip或域名\n    unsigned short port;    // 通讯端口\n\n    tcpClient() : client_sock(-1), port(-1) {}\n\n    ~tcpClient() {\n        if (client_sock != -1) {\n            close();\n        }\n    }\n\n    /**\n     * @param in_ip 客户端ip/域名\n     * @param in_port 端口号\n     * @return 成功返回true，失败返回false\n     */\n    bool connect_to(const string &in_ip, const unsigned short in_port) {\n        if (client_sock != -1) {\n            cout << \"ERROR: sock connect is already exist\" << endl;\n            return false;\n        }\n        // 保存服务端ip和端口号\n        ip = in_ip;\n        port = in_port;\n\n        // 创建客户端Socket\n        client_sock = socket(AF_INET, SOCK_STREAM, 0);\n        if (client_sock == -1) {\n            cout << \"创建Socket失败\" << endl;\n            return false;\n        }\n\n        // 配置服务器地址\n        sockaddr_in server_addr{};\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        // server_addr.sin_addr.s_addr = inet_addr(in_ip.c_str());      // 该方法只能用ip，不能用域名\n\n        struct hostent *h;          // 用于存放服务端的大端序ip的结构体的指针\n        if ((h = gethostbyname(ip.c_str())) == nullptr)      // 把域名、主机名、字符串格式的ip转换为结构体，存储在h中\n        {\n            ::close(client_sock);     // 关闭sock连接\n            client_sock = -1;\n            return false;\n        }\n\n        memcpy(&server_addr.sin_addr, h->h_addr, h->h_length);\n\n        // 连接服务器\n        if (connect(client_sock, (sockaddr *) &server_addr, sizeof(server_addr)) == -1) {\n            cout << \"连接服务器失败\" << endl;\n            ::close(client_sock);\n            return false;\n        }\n\n        return true;\n    }\n\n    bool send(const string &msg) const {\n        // 参数使用string，不使用const char*，因为const char*\n        if (client_sock == -1) {\n            cout << \"ERROR: not connected\" << endl;\n            return false;\n        }\n\n        // 或者：if (send(client_sock, msg.c_str(), msg.length(), 0))      // 语义不准确：buffer可以是string，也可以是一块内存\n        if (::send(client_sock, msg.data(), msg.size(), 0) == -1) {\n            cout << \"ERROR: send failed\" << endl;\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * 用于传输二进制\n     * @param msg 要传输的数据（可以是结构体）\n     * @param size 数据大小\n     * @return\n     */\n    bool send(void *msg, const size_t size) {\n        // 参数使用string，不使用const char*，因为const char*\n        if (client_sock == -1) {\n            cout << \"ERROR: not connected\" << endl;\n            return false;\n        }\n\n        // 或者：if (send(client_sock, msg.c_str(), msg.length(), 0))      // 语义不准确：buffer可以是string，也可以是一块内存\n        if (::send(client_sock, msg, size, 0) == -1) {\n            cout << \"ERROR: send failed\" << endl;\n            return false;\n        }\n\n        return true;\n    }\n\n    bool sendFile(const string &filePath, const size_t fileSize) {\n        ifstream fin;\n        fin.open(filePath, ios::in | ios::binary);\n        if (!fin.is_open()) {\n            cout << \"file open failed\" << endl;\n            return false;\n        }\n\n        int onRead = 0;         // 每次调用 fin.read() 打算读取的字节数\n        int totalByte = 0;      // 从文件中已读取的总字节数\n        int bufferSize = 4096;  // 缓冲区大小，单位byte\n        char buffer[bufferSize];         // 存放读取数据的buffer。实际开发中，一般在1000～5000之间。\n\n        while (true) {\n            memset(buffer, 0, sizeof(buffer));\n            if (fileSize - totalByte > bufferSize) {\n                onRead = bufferSize;\n            } else {\n                onRead = fileSize - totalByte;\n            }\n\n            fin.read(buffer, onRead);\n            if (!send(buffer, onRead)) {\n                return false;\n            }\n            totalByte += onRead;\n\n            if (totalByte == fileSize) {\n                break;\n            }\n        }\n\n        fin.close();\n        return true;\n    }\n\n    /**\n     *\n     * @param msg 存放接收到的内容\n     * @param maxLen 接收的最大长度\n     * @return\n     */\n    bool receive(string &msg, const size_t maxLen) const {\n        if (client_sock == -1) {\n            cout << \"ERROR: not connected\" << endl;\n            return false;\n        }\n\n        msg.clear();        // 清空容器\n        msg.resize(maxLen);     // 设置容器大小\n        /*\n         * 如果直接操作string对象的内存，需要保证亮点：\n         *      1. 不能越界\n         *      2. 操作后需要手动设置string的大小（resize函数）。(因为直接操作string对象的内存后，string对象自动管理内存的功能就会失效)\n         *\n         * 传地址除了使用msg[0]，还可以使用msg.c_str()，msg.data()。\n         * 但是后两种获取到的都是const类型，无法修改，而recv函数需要将收到的数据写入msg中\n         */\n        int read_byte_number = ::recv(client_sock, &msg[0], msg.size(), 0); // 返回接收数据的大小，-1表示失败，0表示sock已断开\n        if (read_byte_number <= 0) {\n            cout << \"ERROR: receive failed\" << endl;\n            msg.clear();\n            return false;\n        }\n        msg.resize(read_byte_number);\n\n        return true;\n    }\n\n    bool close() {\n        if (client_sock == -1) {\n            cout << \"ERROR: not connected\" << endl;\n        }\n        ::close(client_sock);\n\n        client_sock = -1;\n        return true;\n    }\n};\n\n// 通过stat结构体 获得文件大小，单位字节\nsize_t getFileSize(const char *fileName) {\n\n    if (fileName == NULL) {\n        return 0;\n    }\n\n    // 这是一个存储文件(夹)信息的结构体，其中有文件大小和创建时间、访问时间、修改时间等\n    struct stat statbuf;\n\n    // 提供文件名字符串，获得文件属性结构体\n    stat(fileName, &statbuf);\n\n    // 获取文件大小\n    size_t filesize = statbuf.st_size;\n\n    return filesize;\n}\n\nint main() {\n    cout << \"------------------- client start -------------------\" << endl;\n    tcpClient tcp_client;\n    string ip = \"127.0.0.1\";\n    string port = \"5005\";\n    if (!tcp_client.connect_to(ip, atoi(port.c_str()))) {\n        perror((\"connect to \" + ip + \":\" + port + \" failed\").c_str());\n        return -1;\n    }\n\n    // 发送文件\n    // 把待传文件名和文件大小发送给服务端\n    struct fileInfo {\n        char fileName[256];     // 文件目录和文件名。与程序运行位置(工作目录)联系紧密，工作目录不同，fileName对应的路径也不同\n        int fileSize;           // 文件大小\n    } fileinfo;\n    memset(&fileinfo, 0, sizeof(fileInfo));\n    strcpy(fileinfo.fileName, \"test.txt\");\n    fileinfo.fileSize = (int) getFileSize(fileinfo.fileName);\n    if (!tcp_client.send(&fileinfo, sizeof(fileinfo))) {\n        char errormsg[32];\n        sprintf(errormsg, \"fileInfo send failed\");\n        perror(errormsg);\n        return -1;\n    } else {\n        cout << \"发送文件信息: fileName: \" << fileinfo.fileName << \"  fileSize: \" << fileinfo.fileSize << endl;\n    }\n\n    // 等待服务端的确认\n    string buffer;\n    if (!tcp_client.receive(buffer, 2)) {\n        cout << \"receive error\" << endl;\n    }\n    if (buffer != \"OK\") {\n        cout << \"receive message error\" << endl;\n    }\n\n    // 发送文件给服务端\n    if (!tcp_client.sendFile(fileinfo.fileName, fileinfo.fileSize)) {\n        cout << \"file send error\" << endl;\n        return -1;\n    }\n\n    // 等待服务端的确认\n    if (!tcp_client.receive(buffer, 2)) {\n        cout << \"no 'OK' received\" << endl;\n    }\n\n    if (buffer != \"OK\") {\n        cout << \"ERROR receive\" << endl;\n    } else {\n        cout << \"received 'OK'\" << endl;\n    }\n\n    return 0;\n}\n```\n\n##### 服务端\n\n```cpp\n#include <iostream>\n#include <fstream>\n\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <memory.h>\n\n#include <csignal>\n\nusing namespace std;\n\nclass tcpServer {\npublic:\n    int listen_sock;            // 用于监听的socket。-1表示未初始化\n    int client_sock;            // 客户端连上的的socket，用于和客户端通信。-1表示客户端未连接。\n    string client_ip;           // 客户端的ip\n    unsigned short port;        // 服务端用于通讯的端口\n\n    tcpServer() : listen_sock(-1), client_sock(-1) {}\n\n    ~tcpServer() {\n        if (listen_sock == -1) {\n            closeListen();\n        }\n        if (client_sock == -1) {\n            closeClient();\n        }\n    }\n\n    bool initServer(const unsigned short &in_port) {\n        // 初始化服务端用于监听的socket\n        if ((listen_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n            cout << \"ERROR socket init failed\" << endl;\n            return false;\n        }\n\n        port = in_port;\n\n        // 将服务端用于通信的ip和端口绑定到socket上\n        struct sockaddr_in server_addr;\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;                       // 协议\n        server_addr.sin_port = htons(port);                     // 指定服务端的通信端口\n        server_addr.sin_addr.s_addr = htonl(INADDR_ANY);        // 如果操作系统有多个ip，则多个ip都可以用于通信\n\n        // 为socket绑定ip和端口\n        if (bind(listen_sock, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {\n            cout << \"ERROR socket bind failed\" << endl;\n            close(listen_sock);\n            listen_sock = -1;\n            return false;\n        }\n\n        if (listen(listen_sock, 5)) {\n            cout << \"ERROR listening start failed\" << endl;\n            return false;\n        }\n        return true;\n    }\n\n    bool accept() {\n        struct sockaddr_in client_addr;             // 客户端的地址信息\n        socklen_t addrlen = sizeof(client_addr);    // struct sockaddr_in的大小\n        // 注意accept函数的第三个参数是指针：因为accept函数需要将实际接收到的消息长度写回addrlen\n        if ((client_sock = ::accept(listen_sock, (struct sockaddr *) &client_addr, &addrlen)) == -1) {\n            perror(\"accept failed\");\n            return false;\n        }\n\n        client_ip = inet_ntoa(client_addr.sin_addr);          // 将客户端的代码从大端序转换为字符串\n\n        return true;\n    }\n\n    bool send(const string &msg) {\n        if (client_sock == -1) {\n            perror(\"socket no connected\");\n            return false;\n        }\n\n        if ((::send(client_sock, msg.data(), msg.size(), 0) <= 0)) {\n            perror(\"send message failed\");\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * 存放接收到的字符串数据\n     * @param msg\n     * @param maxLen\n     * @return\n     */\n    bool recv(string &msg, const size_t maxLen) {\n        msg.clear();\n        msg.resize(maxLen);\n        int read_byte_number = ::recv(client_sock, &msg[0], msg.size(), 0);\n        if (read_byte_number <= 0) {\n            msg.clear();\n            perror(\"receive failed\");\n            return false;\n        }\n        msg.resize(read_byte_number);\n        return true;\n    }\n\n    /**\n     * 存放接收到的二进制数据\n     * @param msg\n     * @param maxLen\n     * @return\n     */\n    bool recv(void *msg, const size_t maxLen) const {\n        if (client_sock == -1) {\n            cout << \"ERROR: not connected\" << endl;\n            return false;\n        }\n\n        int read_byte_number = ::recv(client_sock, msg, maxLen, 0); // 返回接收数据的大小，-1表示失败，0表示sock已断开\n        if (read_byte_number <= 0) {\n            cout << \"ERROR: receive failed\" << endl;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * 接收文件\n     * @param filePath 文件路径和文件名\n     * @param fileSize 文件大小\n     * @return\n     */\n    bool receiveFile(const string &filePath, const size_t fileSize) {\n        ofstream fout;\n        fout.open(filePath, ios::binary | ios::out);\n        fout<<\"iii\"<<endl;\n        if (!fout.is_open()) {\n            cout << \"file open failed\" << endl;\n            return false;\n        }\n        int totalByte = 0;          // 已接收文件的总字节数\n        int onRead = 0;             // 本次打算接收的字节数\n        int bufferSize = 4096;  \t// 缓冲区大小，单位byte\n        char buffer[bufferSize];             // 接收文件内容的缓冲区，实际开发中，一般在1000～5000之间。\n\n        while (true) {\n            if (fileSize - totalByte > bufferSize) {\n                onRead = bufferSize;\n            } else {\n                onRead = fileSize - totalByte;\n            }\n\n            if (!recv(buffer, onRead)) {\n                return false;\n            }\n\n            fout.write(buffer, onRead);\n\n            totalByte += onRead;\n\n            if (totalByte == fileSize) {\n                fout.close();\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    bool closeListen() {\n        if (listen_sock == -1) {\n            perror(\"not listening\");\n            return false;\n        }\n        close(listen_sock);\n        listen_sock = -1;\n        return true;\n    }\n\n    bool closeClient() {\n        if (client_sock == -1) {\n            perror(\"not listening\");\n            return false;\n        }\n        close(client_sock);\n        client_sock = -1;\n        return true;\n    }\n\n    // 获取string格式的ip地址\n    [[nodiscard]] const string &clientip() const {\n        return client_ip;\n    }\n};\n\ntcpServer tcp_server;\n\nvoid fatherEXIT(int sig) {\n    // 以下代码是为了防止信号处理函数在执行过程中再次被信号中断\n    signal(SIGINT, SIG_IGN);\n    signal(SIGTERM, SIG_IGN);\n\n    cout << \"父进程退出： \" << sig << endl;\n\n    kill(0, SIGTERM);\n\n    // ---------------在这里增加释放资源的代码---------------\n    tcp_server.closeListen();\n    // --------------------------------------------------\n\n    exit(0);\n}\n\nvoid childEXIT(int sig) {\n    signal(SIGINT, SIG_IGN);\n    signal(SIGTERM, SIG_IGN);\n\n    cout << \"子进程退出： \" << sig << endl;\n\n    // ------在这里增加释放资源的代码（只释放子进程的资源）------\n    tcp_server.closeClient();       // 信号处理函数中只能访问全局对象，tcp_server必须定义为全局变量\n    // --------------------------------------------------\n\n    exit(0);\n}\n\nint main() {\n    if (!tcp_server.initServer(5005)) {\n        perror(\"initsServer() failed\");\n        return -1;\n    }\n\n    // 忽略全部信号，不希望被打扰。顺便解决僵尸进程的问题\n    for (int i = 0; i < 64; ++i) {\n        signal(i, SIG_IGN);\n    }\n    // 设置信号，在shell下可以用 'kill 进程号' 和 'Ctrl+C' 正常终止这些线程\n    // 但请不要用 'kill -9 进程号' 强行终止线程\n    signal(SIGTERM, fatherEXIT);\n    signal(SIGINT, fatherEXIT);\n\n    while (true) {\n        // 受理(监听)客户端的连接，从已连接的客户端中取出一个客户端\n        // 如果没有已连接的客户端，accept函数将阻塞等待\n        if (!tcp_server.accept()) {\n            perror(\"accept failed\");\n            return -1;\n        }\n        cout << \"client connected\" << endl;\n\n        int pid = fork();\n        // 系统资源不足\n        if (pid == -1) {\n            perror(\"fork\");\n            return -1;\n        }\n        if (pid > 0) {\n            tcp_server.closeClient();           // 多进程下，服务器父进程不需要客户端的socket，关闭\n            continue;           // 父进程返回循环开始位置，继续受理客户端连接\n        }\n\n        tcp_server.closeListen();           // 子进程不需要监听socket，关闭\n        // 子进程需要重新设置信号\n        signal(SIGTERM, childEXIT);         // 使用kill命令终止进程时，会产生SIGTERM信号，执行childEXIT函数\n        signal(SIGINT, childEXIT);          // 按下ctrl+c会触发SIGINT信号，执行childEXIT函数\n\n        // 接收文件\n        // 接收客户端发来的文件信息\n        struct fileInfo {\n            char fileName[256];     // 文件名\n            int fileSize;           // 文件大小\n        } fileinfo;\n        memset(&fileinfo, 0, sizeof(fileinfo));\n        if (!tcp_server.recv(&fileinfo, sizeof(fileinfo))) {\n            cout << \"fileInfo receive failed\" << endl;\n            return -1;\n        } else {\n            strcpy(fileinfo.fileName, \"test(1).txt\");\n            cout << \"received: fileName: \" << fileinfo.fileName << \"  fileSize: \" << fileinfo.fileSize << endl;\n        }\n\n        // 给客户端发送确认报文\n        if (!tcp_server.send(\"OK\")) {\n            cout << \"send error\" << endl;\n            break;\n        }\n\n        // 接收文件\n        if (!tcp_server.receiveFile(fileinfo.fileName, fileinfo.fileSize)) {\n            cout << \"received file error\" << endl;\n        } else {\n            cout << \"file receive success\" << endl;\n        }\n\n        // 给客户端发送确认报文\n        if (!tcp_server.send(\"OK\")) {\n            cout << \"send 'OK' failed\" << endl;\n        }\n\n        return 0;           // 子进程通信完成后一定要退出，否则就会回到accept()函数的位置\n    }\n\n    return 0;\n}\n```\n\n","source":"_posts/网络编程/socket.md","raw":"---\ntitle: socket编程\ndate: 2025-07-06\ncategories: 网络编程\ntags: [socket, C++]\n---\n\n### 基本函数和结构体\n\n1. 创建socket\n    `int socket(int domain, int type, int protocol)`\n        成功返回`0`；失败返回`-1`，同时设置错误代码`errno`。\n        单个进程能够创建`socket`连接的数量受系统参数`open files`的限制（使用`ulimit -a`查看）。因为`socket`在`Linux`中也是文件\n    - `domain`:通信协议族\n        - `PF_INET`:`ipv4`协议族\n        - `PF_INET6`:`ipv6`协议族\n        - `PF_LOCAL`:本地通信的协议族\n        - `PF_PACKET`:内核底层的协议族\n        - `PF_IPX`:`IPX Novel`协议族\n        - 其余协议族不常用\n    - `type`:数据传输的类型\n        - `SOCK_STREAM`:面向连接的`socket`，\n            - 数据不会丢失\n            - 数据顺序不会错乱\n            - 双向通道\n        - `SOCK_DGRAM`:无连接的`socket`，\n            - 传输效率更高\n            - 数据可能丢失\n            - 数据顺序可能错乱\n    - `protocal`:最终使用的协议\n        - 在`ipv4`协议族中，数据传输方式为`SOCK_STREAM`的协议只有`IPPROTO_TCP`，数据传输方式为`SOCK_DGRAM`的协议只有`IPPROTO_UDP`.\n        - 该参数也可以为0\n\n2. `TCP`和`UDP`.[[TCP协议和UDP协议]]\n\n3. 主机字节序和网络字节序\n    - 主机字节序：分为**大端序**和**小端序**。\n        每个地址内放`1Byte`（`8bit`），大端序和小端序讨论多个字节(`Byte`)的地址高低问题\n        - 大端序：<mark>低高高低</mark>.\n            ==低位==`Byte`存放在==高位==，==高位==`Byte`存放在==低位==.\n        - 小端序：<mark>低低高高</mark>.\n            ==低位==`Byte`存放在==低位==，==高位==`Byte`存放在==高位==.\n            <img src=\"image/Pasted_image_20250610210518.png\" alt=\"image\" style=\"zoom:80%;\" />\n            总结：**大端序按照原来顺序存储，小端序按字节颠倒顺序存储**。\n        - 造成的问题：同样的数据，大端序的计算机和小端序的计算机解析方式不同，那么得到的内容也不一样。在网络传输中，容易出现问题。\n    - **网络字节序（大端序）**：解决不同字节序的计算机之间传输数据的问题\n        C语言提供了四个函数用于网络字节序和主机字节序的转换：\n        - `uint16_t htons(uint16_t hostshort)`:将16位的整数从*主机字节序*转换为*网络字节序*。\n        - `uint32_t htonl(uint32_t hostlong)`:将32位的整数从*主机字节序*转换为*网络字节序*。\n        - `uint16_t stohs(uint16_t netshort)`:将16位的整数从*网络字节序*转换为*主机在字节序*。\n        - `uint32_t stohl(uint32_t netlong)`:将32位的整数从*网络字节序*转换为*主机字节序*。\n            `h: host`主机\n            `n: net`网络\n            `s: short`2字节，16位的整数\n            `l: long`4字节，32位的整数\n\n4. ` ip`地址和通讯端口`port`.\n    `ipv4`地址用4字节(`32bit`)的整数存放，`port`用2字节(`16bit`)的整数存放（0～65535）。\n    为什么不用字符串？\n        因为`192.168.190.134`用字符串存储需要15字节，而用整数存储只需要4个字节：3232284294。（**思考`ipv4`地址最大只能到`255.255.255.255`**）\n\n5. 万恶的结构体\n        因为平时用到的`ip`地址都是字符串类型的，而程序中存储的是`int`类型那么就需要将字符串类型的ip转换为int型ip。主要涉及三个结构体和一个函数\n    \n    1. `sockaddr`结构体\n        存储协议族、端口、地址信息。客户端的`connetc`函数和服务端的`bind`函数都要用到这个结构体。其定义类似下图：\n        \n        ```cpp\n        struct sockaddr{\n            unsigned short int sa_family;   // 协议族\n            unsigned char sa_data[14];  // 14字节的端口和地址\n        }\n        ```\n        \n    2. `sockaddr_in`结构体\n        上方的`sockaddr`是为了统一地址结构的表示方法，统一接口函数。但是很难用，操作不方便。所以定义了等价的`sockaddr_in`结构体，其大小与`sockaddr`相同，可以强制转换。\n        ```cpp\n        struct sockaddr_in{\n            unsigned short int sa_family;   // 协议族\n            unsigned short sin_port;  // 16bit端口号\n            struct in_addr sin_addr;  // 32bit的地址(只能存储ipv4的地址，不能存储ipv6。sockaddr中14个字节的char数组就是预留了ip地址扩展的空间)\n            unsigned char sin_zero[8];// 未使用，为了保持与sockaddr长度相同而添加。\n        }\n        struct in_addr{\n            unsigned int s_addr; // 32bit的ip地址，大端序\n        }\n        ```\n        \n    3. `gethostbyname()`函数\n        根据域名、主机名、字符串`ip`地址获取大端存储的`int32`类型`ip`.\n        ```cpp\n        struct hostent* gethostbyname(const char* name);\n        ```\n        \n    4. `hostent`结构体\n        ```cpp\n        struct hostent{\n            char* h_name; // 主机名\n            char** h_aliases; // 主机所有别名构成的的字符串数组。（同一个ip可以绑定多个域名）\n            short h_addrtype; // 主机ip地址的类型，如ipv4(AF_INET)还是ipv6\n            short h_length; // 主机ip地址长度，ipv4为4(字节),ipv6为16(字节)\n            char** h_addr_list; // 主机的ip地址，以网络字节序存储\n        }\n        ```\n        获取`hostent`后，使用以下代码把大端序的地址复制到`sockaddr_in`结构体的`sin_addr`成员中\n        ```cpp\n        sockaddr_in serveraddr;\n        struct hostent* h = gethostbyname(\"192.168.1.2\"); \n        memcpy(&serveraddr.sin_addr, h->h_addr_list, h->h_length);\n        ```\n    \n6. 字符串`ip`转大端序`ip`.\n    C语言提供了几个库函数，用于字符串`ip`和大端序`ip`的相互转换。通常用于网络通讯的服务端程序中。\n    ``` cpp\n    typedef unsigned int uint32;\n    \n    // 把字符串格式的ip转换成大端序的ip，转换后的ip应该赋值给 sockaddr_in.in_addr.s_addr。不能传入域名\n    uint_32 inet_addr(const char* cp);\n    \n    // 将字符串格式的ip转换为大端序的ip，转换后的ip直接填充到sockaddr_in.in_addr成员（不需要手动填充）。不能传入域名 \n    int inet_aton(const char* cp, struct int_addr * inp);\n    \n    // 将大端序ip转换为字符串格式的ip。用于在服务器程序中解析客户端的ip地址  \n    char* inet_ntoa(struct in_addr in);\n    ```\n\n7. `bind`函数\n    绑定服务端的`ip`和端口，失败返回-1\n\n    ```cpp\n    struct sockaddr server_addr;\n    bind(listenfd, (struct sockaddr *)&server_addr, sizeof(server_addr))\n    ```\n\n8. `lieten`函数\n    把socket设置为可连接(监听)的状态，失败返回-1\n    `listen(listenfd, 5)`\n\n### 封装socket客户端\n``` cpp\n#include <iostream>\n\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <memory.h>\n#include <netdb.h>\n\nusing namespace std;\n\nclass tcpClient {\npublic:\n    int client_sock;        // 客户端socket，-1表示未连接或者已断开。>=0表示有效的socket\n    string ip;              // 服务端的ip或域名\n    unsigned short port;    // 通讯端口\n\n    tcpClient() : client_sock(-1), port(-1) {}\n\n    ~tcpClient() {\n        if (client_sock != -1) {\n            close();\n        }\n    }\n\n    /**\n     * @param in_ip 客户端ip/域名\n     * @param in_port 端口号\n     * @return 成功返回true，失败返回false\n     */\n    bool connect_to(const string &in_ip, const unsigned short in_port) {\n        if (client_sock != -1) {\n            cout << \"ERROR: sock connect is already exist\" << endl;\n            return false;\n        }\n        // 保存服务端ip和端口号\n        ip = in_ip;\n        port = in_port;\n\n        // 创建客户端Socket\n        client_sock = socket(AF_INET, SOCK_STREAM, 0);\n        if (client_sock == -1) {\n            cout << \"创建Socket失败\" << endl;\n            return false;\n        }\n\n        // 配置服务器地址\n        sockaddr_in server_addr{};\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        // server_addr.sin_addr.s_addr = inet_addr(in_ip.c_str());      // 该方法只能用ip，不能用域名\n\n        struct hostent *h;          // 用于存放服务端的大端序ip的结构体的指针\n        if ((h = gethostbyname(ip.c_str())) == nullptr)      // 把域名、主机名、字符串格式的ip转换为结构体，存储在h中\n        {\n            ::close(client_sock);     // 关闭sock连接\n            client_sock = -1;\n            return false;\n        }\n\n        memcpy(&server_addr.sin_addr, h->h_addr, h->h_length);\n\n        // 连接服务器\n        if (connect(client_sock, (sockaddr *) &server_addr, sizeof(server_addr)) == -1) {\n            cout << \"连接服务器失败\" << endl;\n            ::close(client_sock);\n            return false;\n        }\n\n        return true;\n    }\n\n    bool send(const string &msg) const {\n        // 参数使用string，不使用const char*，因为const char*\n        if (client_sock == -1) {\n            cout << \"ERROR: not connected\" << endl;\n            return false;\n        }\n\n        // 或者：if (send(client_sock, msg.c_str(), msg.length(), 0))      // 语义不准确：buffer可以是string，也可以是一块内存\n        if (::send(client_sock, msg.data(), msg.size(), 0) == -1) {\n            cout << \"ERROR: send failed\" << endl;\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     *\n     * @param msg 存放接收到的内容\n     * @param maxLen 接收的最大长度\n     * @return\n     */\n    bool receive(string &msg, const size_t maxLen) const {\n        if (client_sock == -1) {\n            cout << \"ERROR: not connected\" << endl;\n            return false;\n        }\n\n        msg.clear();        // 清空容器\n        msg.resize(maxLen);     // 设置容器大小\n        /*\n         * 如果直接操作string对象的内存，需要保证两点：\n         *      1. 不能越界\n         *      2. 操作后需要手动设置string的大小（resize函数）。(因为直接操作string对象的内存后，string对象自动管理内存的功能就会失效)\n         *\n         * 传地址除了使用msg[0]，还可以使用msg.c_str()，msg.data()。\n         * 但是后两种获取到的都是const类型，无法修改，而recv函数需要将收到的数据写入msg中\n         */\n        int read_byte_number = ::recv(client_sock, &msg[0], msg.size(), 0); // 返回接收数据的大小，-1表示失败，0表示sock已断开\n        if (read_byte_number <= 0) {\n            cout << \"ERROR: receive failed\" << endl;\n            msg.clear();\n            return false;\n        }\n        msg.resize(read_byte_number);\n\n        return true;\n    }\n\n    bool close() {\n        if (client_sock == -1) {\n            cout << \"ERROR: not connected\" << endl;\n        }\n        ::close(client_sock);\n\n        client_sock = -1;\n        return true;\n    }\n};\n\nint main() {\n    cout << \"------------------- client start -------------------\" << endl;\n    tcpClient tcp_client;\n    string ip = \"127.0.0.1\";\n    string port = \"5005\";\n    if (!tcp_client.connect_to(ip, atoi(port.c_str()))) {\n        perror((\"connect to \" + ip + \":\" + port + \" failed\").c_str());\n        return -1;\n    }\n    char msg[1024];\n\n    for (int i = 0; i < 10; ++i) {\n        int iret;\n        memset(msg, 0, sizeof(msg));\n        sprintf(msg, \"test message %d\", i + 1);\n\n        // 向服务端发送请求报文\n        if (!tcp_client.send(msg)) {\n            char errormsg[32];\n            sprintf(errormsg, \"message %d send failed\", i + 1);\n            perror(errormsg);\n        }\n        cout << \"send: \" << msg << endl;\n\n        string received_message;\n        if (!tcp_client.receive(received_message, 1024)) {\n            perror(\"received failed\");\n        }\n        cout << \"received: \" << received_message << endl;\n        sleep(1);\n    }\n\n    return 0;\n}\n```\n### 封装socket服务端\n\n#### 单进程单线程服务端\n\n```cpp\n#include <iostream>\n\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <memory.h>\n\nusing namespace std;\n\nclass tcpServer {\npublic:\n    int listen_sock;            // 用于监听的socket。-1表示未初始化\n    int client_sock;            // 客户端连上的的socket，用于和客户端通信。-1表示客户端未连接。\n    string client_ip;           // 客户端的ip\n    unsigned short port;        // 服务端用于通讯的端口\n\n    tcpServer() : listen_sock(-1), client_sock(-1) {}\n\n    ~tcpServer() {\n        if (listen_sock == -1) {\n            closeListen();\n        }\n        if (client_sock == -1) {\n            closeClient();\n        }\n    }\n\n    bool initServer(const unsigned short &in_port) {\n        // 初始化服务端用于监听的socket\n        if ((listen_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n            cout << \"ERROR socket init failed\" << endl;\n            return false;\n        }\n\n        port = in_port;\n\n        // 将服务端用于通信的ip和端口绑定到socket上\n        struct sockaddr_in server_addr;\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;                       // 协议\n        server_addr.sin_port = htons(port);                     // 指定服务端的通信端口\n        server_addr.sin_addr.s_addr = htonl(INADDR_ANY);        // 如果操作系统有多个ip，则多个ip都可以用于通信\n\n        // 为socket绑定ip和端口\n        if (bind(listen_sock, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {\n            cout << \"ERROR socket bind failed\" << endl;\n            close(listen_sock);\n            listen_sock = -1;\n            return false;\n        }\n\n        if (listen(listen_sock, 5)) {\n            cout << \"ERROR listening start failed\" << endl;\n            return false;\n        }\n        return true;\n    }\n\n    bool accept() {\n        struct sockaddr_in client_addr;             // 客户端的地址信息\n        socklen_t addrlen = sizeof(client_addr);    // struct sockaddr_in的大小\n        // 注意accept函数的第三个参数是指针：因为accept函数需要将实际接收到的消息长度写回addrlen\n        if ((client_sock = ::accept(listen_sock, (struct sockaddr *) &client_addr, &addrlen)) == -1) {\n            perror(\"accept failed\");\n            return false;\n        }\n\n        client_ip = inet_ntoa(client_addr.sin_addr);          // 将客户端的代码从大端序转换为字符串\n\n        return true;\n    }\n\n    bool send(const string &msg) {\n        if (client_sock == -1) {\n            perror(\"socket no connected\");\n            return false;\n        }\n\n        if ((::send(client_sock, msg.data(), msg.size(), 0) <= 0)) {\n            perror(\"send message failed\");\n            return false;\n        }\n\n        return true;\n    }\n\n    bool recv(string &msg, const size_t maxLen) {\n        msg.clear();\n        msg.resize(maxLen);\n        int read_byte_number = ::recv(client_sock, &msg[0], msg.size(), 0);\n        if (read_byte_number <= 0) {\n            msg.clear();\n            perror(\"receive failed\");\n            return false;\n        }\n        msg.resize(read_byte_number);\n        return true;\n    }\n\n    bool closeListen() {\n        if (listen_sock == -1) {\n            perror(\"not listening\");\n            return false;\n        }\n        close(listen_sock);\n        listen_sock = -1;\n        return true;\n    }\n\n    bool closeClient() {\n        if (client_sock == -1) {\n            perror(\"not listening\");\n            return false;\n        }\n        close(client_sock);\n        client_sock = -1;\n        return true;\n    }\n\n    // 获取string格式的ip地址\n    [[nodiscard]] const string &clientip() const {\n        return client_ip;\n    }\n};\n\nint main() {\n    tcpServer tcp_server;\n    if (!tcp_server.initServer(5005)) {\n        perror(\"initsServer() failed\");\n        return -1;\n    }\n\n    if (!tcp_server.accept()) {\n        perror(\"accept failed\");\n        return -1;\n    }\n    cout << \"client connected\" << endl;\n\n    string msg;\n    while (true) {\n        // 接收客户端发来的报文，如果客户端没有发来报文，recv将阻塞等待\n        if (!tcp_server.recv(msg, 1024)) {\n            perror(\"receive failed\");\n        }\n        cout << \"received: \" << msg << endl;\n\n        msg = \"OK\";\n        // 向客户端发送报文\n        if (!tcp_server.send(msg)) {\n            perror(\"send failed\");\n        }\n        cout << \"send: \" << msg << endl;\n        sleep(1);\n    }\n\n    return 0;\n}\n```\n\n#### 多进程服务端\n\n```cpp\n#include <iostream>\n\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <memory.h>\n\n#include <csignal>\n\nusing namespace std;\n\nclass tcpServer {\npublic:\n    int listen_sock;            // 用于监听的socket。-1表示未初始化\n    int client_sock;            // 客户端连上的的socket，用于和客户端通信。-1表示客户端未连接。\n    string client_ip;           // 客户端的ip\n    unsigned short port;        // 服务端用于通讯的端口\n\n    tcpServer() : listen_sock(-1), client_sock(-1) {}\n\n    ~tcpServer() {\n        if (listen_sock == -1) {\n            closeListen();\n        }\n        if (client_sock == -1) {\n            closeClient();\n        }\n    }\n\n    bool initServer(const unsigned short &in_port) {\n        // 初始化服务端用于监听的socket\n        if ((listen_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n            cout << \"ERROR socket init failed\" << endl;\n            return false;\n        }\n\n        port = in_port;\n\n        // 将服务端用于通信的ip和端口绑定到socket上\n        struct sockaddr_in server_addr;\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;                       // 协议\n        server_addr.sin_port = htons(port);                     // 指定服务端的通信端口\n        server_addr.sin_addr.s_addr = htonl(INADDR_ANY);        // 如果操作系统有多个ip，则多个ip都可以用于通信\n\n        // 为socket绑定ip和端口\n        if (bind(listen_sock, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {\n            cout << \"ERROR socket bind failed\" << endl;\n            close(listen_sock);\n            listen_sock = -1;\n            return false;\n        }\n\n        if (listen(listen_sock, 5)) {\n            cout << \"ERROR listening start failed\" << endl;\n            return false;\n        }\n        return true;\n    }\n\n    bool accept() {\n        struct sockaddr_in client_addr;             // 客户端的地址信息\n        socklen_t addrlen = sizeof(client_addr);    // struct sockaddr_in的大小\n        // 注意accept函数的第三个参数是指针：因为accept函数需要将实际接收到的消息长度写回addrlen\n        if ((client_sock = ::accept(listen_sock, (struct sockaddr *) &client_addr, &addrlen)) == -1) {\n            perror(\"accept failed\");\n            return false;\n        }\n\n        client_ip = inet_ntoa(client_addr.sin_addr);          // 将客户端的代码从大端序转换为字符串\n\n        return true;\n    }\n\n    bool send(const string &msg) {\n        if (client_sock == -1) {\n            perror(\"socket no connected\");\n            return false;\n        }\n\n        if ((::send(client_sock, msg.data(), msg.size(), 0) <= 0)) {\n            perror(\"send message failed\");\n            return false;\n        }\n\n        return true;\n    }\n\n    bool recv(string &msg, const size_t maxLen) {\n        msg.clear();\n        msg.resize(maxLen);\n        int read_byte_number = ::recv(client_sock, &msg[0], msg.size(), 0);\n        if (read_byte_number <= 0) {\n            msg.clear();\n            perror(\"receive failed\");\n            return false;\n        }\n        msg.resize(read_byte_number);\n        return true;\n    }\n\n    bool closeListen() {\n        if (listen_sock == -1) {\n            perror(\"not listening\");\n            return false;\n        }\n        close(listen_sock);\n        listen_sock = -1;\n        return true;\n    }\n\n    bool closeClient() {\n        if (client_sock == -1) {\n            perror(\"not listening\");\n            return false;\n        }\n        close(client_sock);\n        client_sock = -1;\n        return true;\n    }\n\n    // 获取string格式的ip地址\n    [[nodiscard]] const string &clientip() const {\n        return client_ip;\n    }\n};\n\ntcpServer tcp_server;\n\nvoid fatherEXIT(int sig) {\n    // 以下代码是为了防止信号处理函数在执行过程中再次被信号中断\n    signal(SIGINT, SIG_IGN);\n    signal(SIGTERM, SIG_IGN);\n\n    cout << \"父进程退出： \" << sig << endl;\n\n    kill(0, SIGTERM);\n\n    // ---------------在这里增加释放资源的代码---------------\n    tcp_server.closeListen();\n    // --------------------------------------------------\n\n    exit(0);\n}\n\nvoid childEXIT(int sig) {\n    signal(SIGINT, SIG_IGN);\n    signal(SIGTERM, SIG_IGN);\n\n    cout << \"子进程退出： \" << sig << endl;\n\n    // ------在这里增加释放资源的代码（只释放子进程的资源）------\n    tcp_server.closeClient();       // 信号处理函数中只能访问全局对象，tcp_server必须定义为全局变量\n    // --------------------------------------------------\n\n    exit(0);\n}\n\nint main() {\n    if (!tcp_server.initServer(5005)) {\n        perror(\"initsServer() failed\");\n        return -1;\n    }\n\n    // 忽略全部信号，不希望被打扰。顺便解决僵尸进程的问题\n    for (int i = 0; i < 64; ++i) {\n        signal(i, SIG_IGN);\n    }\n    // 设置信号，在shell下可以用 'kill 进程号' 和 'Ctrl+C' 正常终止这些线程\n    // 但请不要用 'kill -9 进程号' 强行终止线程\n    signal(SIGTERM, fatherEXIT);\n    signal(SIGINT, fatherEXIT);\n\n    while (true) {\n        // 受理(监听)客户端的连接，从已连接的客户端中取出一个客户端\n        // 如果没有已连接的客户端，accept函数将阻塞等待\n        if (!tcp_server.accept()) {\n            perror(\"accept failed\");\n            return -1;\n        }\n        cout << \"client connected\" << endl;\n\n        int pid = fork();\n        // 系统资源不足\n        if (pid == -1) {\n            perror(\"fork\");\n            return -1;\n        }\n        if (pid > 0) {\n            tcp_server.closeClient();           // 多进程下，服务器父进程不需要客户端的socket，关闭\n            continue;           // 父进程返回循环开始位置，继续受理客户端连接\n        }\n\n        tcp_server.closeListen();           // 子进程不需要监听socket，关闭\n        // 子进程需要重新设置信号\n        signal(SIGTERM, childEXIT);         // 使用kill命令终止进程时，会产生SIGTERM信号，执行childEXIT函数\n        signal(SIGINT, childEXIT);          // 按下ctrl+c会触发SIGINT信号，执行childEXIT函数\n\n        // 子进程负责与客户端进行通讯\n        string msg;\n        while (true) {\n            // 接收客户端发来的报文，如果客户端没有发来报文，recv将阻塞等待\n            if (!tcp_server.recv(msg, 1024)) {\n                perror(\"receive failed\");\n            } else {\n                cout << \"received: \" << msg << \"------thread id: \" << getpid() << endl;\n            }\n\n            msg = \"OK\";\n            // 向客户端发送报文\n            if (!tcp_server.send(msg)) {\n                perror(\"send failed\");\n            } else {\n                cout << \"send: \" << msg << endl;\n            }\n\n            sleep(1);\n        }\n\n        return 0;           // 子进程通信完成后一定要退出，否则就会回到accept()函数的位置\n    }\n\n    return 0;\n}\n```\n\n#### 文件传输\n\n##### 客户端\n\n```cpp\n#include <iostream>\n#include <fstream>\n\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <memory.h>\n#include <netdb.h>\n#include <sys/stat.h>\n\nusing namespace std;\n\nclass tcpClient {\npublic:\n    int client_sock;        // 客户端socket，-1表示未连接或者已断开。>=0表示有效的socket\n    string ip;              // 服务端的ip或域名\n    unsigned short port;    // 通讯端口\n\n    tcpClient() : client_sock(-1), port(-1) {}\n\n    ~tcpClient() {\n        if (client_sock != -1) {\n            close();\n        }\n    }\n\n    /**\n     * @param in_ip 客户端ip/域名\n     * @param in_port 端口号\n     * @return 成功返回true，失败返回false\n     */\n    bool connect_to(const string &in_ip, const unsigned short in_port) {\n        if (client_sock != -1) {\n            cout << \"ERROR: sock connect is already exist\" << endl;\n            return false;\n        }\n        // 保存服务端ip和端口号\n        ip = in_ip;\n        port = in_port;\n\n        // 创建客户端Socket\n        client_sock = socket(AF_INET, SOCK_STREAM, 0);\n        if (client_sock == -1) {\n            cout << \"创建Socket失败\" << endl;\n            return false;\n        }\n\n        // 配置服务器地址\n        sockaddr_in server_addr{};\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        // server_addr.sin_addr.s_addr = inet_addr(in_ip.c_str());      // 该方法只能用ip，不能用域名\n\n        struct hostent *h;          // 用于存放服务端的大端序ip的结构体的指针\n        if ((h = gethostbyname(ip.c_str())) == nullptr)      // 把域名、主机名、字符串格式的ip转换为结构体，存储在h中\n        {\n            ::close(client_sock);     // 关闭sock连接\n            client_sock = -1;\n            return false;\n        }\n\n        memcpy(&server_addr.sin_addr, h->h_addr, h->h_length);\n\n        // 连接服务器\n        if (connect(client_sock, (sockaddr *) &server_addr, sizeof(server_addr)) == -1) {\n            cout << \"连接服务器失败\" << endl;\n            ::close(client_sock);\n            return false;\n        }\n\n        return true;\n    }\n\n    bool send(const string &msg) const {\n        // 参数使用string，不使用const char*，因为const char*\n        if (client_sock == -1) {\n            cout << \"ERROR: not connected\" << endl;\n            return false;\n        }\n\n        // 或者：if (send(client_sock, msg.c_str(), msg.length(), 0))      // 语义不准确：buffer可以是string，也可以是一块内存\n        if (::send(client_sock, msg.data(), msg.size(), 0) == -1) {\n            cout << \"ERROR: send failed\" << endl;\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * 用于传输二进制\n     * @param msg 要传输的数据（可以是结构体）\n     * @param size 数据大小\n     * @return\n     */\n    bool send(void *msg, const size_t size) {\n        // 参数使用string，不使用const char*，因为const char*\n        if (client_sock == -1) {\n            cout << \"ERROR: not connected\" << endl;\n            return false;\n        }\n\n        // 或者：if (send(client_sock, msg.c_str(), msg.length(), 0))      // 语义不准确：buffer可以是string，也可以是一块内存\n        if (::send(client_sock, msg, size, 0) == -1) {\n            cout << \"ERROR: send failed\" << endl;\n            return false;\n        }\n\n        return true;\n    }\n\n    bool sendFile(const string &filePath, const size_t fileSize) {\n        ifstream fin;\n        fin.open(filePath, ios::in | ios::binary);\n        if (!fin.is_open()) {\n            cout << \"file open failed\" << endl;\n            return false;\n        }\n\n        int onRead = 0;         // 每次调用 fin.read() 打算读取的字节数\n        int totalByte = 0;      // 从文件中已读取的总字节数\n        int bufferSize = 4096;  // 缓冲区大小，单位byte\n        char buffer[bufferSize];         // 存放读取数据的buffer。实际开发中，一般在1000～5000之间。\n\n        while (true) {\n            memset(buffer, 0, sizeof(buffer));\n            if (fileSize - totalByte > bufferSize) {\n                onRead = bufferSize;\n            } else {\n                onRead = fileSize - totalByte;\n            }\n\n            fin.read(buffer, onRead);\n            if (!send(buffer, onRead)) {\n                return false;\n            }\n            totalByte += onRead;\n\n            if (totalByte == fileSize) {\n                break;\n            }\n        }\n\n        fin.close();\n        return true;\n    }\n\n    /**\n     *\n     * @param msg 存放接收到的内容\n     * @param maxLen 接收的最大长度\n     * @return\n     */\n    bool receive(string &msg, const size_t maxLen) const {\n        if (client_sock == -1) {\n            cout << \"ERROR: not connected\" << endl;\n            return false;\n        }\n\n        msg.clear();        // 清空容器\n        msg.resize(maxLen);     // 设置容器大小\n        /*\n         * 如果直接操作string对象的内存，需要保证亮点：\n         *      1. 不能越界\n         *      2. 操作后需要手动设置string的大小（resize函数）。(因为直接操作string对象的内存后，string对象自动管理内存的功能就会失效)\n         *\n         * 传地址除了使用msg[0]，还可以使用msg.c_str()，msg.data()。\n         * 但是后两种获取到的都是const类型，无法修改，而recv函数需要将收到的数据写入msg中\n         */\n        int read_byte_number = ::recv(client_sock, &msg[0], msg.size(), 0); // 返回接收数据的大小，-1表示失败，0表示sock已断开\n        if (read_byte_number <= 0) {\n            cout << \"ERROR: receive failed\" << endl;\n            msg.clear();\n            return false;\n        }\n        msg.resize(read_byte_number);\n\n        return true;\n    }\n\n    bool close() {\n        if (client_sock == -1) {\n            cout << \"ERROR: not connected\" << endl;\n        }\n        ::close(client_sock);\n\n        client_sock = -1;\n        return true;\n    }\n};\n\n// 通过stat结构体 获得文件大小，单位字节\nsize_t getFileSize(const char *fileName) {\n\n    if (fileName == NULL) {\n        return 0;\n    }\n\n    // 这是一个存储文件(夹)信息的结构体，其中有文件大小和创建时间、访问时间、修改时间等\n    struct stat statbuf;\n\n    // 提供文件名字符串，获得文件属性结构体\n    stat(fileName, &statbuf);\n\n    // 获取文件大小\n    size_t filesize = statbuf.st_size;\n\n    return filesize;\n}\n\nint main() {\n    cout << \"------------------- client start -------------------\" << endl;\n    tcpClient tcp_client;\n    string ip = \"127.0.0.1\";\n    string port = \"5005\";\n    if (!tcp_client.connect_to(ip, atoi(port.c_str()))) {\n        perror((\"connect to \" + ip + \":\" + port + \" failed\").c_str());\n        return -1;\n    }\n\n    // 发送文件\n    // 把待传文件名和文件大小发送给服务端\n    struct fileInfo {\n        char fileName[256];     // 文件目录和文件名。与程序运行位置(工作目录)联系紧密，工作目录不同，fileName对应的路径也不同\n        int fileSize;           // 文件大小\n    } fileinfo;\n    memset(&fileinfo, 0, sizeof(fileInfo));\n    strcpy(fileinfo.fileName, \"test.txt\");\n    fileinfo.fileSize = (int) getFileSize(fileinfo.fileName);\n    if (!tcp_client.send(&fileinfo, sizeof(fileinfo))) {\n        char errormsg[32];\n        sprintf(errormsg, \"fileInfo send failed\");\n        perror(errormsg);\n        return -1;\n    } else {\n        cout << \"发送文件信息: fileName: \" << fileinfo.fileName << \"  fileSize: \" << fileinfo.fileSize << endl;\n    }\n\n    // 等待服务端的确认\n    string buffer;\n    if (!tcp_client.receive(buffer, 2)) {\n        cout << \"receive error\" << endl;\n    }\n    if (buffer != \"OK\") {\n        cout << \"receive message error\" << endl;\n    }\n\n    // 发送文件给服务端\n    if (!tcp_client.sendFile(fileinfo.fileName, fileinfo.fileSize)) {\n        cout << \"file send error\" << endl;\n        return -1;\n    }\n\n    // 等待服务端的确认\n    if (!tcp_client.receive(buffer, 2)) {\n        cout << \"no 'OK' received\" << endl;\n    }\n\n    if (buffer != \"OK\") {\n        cout << \"ERROR receive\" << endl;\n    } else {\n        cout << \"received 'OK'\" << endl;\n    }\n\n    return 0;\n}\n```\n\n##### 服务端\n\n```cpp\n#include <iostream>\n#include <fstream>\n\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <memory.h>\n\n#include <csignal>\n\nusing namespace std;\n\nclass tcpServer {\npublic:\n    int listen_sock;            // 用于监听的socket。-1表示未初始化\n    int client_sock;            // 客户端连上的的socket，用于和客户端通信。-1表示客户端未连接。\n    string client_ip;           // 客户端的ip\n    unsigned short port;        // 服务端用于通讯的端口\n\n    tcpServer() : listen_sock(-1), client_sock(-1) {}\n\n    ~tcpServer() {\n        if (listen_sock == -1) {\n            closeListen();\n        }\n        if (client_sock == -1) {\n            closeClient();\n        }\n    }\n\n    bool initServer(const unsigned short &in_port) {\n        // 初始化服务端用于监听的socket\n        if ((listen_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n            cout << \"ERROR socket init failed\" << endl;\n            return false;\n        }\n\n        port = in_port;\n\n        // 将服务端用于通信的ip和端口绑定到socket上\n        struct sockaddr_in server_addr;\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;                       // 协议\n        server_addr.sin_port = htons(port);                     // 指定服务端的通信端口\n        server_addr.sin_addr.s_addr = htonl(INADDR_ANY);        // 如果操作系统有多个ip，则多个ip都可以用于通信\n\n        // 为socket绑定ip和端口\n        if (bind(listen_sock, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {\n            cout << \"ERROR socket bind failed\" << endl;\n            close(listen_sock);\n            listen_sock = -1;\n            return false;\n        }\n\n        if (listen(listen_sock, 5)) {\n            cout << \"ERROR listening start failed\" << endl;\n            return false;\n        }\n        return true;\n    }\n\n    bool accept() {\n        struct sockaddr_in client_addr;             // 客户端的地址信息\n        socklen_t addrlen = sizeof(client_addr);    // struct sockaddr_in的大小\n        // 注意accept函数的第三个参数是指针：因为accept函数需要将实际接收到的消息长度写回addrlen\n        if ((client_sock = ::accept(listen_sock, (struct sockaddr *) &client_addr, &addrlen)) == -1) {\n            perror(\"accept failed\");\n            return false;\n        }\n\n        client_ip = inet_ntoa(client_addr.sin_addr);          // 将客户端的代码从大端序转换为字符串\n\n        return true;\n    }\n\n    bool send(const string &msg) {\n        if (client_sock == -1) {\n            perror(\"socket no connected\");\n            return false;\n        }\n\n        if ((::send(client_sock, msg.data(), msg.size(), 0) <= 0)) {\n            perror(\"send message failed\");\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * 存放接收到的字符串数据\n     * @param msg\n     * @param maxLen\n     * @return\n     */\n    bool recv(string &msg, const size_t maxLen) {\n        msg.clear();\n        msg.resize(maxLen);\n        int read_byte_number = ::recv(client_sock, &msg[0], msg.size(), 0);\n        if (read_byte_number <= 0) {\n            msg.clear();\n            perror(\"receive failed\");\n            return false;\n        }\n        msg.resize(read_byte_number);\n        return true;\n    }\n\n    /**\n     * 存放接收到的二进制数据\n     * @param msg\n     * @param maxLen\n     * @return\n     */\n    bool recv(void *msg, const size_t maxLen) const {\n        if (client_sock == -1) {\n            cout << \"ERROR: not connected\" << endl;\n            return false;\n        }\n\n        int read_byte_number = ::recv(client_sock, msg, maxLen, 0); // 返回接收数据的大小，-1表示失败，0表示sock已断开\n        if (read_byte_number <= 0) {\n            cout << \"ERROR: receive failed\" << endl;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * 接收文件\n     * @param filePath 文件路径和文件名\n     * @param fileSize 文件大小\n     * @return\n     */\n    bool receiveFile(const string &filePath, const size_t fileSize) {\n        ofstream fout;\n        fout.open(filePath, ios::binary | ios::out);\n        fout<<\"iii\"<<endl;\n        if (!fout.is_open()) {\n            cout << \"file open failed\" << endl;\n            return false;\n        }\n        int totalByte = 0;          // 已接收文件的总字节数\n        int onRead = 0;             // 本次打算接收的字节数\n        int bufferSize = 4096;  \t// 缓冲区大小，单位byte\n        char buffer[bufferSize];             // 接收文件内容的缓冲区，实际开发中，一般在1000～5000之间。\n\n        while (true) {\n            if (fileSize - totalByte > bufferSize) {\n                onRead = bufferSize;\n            } else {\n                onRead = fileSize - totalByte;\n            }\n\n            if (!recv(buffer, onRead)) {\n                return false;\n            }\n\n            fout.write(buffer, onRead);\n\n            totalByte += onRead;\n\n            if (totalByte == fileSize) {\n                fout.close();\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    bool closeListen() {\n        if (listen_sock == -1) {\n            perror(\"not listening\");\n            return false;\n        }\n        close(listen_sock);\n        listen_sock = -1;\n        return true;\n    }\n\n    bool closeClient() {\n        if (client_sock == -1) {\n            perror(\"not listening\");\n            return false;\n        }\n        close(client_sock);\n        client_sock = -1;\n        return true;\n    }\n\n    // 获取string格式的ip地址\n    [[nodiscard]] const string &clientip() const {\n        return client_ip;\n    }\n};\n\ntcpServer tcp_server;\n\nvoid fatherEXIT(int sig) {\n    // 以下代码是为了防止信号处理函数在执行过程中再次被信号中断\n    signal(SIGINT, SIG_IGN);\n    signal(SIGTERM, SIG_IGN);\n\n    cout << \"父进程退出： \" << sig << endl;\n\n    kill(0, SIGTERM);\n\n    // ---------------在这里增加释放资源的代码---------------\n    tcp_server.closeListen();\n    // --------------------------------------------------\n\n    exit(0);\n}\n\nvoid childEXIT(int sig) {\n    signal(SIGINT, SIG_IGN);\n    signal(SIGTERM, SIG_IGN);\n\n    cout << \"子进程退出： \" << sig << endl;\n\n    // ------在这里增加释放资源的代码（只释放子进程的资源）------\n    tcp_server.closeClient();       // 信号处理函数中只能访问全局对象，tcp_server必须定义为全局变量\n    // --------------------------------------------------\n\n    exit(0);\n}\n\nint main() {\n    if (!tcp_server.initServer(5005)) {\n        perror(\"initsServer() failed\");\n        return -1;\n    }\n\n    // 忽略全部信号，不希望被打扰。顺便解决僵尸进程的问题\n    for (int i = 0; i < 64; ++i) {\n        signal(i, SIG_IGN);\n    }\n    // 设置信号，在shell下可以用 'kill 进程号' 和 'Ctrl+C' 正常终止这些线程\n    // 但请不要用 'kill -9 进程号' 强行终止线程\n    signal(SIGTERM, fatherEXIT);\n    signal(SIGINT, fatherEXIT);\n\n    while (true) {\n        // 受理(监听)客户端的连接，从已连接的客户端中取出一个客户端\n        // 如果没有已连接的客户端，accept函数将阻塞等待\n        if (!tcp_server.accept()) {\n            perror(\"accept failed\");\n            return -1;\n        }\n        cout << \"client connected\" << endl;\n\n        int pid = fork();\n        // 系统资源不足\n        if (pid == -1) {\n            perror(\"fork\");\n            return -1;\n        }\n        if (pid > 0) {\n            tcp_server.closeClient();           // 多进程下，服务器父进程不需要客户端的socket，关闭\n            continue;           // 父进程返回循环开始位置，继续受理客户端连接\n        }\n\n        tcp_server.closeListen();           // 子进程不需要监听socket，关闭\n        // 子进程需要重新设置信号\n        signal(SIGTERM, childEXIT);         // 使用kill命令终止进程时，会产生SIGTERM信号，执行childEXIT函数\n        signal(SIGINT, childEXIT);          // 按下ctrl+c会触发SIGINT信号，执行childEXIT函数\n\n        // 接收文件\n        // 接收客户端发来的文件信息\n        struct fileInfo {\n            char fileName[256];     // 文件名\n            int fileSize;           // 文件大小\n        } fileinfo;\n        memset(&fileinfo, 0, sizeof(fileinfo));\n        if (!tcp_server.recv(&fileinfo, sizeof(fileinfo))) {\n            cout << \"fileInfo receive failed\" << endl;\n            return -1;\n        } else {\n            strcpy(fileinfo.fileName, \"test(1).txt\");\n            cout << \"received: fileName: \" << fileinfo.fileName << \"  fileSize: \" << fileinfo.fileSize << endl;\n        }\n\n        // 给客户端发送确认报文\n        if (!tcp_server.send(\"OK\")) {\n            cout << \"send error\" << endl;\n            break;\n        }\n\n        // 接收文件\n        if (!tcp_server.receiveFile(fileinfo.fileName, fileinfo.fileSize)) {\n            cout << \"received file error\" << endl;\n        } else {\n            cout << \"file receive success\" << endl;\n        }\n\n        // 给客户端发送确认报文\n        if (!tcp_server.send(\"OK\")) {\n            cout << \"send 'OK' failed\" << endl;\n        }\n\n        return 0;           // 子进程通信完成后一定要退出，否则就会回到accept()函数的位置\n    }\n\n    return 0;\n}\n```\n\n","slug":"网络编程/socket","published":1,"updated":"2025-09-14T02:36:11.049Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpt000w4e4pddw409qf","content":"<h3 id=\"基本函数和结构体\">基本函数和结构体</h3>\n<ol>\n<li>\n<p>创建socket<br>\n<code>int socket(int domain, int type, int protocol)</code><br>\n成功返回<code>0</code>；失败返回<code>-1</code>，同时设置错误代码<code>errno</code>。<br>\n单个进程能够创建<code>socket</code>连接的数量受系统参数<code>open files</code>的限制（使用<code>ulimit -a</code>查看）。因为<code>socket</code>在<code>Linux</code>中也是文件</p>\n<ul>\n<li><code>domain</code>:通信协议族\n<ul>\n<li><code>PF_INET</code>:<code>ipv4</code>协议族</li>\n<li><code>PF_INET6</code>:<code>ipv6</code>协议族</li>\n<li><code>PF_LOCAL</code>:本地通信的协议族</li>\n<li><code>PF_PACKET</code>:内核底层的协议族</li>\n<li><code>PF_IPX</code>:<code>IPX Novel</code>协议族</li>\n<li>其余协议族不常用</li>\n</ul>\n</li>\n<li><code>type</code>:数据传输的类型\n<ul>\n<li><code>SOCK_STREAM</code>:面向连接的<code>socket</code>，\n<ul>\n<li>数据不会丢失</li>\n<li>数据顺序不会错乱</li>\n<li>双向通道</li>\n</ul>\n</li>\n<li><code>SOCK_DGRAM</code>:无连接的<code>socket</code>，\n<ul>\n<li>传输效率更高</li>\n<li>数据可能丢失</li>\n<li>数据顺序可能错乱</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>protocal</code>:最终使用的协议\n<ul>\n<li>在<code>ipv4</code>协议族中，数据传输方式为<code>SOCK_STREAM</code>的协议只有<code>IPPROTO_TCP</code>，数据传输方式为<code>SOCK_DGRAM</code>的协议只有<code>IPPROTO_UDP</code>.</li>\n<li>该参数也可以为0</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>TCP</code>和<code>UDP</code>.[[TCP协议和UDP协议]]</p>\n</li>\n<li>\n<p>主机字节序和网络字节序</p>\n<ul>\n<li>主机字节序：分为<strong>大端序</strong>和<strong>小端序</strong>。<br>\n每个地址内放<code>1Byte</code>（<code>8bit</code>），大端序和小端序讨论多个字节(<code>Byte</code>)的地址高低问题\n<ul>\n<li>大端序：<mark>低高高低</mark>.<br>\n<mark>低位</mark><code>Byte</code>存放在<mark>高位</mark>，<mark>高位</mark><code>Byte</code>存放在<mark>低位</mark>.</li>\n<li>小端序：<mark>低低高高</mark>.<br>\n<mark>低位</mark><code>Byte</code>存放在<mark>低位</mark>，<mark>高位</mark><code>Byte</code>存放在<mark>高位</mark>.<br>\n<img src=\"image/Pasted_image_20250610210518.png\" alt=\"image\" style=\"zoom:80%;\" /><br>\n总结：<strong>大端序按照原来顺序存储，小端序按字节颠倒顺序存储</strong>。</li>\n<li>造成的问题：同样的数据，大端序的计算机和小端序的计算机解析方式不同，那么得到的内容也不一样。在网络传输中，容易出现问题。</li>\n</ul>\n</li>\n<li><strong>网络字节序（大端序）</strong>：解决不同字节序的计算机之间传输数据的问题<br>\nC语言提供了四个函数用于网络字节序和主机字节序的转换：\n<ul>\n<li><code>uint16_t htons(uint16_t hostshort)</code>:将16位的整数从<em>主机字节序</em>转换为<em>网络字节序</em>。</li>\n<li><code>uint32_t htonl(uint32_t hostlong)</code>:将32位的整数从<em>主机字节序</em>转换为<em>网络字节序</em>。</li>\n<li><code>uint16_t stohs(uint16_t netshort)</code>:将16位的整数从<em>网络字节序</em>转换为<em>主机在字节序</em>。</li>\n<li><code>uint32_t stohl(uint32_t netlong)</code>:将32位的整数从<em>网络字节序</em>转换为<em>主机字节序</em>。<br>\n<code>h: host</code>主机<br>\n<code>n: net</code>网络<br>\n<code>s: short</code>2字节，16位的整数<br>\n<code>l: long</code>4字节，32位的整数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code> ip</code>地址和通讯端口<code>port</code>.<br>\n<code>ipv4</code>地址用4字节(<code>32bit</code>)的整数存放，<code>port</code>用2字节(<code>16bit</code>)的整数存放（0～65535）。<br>\n为什么不用字符串？<br>\n因为<code>192.168.190.134</code>用字符串存储需要15字节，而用整数存储只需要4个字节：3232284294。（<strong>思考<code>ipv4</code>地址最大只能到<code>255.255.255.255</code></strong>）</p>\n</li>\n<li>\n<p>万恶的结构体<br>\n因为平时用到的<code>ip</code>地址都是字符串类型的，而程序中存储的是<code>int</code>类型那么就需要将字符串类型的ip转换为int型ip。主要涉及三个结构体和一个函数</p>\n<ol>\n<li>\n<p><code>sockaddr</code>结构体<br>\n存储协议族、端口、地址信息。客户端的<code>connetc</code>函数和服务端的<code>bind</code>函数都要用到这个结构体。其定义类似下图：</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">short</span> <span class=\"type\">int</span> sa_family;   <span class=\"comment\">// 协议族</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> sa_data[<span class=\"number\">14</span>];  <span class=\"comment\">// 14字节的端口和地址</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>sockaddr_in</code>结构体<br>\n上方的<code>sockaddr</code>是为了统一地址结构的表示方法，统一接口函数。但是很难用，操作不方便。所以定义了等价的<code>sockaddr_in</code>结构体，其大小与<code>sockaddr</code>相同，可以强制转换。</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr_in</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">short</span> <span class=\"type\">int</span> sa_family;   <span class=\"comment\">// 协议族</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">short</span> sin_port;  <span class=\"comment\">// 16bit端口号</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">in_addr</span> sin_addr;  <span class=\"comment\">// 32bit的地址(只能存储ipv4的地址，不能存储ipv6。sockaddr中14个字节的char数组就是预留了ip地址扩展的空间)</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> sin_zero[<span class=\"number\">8</span>];<span class=\"comment\">// 未使用，为了保持与sockaddr长度相同而添加。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">in_addr</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> s_addr; <span class=\"comment\">// 32bit的ip地址，大端序</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>gethostbyname()</code>函数<br>\n根据域名、主机名、字符串<code>ip</code>地址获取大端存储的<code>int32</code>类型<code>ip</code>.</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hostent</span>* <span class=\"built_in\">gethostbyname</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* name);</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>hostent</code>结构体</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hostent</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* h_name; <span class=\"comment\">// 主机名</span></span><br><span class=\"line\">    <span class=\"type\">char</span>** h_aliases; <span class=\"comment\">// 主机所有别名构成的的字符串数组。（同一个ip可以绑定多个域名）</span></span><br><span class=\"line\">    <span class=\"type\">short</span> h_addrtype; <span class=\"comment\">// 主机ip地址的类型，如ipv4(AF_INET)还是ipv6</span></span><br><span class=\"line\">    <span class=\"type\">short</span> h_length; <span class=\"comment\">// 主机ip地址长度，ipv4为4(字节),ipv6为16(字节)</span></span><br><span class=\"line\">    <span class=\"type\">char</span>** h_addr_list; <span class=\"comment\">// 主机的ip地址，以网络字节序存储</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取<code>hostent</code>后，使用以下代码把大端序的地址复制到<code>sockaddr_in</code>结构体的<code>sin_addr</code>成员中</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sockaddr_in serveraddr;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hostent</span>* h = <span class=\"built_in\">gethostbyname</span>(<span class=\"string\">&quot;192.168.1.2&quot;</span>); </span><br><span class=\"line\"><span class=\"built_in\">memcpy</span>(&amp;serveraddr.sin_addr, h-&gt;h_addr_list, h-&gt;h_length);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p>字符串<code>ip</code>转大端序<code>ip</code>.<br>\nC语言提供了几个库函数，用于字符串<code>ip</code>和大端序<code>ip</code>的相互转换。通常用于网络通讯的服务端程序中。</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> uint32;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把字符串格式的ip转换成大端序的ip，转换后的ip应该赋值给 sockaddr_in.in_addr.s_addr。不能传入域名</span></span><br><span class=\"line\"><span class=\"function\">uint_32 <span class=\"title\">inet_addr</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* cp)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将字符串格式的ip转换为大端序的ip，转换后的ip直接填充到sockaddr_in.in_addr成员（不需要手动填充）。不能传入域名 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">inet_aton</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* cp, <span class=\"keyword\">struct</span> int_addr * inp)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将大端序ip转换为字符串格式的ip。用于在服务器程序中解析客户端的ip地址  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">char</span>* <span class=\"title\">inet_ntoa</span><span class=\"params\">(<span class=\"keyword\">struct</span> in_addr in)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>bind</code>函数<br>\n绑定服务端的<code>ip</code>和端口，失败返回-1</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr</span> server_addr;</span><br><span class=\"line\"><span class=\"built_in\">bind</span>(listenfd, (<span class=\"keyword\">struct</span> sockaddr *)&amp;server_addr, <span class=\"built_in\">sizeof</span>(server_addr))</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>lieten</code>函数<br>\n把socket设置为可连接(监听)的状态，失败返回-1<br>\n<code>listen(listenfd, 5)</code></p>\n</li>\n</ol>\n<h3 id=\"封装socket客户端\">封装socket客户端</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">tcpClient</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> client_sock;        <span class=\"comment\">// 客户端socket，-1表示未连接或者已断开。&gt;=0表示有效的socket</span></span><br><span class=\"line\">    string ip;              <span class=\"comment\">// 服务端的ip或域名</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">short</span> port;    <span class=\"comment\">// 通讯端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">tcpClient</span>() : <span class=\"built_in\">client_sock</span>(<span class=\"number\">-1</span>), <span class=\"built_in\">port</span>(<span class=\"number\">-1</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">tcpClient</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">close</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @param in_ip 客户端ip/域名</span></span><br><span class=\"line\"><span class=\"comment\">     * @param in_port 端口号</span></span><br><span class=\"line\"><span class=\"comment\">     * @return 成功返回true，失败返回false</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">connect_to</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;in_ip, <span class=\"type\">const</span> <span class=\"type\">unsigned</span> <span class=\"type\">short</span> in_port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: sock connect is already exist&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 保存服务端ip和端口号</span></span><br><span class=\"line\">        ip = in_ip;</span><br><span class=\"line\">        port = in_port;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建客户端Socket</span></span><br><span class=\"line\">        client_sock = <span class=\"built_in\">socket</span>(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;创建Socket失败&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 配置服务器地址</span></span><br><span class=\"line\">        sockaddr_in server_addr&#123;&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(&amp;server_addr, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(server_addr));</span><br><span class=\"line\">        server_addr.sin_family = AF_INET;</span><br><span class=\"line\">        server_addr.sin_port = <span class=\"built_in\">htons</span>(port);</span><br><span class=\"line\">        <span class=\"comment\">// server_addr.sin_addr.s_addr = inet_addr(in_ip.c_str());      // 该方法只能用ip，不能用域名</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">hostent</span> *h;          <span class=\"comment\">// 用于存放服务端的大端序ip的结构体的指针</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((h = <span class=\"built_in\">gethostbyname</span>(ip.<span class=\"built_in\">c_str</span>())) == <span class=\"literal\">nullptr</span>)      <span class=\"comment\">// 把域名、主机名、字符串格式的ip转换为结构体，存储在h中</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ::<span class=\"built_in\">close</span>(client_sock);     <span class=\"comment\">// 关闭sock连接</span></span><br><span class=\"line\">            client_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(&amp;server_addr.sin_addr, h-&gt;h_addr, h-&gt;h_length);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 连接服务器</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">connect</span>(client_sock, (sockaddr *) &amp;server_addr, <span class=\"built_in\">sizeof</span>(server_addr)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;连接服务器失败&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            ::<span class=\"built_in\">close</span>(client_sock);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;msg)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 参数使用string，不使用const char*，因为const char*</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: not connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 或者：if (send(client_sock, msg.c_str(), msg.length(), 0))      // 语义不准确：buffer可以是string，也可以是一块内存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (::<span class=\"built_in\">send</span>(client_sock, msg.<span class=\"built_in\">data</span>(), msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: send failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * @param msg 存放接收到的内容</span></span><br><span class=\"line\"><span class=\"comment\">     * @param maxLen 接收的最大长度</span></span><br><span class=\"line\"><span class=\"comment\">     * @return</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">receive</span><span class=\"params\">(string &amp;msg, <span class=\"type\">const</span> <span class=\"type\">size_t</span> maxLen)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: not connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.<span class=\"built_in\">clear</span>();        <span class=\"comment\">// 清空容器</span></span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(maxLen);     <span class=\"comment\">// 设置容器大小</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果直接操作string对象的内存，需要保证两点：</span></span><br><span class=\"line\"><span class=\"comment\">         *      1. 不能越界</span></span><br><span class=\"line\"><span class=\"comment\">         *      2. 操作后需要手动设置string的大小（resize函数）。(因为直接操作string对象的内存后，string对象自动管理内存的功能就会失效)</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * 传地址除了使用msg[0]，还可以使用msg.c_str()，msg.data()。</span></span><br><span class=\"line\"><span class=\"comment\">         * 但是后两种获取到的都是const类型，无法修改，而recv函数需要将收到的数据写入msg中</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"type\">int</span> read_byte_number = ::<span class=\"built_in\">recv</span>(client_sock, &amp;msg[<span class=\"number\">0</span>], msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>); <span class=\"comment\">// 返回接收数据的大小，-1表示失败，0表示sock已断开</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read_byte_number &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: receive failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            msg.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(read_byte_number);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: not connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ::<span class=\"built_in\">close</span>(client_sock);</span><br><span class=\"line\"></span><br><span class=\"line\">        client_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;------------------- client start -------------------&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    tcpClient tcp_client;</span><br><span class=\"line\">    string ip = <span class=\"string\">&quot;127.0.0.1&quot;</span>;</span><br><span class=\"line\">    string port = <span class=\"string\">&quot;5005&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_client.<span class=\"built_in\">connect_to</span>(ip, <span class=\"built_in\">atoi</span>(port.<span class=\"built_in\">c_str</span>()))) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>((<span class=\"string\">&quot;connect to &quot;</span> + ip + <span class=\"string\">&quot;:&quot;</span> + port + <span class=\"string\">&quot; failed&quot;</span>).<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">char</span> msg[<span class=\"number\">1024</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> iret;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(msg, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(msg));</span><br><span class=\"line\">        <span class=\"built_in\">sprintf</span>(msg, <span class=\"string\">&quot;test message %d&quot;</span>, i + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 向服务端发送请求报文</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_client.<span class=\"built_in\">send</span>(msg)) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> errormsg[<span class=\"number\">32</span>];</span><br><span class=\"line\">            <span class=\"built_in\">sprintf</span>(errormsg, <span class=\"string\">&quot;message %d send failed&quot;</span>, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(errormsg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;send: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">        string received_message;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_client.<span class=\"built_in\">receive</span>(received_message, <span class=\"number\">1024</span>)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;received failed&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;received: &quot;</span> &lt;&lt; received_message &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"封装socket服务端\">封装socket服务端</h3>\n<h4 id=\"单进程单线程服务端\">单进程单线程服务端</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">tcpServer</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> listen_sock;            <span class=\"comment\">// 用于监听的socket。-1表示未初始化</span></span><br><span class=\"line\">    <span class=\"type\">int</span> client_sock;            <span class=\"comment\">// 客户端连上的的socket，用于和客户端通信。-1表示客户端未连接。</span></span><br><span class=\"line\">    string client_ip;           <span class=\"comment\">// 客户端的ip</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">short</span> port;        <span class=\"comment\">// 服务端用于通讯的端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">tcpServer</span>() : <span class=\"built_in\">listen_sock</span>(<span class=\"number\">-1</span>), <span class=\"built_in\">client_sock</span>(<span class=\"number\">-1</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">tcpServer</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listen_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">closeListen</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">closeClient</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">initServer</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">unsigned</span> <span class=\"type\">short</span> &amp;in_port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化服务端用于监听的socket</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((listen_sock = <span class=\"built_in\">socket</span>(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR socket init failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        port = in_port;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将服务端用于通信的ip和端口绑定到socket上</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr_in</span> server_addr;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(&amp;server_addr, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(server_addr));</span><br><span class=\"line\">        server_addr.sin_family = AF_INET;                       <span class=\"comment\">// 协议</span></span><br><span class=\"line\">        server_addr.sin_port = <span class=\"built_in\">htons</span>(port);                     <span class=\"comment\">// 指定服务端的通信端口</span></span><br><span class=\"line\">        server_addr.sin_addr.s_addr = <span class=\"built_in\">htonl</span>(INADDR_ANY);        <span class=\"comment\">// 如果操作系统有多个ip，则多个ip都可以用于通信</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 为socket绑定ip和端口</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">bind</span>(listen_sock, (<span class=\"keyword\">struct</span> sockaddr *) &amp;server_addr, <span class=\"built_in\">sizeof</span>(server_addr)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR socket bind failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"built_in\">close</span>(listen_sock);</span><br><span class=\"line\">            listen_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">listen</span>(listen_sock, <span class=\"number\">5</span>)) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR listening start failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">accept</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr_in</span> client_addr;             <span class=\"comment\">// 客户端的地址信息</span></span><br><span class=\"line\">        <span class=\"type\">socklen_t</span> addrlen = <span class=\"built_in\">sizeof</span>(client_addr);    <span class=\"comment\">// struct sockaddr_in的大小</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意accept函数的第三个参数是指针：因为accept函数需要将实际接收到的消息长度写回addrlen</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((client_sock = ::<span class=\"built_in\">accept</span>(listen_sock, (<span class=\"keyword\">struct</span> sockaddr *) &amp;client_addr, &amp;addrlen)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;accept failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        client_ip = <span class=\"built_in\">inet_ntoa</span>(client_addr.sin_addr);          <span class=\"comment\">// 将客户端的代码从大端序转换为字符串</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;socket no connected&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((::<span class=\"built_in\">send</span>(client_sock, msg.<span class=\"built_in\">data</span>(), msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>) &lt;= <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;send message failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">recv</span><span class=\"params\">(string &amp;msg, <span class=\"type\">const</span> <span class=\"type\">size_t</span> maxLen)</span> </span>&#123;</span><br><span class=\"line\">        msg.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(maxLen);</span><br><span class=\"line\">        <span class=\"type\">int</span> read_byte_number = ::<span class=\"built_in\">recv</span>(client_sock, &amp;msg[<span class=\"number\">0</span>], msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read_byte_number &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            msg.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;receive failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(read_byte_number);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">closeListen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listen_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;not listening&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(listen_sock);</span><br><span class=\"line\">        listen_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">closeClient</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;not listening&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(client_sock);</span><br><span class=\"line\">        client_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取string格式的ip地址</span></span><br><span class=\"line\">    [[nodiscard]] <span class=\"function\"><span class=\"type\">const</span> string &amp;<span class=\"title\">clientip</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> client_ip;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    tcpServer tcp_server;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">initServer</span>(<span class=\"number\">5005</span>)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;initsServer() failed&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">accept</span>()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;accept failed&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;client connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    string msg;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 接收客户端发来的报文，如果客户端没有发来报文，recv将阻塞等待</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">recv</span>(msg, <span class=\"number\">1024</span>)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;receive failed&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;received: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">        msg = <span class=\"string\">&quot;OK&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 向客户端发送报文</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">send</span>(msg)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;send failed&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;send: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"多进程服务端\">多进程服务端</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;csignal&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">tcpServer</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> listen_sock;            <span class=\"comment\">// 用于监听的socket。-1表示未初始化</span></span><br><span class=\"line\">    <span class=\"type\">int</span> client_sock;            <span class=\"comment\">// 客户端连上的的socket，用于和客户端通信。-1表示客户端未连接。</span></span><br><span class=\"line\">    string client_ip;           <span class=\"comment\">// 客户端的ip</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">short</span> port;        <span class=\"comment\">// 服务端用于通讯的端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">tcpServer</span>() : <span class=\"built_in\">listen_sock</span>(<span class=\"number\">-1</span>), <span class=\"built_in\">client_sock</span>(<span class=\"number\">-1</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">tcpServer</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listen_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">closeListen</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">closeClient</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">initServer</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">unsigned</span> <span class=\"type\">short</span> &amp;in_port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化服务端用于监听的socket</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((listen_sock = <span class=\"built_in\">socket</span>(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR socket init failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        port = in_port;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将服务端用于通信的ip和端口绑定到socket上</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr_in</span> server_addr;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(&amp;server_addr, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(server_addr));</span><br><span class=\"line\">        server_addr.sin_family = AF_INET;                       <span class=\"comment\">// 协议</span></span><br><span class=\"line\">        server_addr.sin_port = <span class=\"built_in\">htons</span>(port);                     <span class=\"comment\">// 指定服务端的通信端口</span></span><br><span class=\"line\">        server_addr.sin_addr.s_addr = <span class=\"built_in\">htonl</span>(INADDR_ANY);        <span class=\"comment\">// 如果操作系统有多个ip，则多个ip都可以用于通信</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 为socket绑定ip和端口</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">bind</span>(listen_sock, (<span class=\"keyword\">struct</span> sockaddr *) &amp;server_addr, <span class=\"built_in\">sizeof</span>(server_addr)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR socket bind failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"built_in\">close</span>(listen_sock);</span><br><span class=\"line\">            listen_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">listen</span>(listen_sock, <span class=\"number\">5</span>)) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR listening start failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">accept</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr_in</span> client_addr;             <span class=\"comment\">// 客户端的地址信息</span></span><br><span class=\"line\">        <span class=\"type\">socklen_t</span> addrlen = <span class=\"built_in\">sizeof</span>(client_addr);    <span class=\"comment\">// struct sockaddr_in的大小</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意accept函数的第三个参数是指针：因为accept函数需要将实际接收到的消息长度写回addrlen</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((client_sock = ::<span class=\"built_in\">accept</span>(listen_sock, (<span class=\"keyword\">struct</span> sockaddr *) &amp;client_addr, &amp;addrlen)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;accept failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        client_ip = <span class=\"built_in\">inet_ntoa</span>(client_addr.sin_addr);          <span class=\"comment\">// 将客户端的代码从大端序转换为字符串</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;socket no connected&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((::<span class=\"built_in\">send</span>(client_sock, msg.<span class=\"built_in\">data</span>(), msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>) &lt;= <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;send message failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">recv</span><span class=\"params\">(string &amp;msg, <span class=\"type\">const</span> <span class=\"type\">size_t</span> maxLen)</span> </span>&#123;</span><br><span class=\"line\">        msg.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(maxLen);</span><br><span class=\"line\">        <span class=\"type\">int</span> read_byte_number = ::<span class=\"built_in\">recv</span>(client_sock, &amp;msg[<span class=\"number\">0</span>], msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read_byte_number &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            msg.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;receive failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(read_byte_number);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">closeListen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listen_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;not listening&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(listen_sock);</span><br><span class=\"line\">        listen_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">closeClient</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;not listening&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(client_sock);</span><br><span class=\"line\">        client_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取string格式的ip地址</span></span><br><span class=\"line\">    [[nodiscard]] <span class=\"function\"><span class=\"type\">const</span> string &amp;<span class=\"title\">clientip</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> client_ip;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">tcpServer tcp_server;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fatherEXIT</span><span class=\"params\">(<span class=\"type\">int</span> sig)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 以下代码是为了防止信号处理函数在执行过程中再次被信号中断</span></span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGINT, SIG_IGN);</span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGTERM, SIG_IGN);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;父进程退出： &quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">kill</span>(<span class=\"number\">0</span>, SIGTERM);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ---------------在这里增加释放资源的代码---------------</span></span><br><span class=\"line\">    tcp_server.<span class=\"built_in\">closeListen</span>();</span><br><span class=\"line\">    <span class=\"comment\">// --------------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">childEXIT</span><span class=\"params\">(<span class=\"type\">int</span> sig)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGINT, SIG_IGN);</span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGTERM, SIG_IGN);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;子进程退出： &quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ------在这里增加释放资源的代码（只释放子进程的资源）------</span></span><br><span class=\"line\">    tcp_server.<span class=\"built_in\">closeClient</span>();       <span class=\"comment\">// 信号处理函数中只能访问全局对象，tcp_server必须定义为全局变量</span></span><br><span class=\"line\">    <span class=\"comment\">// --------------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">initServer</span>(<span class=\"number\">5005</span>)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;initsServer() failed&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 忽略全部信号，不希望被打扰。顺便解决僵尸进程的问题</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">64</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">signal</span>(i, SIG_IGN);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 设置信号，在shell下可以用 &#x27;kill 进程号&#x27; 和 &#x27;Ctrl+C&#x27; 正常终止这些线程</span></span><br><span class=\"line\">    <span class=\"comment\">// 但请不要用 &#x27;kill -9 进程号&#x27; 强行终止线程</span></span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGTERM, fatherEXIT);</span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGINT, fatherEXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 受理(监听)客户端的连接，从已连接的客户端中取出一个客户端</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果没有已连接的客户端，accept函数将阻塞等待</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">accept</span>()) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;accept failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;client connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> pid = fork();</span><br><span class=\"line\">        <span class=\"comment\">// 系统资源不足</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pid == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;fork&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pid &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            tcp_server.<span class=\"built_in\">closeClient</span>();           <span class=\"comment\">// 多进程下，服务器父进程不需要客户端的socket，关闭</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;           <span class=\"comment\">// 父进程返回循环开始位置，继续受理客户端连接</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tcp_server.<span class=\"built_in\">closeListen</span>();           <span class=\"comment\">// 子进程不需要监听socket，关闭</span></span><br><span class=\"line\">        <span class=\"comment\">// 子进程需要重新设置信号</span></span><br><span class=\"line\">        <span class=\"built_in\">signal</span>(SIGTERM, childEXIT);         <span class=\"comment\">// 使用kill命令终止进程时，会产生SIGTERM信号，执行childEXIT函数</span></span><br><span class=\"line\">        <span class=\"built_in\">signal</span>(SIGINT, childEXIT);          <span class=\"comment\">// 按下ctrl+c会触发SIGINT信号，执行childEXIT函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 子进程负责与客户端进行通讯</span></span><br><span class=\"line\">        string msg;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 接收客户端发来的报文，如果客户端没有发来报文，recv将阻塞等待</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">recv</span>(msg, <span class=\"number\">1024</span>)) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;receive failed&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cout &lt;&lt; <span class=\"string\">&quot;received: &quot;</span> &lt;&lt; msg &lt;&lt; <span class=\"string\">&quot;------thread id: &quot;</span> &lt;&lt; <span class=\"built_in\">getpid</span>() &lt;&lt; endl;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            msg = <span class=\"string\">&quot;OK&quot;</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 向客户端发送报文</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">send</span>(msg)) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;send failed&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cout &lt;&lt; <span class=\"string\">&quot;send: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;           <span class=\"comment\">// 子进程通信完成后一定要退出，否则就会回到accept()函数的位置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"文件传输\">文件传输</h4>\n<h5 id=\"客户端\">客户端</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">tcpClient</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> client_sock;        <span class=\"comment\">// 客户端socket，-1表示未连接或者已断开。&gt;=0表示有效的socket</span></span><br><span class=\"line\">    string ip;              <span class=\"comment\">// 服务端的ip或域名</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">short</span> port;    <span class=\"comment\">// 通讯端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">tcpClient</span>() : <span class=\"built_in\">client_sock</span>(<span class=\"number\">-1</span>), <span class=\"built_in\">port</span>(<span class=\"number\">-1</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">tcpClient</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">close</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @param in_ip 客户端ip/域名</span></span><br><span class=\"line\"><span class=\"comment\">     * @param in_port 端口号</span></span><br><span class=\"line\"><span class=\"comment\">     * @return 成功返回true，失败返回false</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">connect_to</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;in_ip, <span class=\"type\">const</span> <span class=\"type\">unsigned</span> <span class=\"type\">short</span> in_port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: sock connect is already exist&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 保存服务端ip和端口号</span></span><br><span class=\"line\">        ip = in_ip;</span><br><span class=\"line\">        port = in_port;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建客户端Socket</span></span><br><span class=\"line\">        client_sock = <span class=\"built_in\">socket</span>(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;创建Socket失败&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 配置服务器地址</span></span><br><span class=\"line\">        sockaddr_in server_addr&#123;&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(&amp;server_addr, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(server_addr));</span><br><span class=\"line\">        server_addr.sin_family = AF_INET;</span><br><span class=\"line\">        server_addr.sin_port = <span class=\"built_in\">htons</span>(port);</span><br><span class=\"line\">        <span class=\"comment\">// server_addr.sin_addr.s_addr = inet_addr(in_ip.c_str());      // 该方法只能用ip，不能用域名</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">hostent</span> *h;          <span class=\"comment\">// 用于存放服务端的大端序ip的结构体的指针</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((h = <span class=\"built_in\">gethostbyname</span>(ip.<span class=\"built_in\">c_str</span>())) == <span class=\"literal\">nullptr</span>)      <span class=\"comment\">// 把域名、主机名、字符串格式的ip转换为结构体，存储在h中</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ::<span class=\"built_in\">close</span>(client_sock);     <span class=\"comment\">// 关闭sock连接</span></span><br><span class=\"line\">            client_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(&amp;server_addr.sin_addr, h-&gt;h_addr, h-&gt;h_length);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 连接服务器</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">connect</span>(client_sock, (sockaddr *) &amp;server_addr, <span class=\"built_in\">sizeof</span>(server_addr)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;连接服务器失败&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            ::<span class=\"built_in\">close</span>(client_sock);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;msg)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 参数使用string，不使用const char*，因为const char*</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: not connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 或者：if (send(client_sock, msg.c_str(), msg.length(), 0))      // 语义不准确：buffer可以是string，也可以是一块内存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (::<span class=\"built_in\">send</span>(client_sock, msg.<span class=\"built_in\">data</span>(), msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: send failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 用于传输二进制</span></span><br><span class=\"line\"><span class=\"comment\">     * @param msg 要传输的数据（可以是结构体）</span></span><br><span class=\"line\"><span class=\"comment\">     * @param size 数据大小</span></span><br><span class=\"line\"><span class=\"comment\">     * @return</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"type\">void</span> *msg, <span class=\"type\">const</span> <span class=\"type\">size_t</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 参数使用string，不使用const char*，因为const char*</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: not connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 或者：if (send(client_sock, msg.c_str(), msg.length(), 0))      // 语义不准确：buffer可以是string，也可以是一块内存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (::<span class=\"built_in\">send</span>(client_sock, msg, size, <span class=\"number\">0</span>) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: send failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">sendFile</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;filePath, <span class=\"type\">const</span> <span class=\"type\">size_t</span> fileSize)</span> </span>&#123;</span><br><span class=\"line\">        ifstream fin;</span><br><span class=\"line\">        fin.<span class=\"built_in\">open</span>(filePath, ios::in | ios::binary);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!fin.<span class=\"built_in\">is_open</span>()) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;file open failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> onRead = <span class=\"number\">0</span>;         <span class=\"comment\">// 每次调用 fin.read() 打算读取的字节数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> totalByte = <span class=\"number\">0</span>;      <span class=\"comment\">// 从文件中已读取的总字节数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> bufferSize = <span class=\"number\">4096</span>;  <span class=\"comment\">// 缓冲区大小，单位byte</span></span><br><span class=\"line\">        <span class=\"type\">char</span> buffer[bufferSize];         <span class=\"comment\">// 存放读取数据的buffer。实际开发中，一般在1000～5000之间。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">memset</span>(buffer, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(buffer));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fileSize - totalByte &gt; bufferSize) &#123;</span><br><span class=\"line\">                onRead = bufferSize;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                onRead = fileSize - totalByte;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            fin.<span class=\"built_in\">read</span>(buffer, onRead);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">send</span>(buffer, onRead)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            totalByte += onRead;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (totalByte == fileSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        fin.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * @param msg 存放接收到的内容</span></span><br><span class=\"line\"><span class=\"comment\">     * @param maxLen 接收的最大长度</span></span><br><span class=\"line\"><span class=\"comment\">     * @return</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">receive</span><span class=\"params\">(string &amp;msg, <span class=\"type\">const</span> <span class=\"type\">size_t</span> maxLen)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: not connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.<span class=\"built_in\">clear</span>();        <span class=\"comment\">// 清空容器</span></span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(maxLen);     <span class=\"comment\">// 设置容器大小</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果直接操作string对象的内存，需要保证亮点：</span></span><br><span class=\"line\"><span class=\"comment\">         *      1. 不能越界</span></span><br><span class=\"line\"><span class=\"comment\">         *      2. 操作后需要手动设置string的大小（resize函数）。(因为直接操作string对象的内存后，string对象自动管理内存的功能就会失效)</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * 传地址除了使用msg[0]，还可以使用msg.c_str()，msg.data()。</span></span><br><span class=\"line\"><span class=\"comment\">         * 但是后两种获取到的都是const类型，无法修改，而recv函数需要将收到的数据写入msg中</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"type\">int</span> read_byte_number = ::<span class=\"built_in\">recv</span>(client_sock, &amp;msg[<span class=\"number\">0</span>], msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>); <span class=\"comment\">// 返回接收数据的大小，-1表示失败，0表示sock已断开</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read_byte_number &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: receive failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            msg.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(read_byte_number);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: not connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ::<span class=\"built_in\">close</span>(client_sock);</span><br><span class=\"line\"></span><br><span class=\"line\">        client_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过stat结构体 获得文件大小，单位字节</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">getFileSize</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *fileName)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fileName == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这是一个存储文件(夹)信息的结构体，其中有文件大小和创建时间、访问时间、修改时间等</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">stat</span> statbuf;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 提供文件名字符串，获得文件属性结构体</span></span><br><span class=\"line\">    <span class=\"built_in\">stat</span>(fileName, &amp;statbuf);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取文件大小</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> filesize = statbuf.st_size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> filesize;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;------------------- client start -------------------&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    tcpClient tcp_client;</span><br><span class=\"line\">    string ip = <span class=\"string\">&quot;127.0.0.1&quot;</span>;</span><br><span class=\"line\">    string port = <span class=\"string\">&quot;5005&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_client.<span class=\"built_in\">connect_to</span>(ip, <span class=\"built_in\">atoi</span>(port.<span class=\"built_in\">c_str</span>()))) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>((<span class=\"string\">&quot;connect to &quot;</span> + ip + <span class=\"string\">&quot;:&quot;</span> + port + <span class=\"string\">&quot; failed&quot;</span>).<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送文件</span></span><br><span class=\"line\">    <span class=\"comment\">// 把待传文件名和文件大小发送给服务端</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">fileInfo</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> fileName[<span class=\"number\">256</span>];     <span class=\"comment\">// 文件目录和文件名。与程序运行位置(工作目录)联系紧密，工作目录不同，fileName对应的路径也不同</span></span><br><span class=\"line\">        <span class=\"type\">int</span> fileSize;           <span class=\"comment\">// 文件大小</span></span><br><span class=\"line\">    &#125; fileinfo;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;fileinfo, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(fileInfo));</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(fileinfo.fileName, <span class=\"string\">&quot;test.txt&quot;</span>);</span><br><span class=\"line\">    fileinfo.fileSize = (<span class=\"type\">int</span>) <span class=\"built_in\">getFileSize</span>(fileinfo.fileName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_client.<span class=\"built_in\">send</span>(&amp;fileinfo, <span class=\"built_in\">sizeof</span>(fileinfo))) &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> errormsg[<span class=\"number\">32</span>];</span><br><span class=\"line\">        <span class=\"built_in\">sprintf</span>(errormsg, <span class=\"string\">&quot;fileInfo send failed&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(errormsg);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;发送文件信息: fileName: &quot;</span> &lt;&lt; fileinfo.fileName &lt;&lt; <span class=\"string\">&quot;  fileSize: &quot;</span> &lt;&lt; fileinfo.fileSize &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待服务端的确认</span></span><br><span class=\"line\">    string buffer;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_client.<span class=\"built_in\">receive</span>(buffer, <span class=\"number\">2</span>)) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;receive error&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buffer != <span class=\"string\">&quot;OK&quot;</span>) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;receive message error&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送文件给服务端</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_client.<span class=\"built_in\">sendFile</span>(fileinfo.fileName, fileinfo.fileSize)) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;file send error&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待服务端的确认</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_client.<span class=\"built_in\">receive</span>(buffer, <span class=\"number\">2</span>)) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;no &#x27;OK&#x27; received&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buffer != <span class=\"string\">&quot;OK&quot;</span>) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;ERROR receive&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;received &#x27;OK&#x27;&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"服务端\">服务端</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;csignal&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">tcpServer</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> listen_sock;            <span class=\"comment\">// 用于监听的socket。-1表示未初始化</span></span><br><span class=\"line\">    <span class=\"type\">int</span> client_sock;            <span class=\"comment\">// 客户端连上的的socket，用于和客户端通信。-1表示客户端未连接。</span></span><br><span class=\"line\">    string client_ip;           <span class=\"comment\">// 客户端的ip</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">short</span> port;        <span class=\"comment\">// 服务端用于通讯的端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">tcpServer</span>() : <span class=\"built_in\">listen_sock</span>(<span class=\"number\">-1</span>), <span class=\"built_in\">client_sock</span>(<span class=\"number\">-1</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">tcpServer</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listen_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">closeListen</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">closeClient</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">initServer</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">unsigned</span> <span class=\"type\">short</span> &amp;in_port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化服务端用于监听的socket</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((listen_sock = <span class=\"built_in\">socket</span>(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR socket init failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        port = in_port;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将服务端用于通信的ip和端口绑定到socket上</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr_in</span> server_addr;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(&amp;server_addr, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(server_addr));</span><br><span class=\"line\">        server_addr.sin_family = AF_INET;                       <span class=\"comment\">// 协议</span></span><br><span class=\"line\">        server_addr.sin_port = <span class=\"built_in\">htons</span>(port);                     <span class=\"comment\">// 指定服务端的通信端口</span></span><br><span class=\"line\">        server_addr.sin_addr.s_addr = <span class=\"built_in\">htonl</span>(INADDR_ANY);        <span class=\"comment\">// 如果操作系统有多个ip，则多个ip都可以用于通信</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 为socket绑定ip和端口</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">bind</span>(listen_sock, (<span class=\"keyword\">struct</span> sockaddr *) &amp;server_addr, <span class=\"built_in\">sizeof</span>(server_addr)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR socket bind failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"built_in\">close</span>(listen_sock);</span><br><span class=\"line\">            listen_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">listen</span>(listen_sock, <span class=\"number\">5</span>)) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR listening start failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">accept</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr_in</span> client_addr;             <span class=\"comment\">// 客户端的地址信息</span></span><br><span class=\"line\">        <span class=\"type\">socklen_t</span> addrlen = <span class=\"built_in\">sizeof</span>(client_addr);    <span class=\"comment\">// struct sockaddr_in的大小</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意accept函数的第三个参数是指针：因为accept函数需要将实际接收到的消息长度写回addrlen</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((client_sock = ::<span class=\"built_in\">accept</span>(listen_sock, (<span class=\"keyword\">struct</span> sockaddr *) &amp;client_addr, &amp;addrlen)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;accept failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        client_ip = <span class=\"built_in\">inet_ntoa</span>(client_addr.sin_addr);          <span class=\"comment\">// 将客户端的代码从大端序转换为字符串</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;socket no connected&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((::<span class=\"built_in\">send</span>(client_sock, msg.<span class=\"built_in\">data</span>(), msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>) &lt;= <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;send message failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 存放接收到的字符串数据</span></span><br><span class=\"line\"><span class=\"comment\">     * @param msg</span></span><br><span class=\"line\"><span class=\"comment\">     * @param maxLen</span></span><br><span class=\"line\"><span class=\"comment\">     * @return</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">recv</span><span class=\"params\">(string &amp;msg, <span class=\"type\">const</span> <span class=\"type\">size_t</span> maxLen)</span> </span>&#123;</span><br><span class=\"line\">        msg.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(maxLen);</span><br><span class=\"line\">        <span class=\"type\">int</span> read_byte_number = ::<span class=\"built_in\">recv</span>(client_sock, &amp;msg[<span class=\"number\">0</span>], msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read_byte_number &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            msg.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;receive failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(read_byte_number);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 存放接收到的二进制数据</span></span><br><span class=\"line\"><span class=\"comment\">     * @param msg</span></span><br><span class=\"line\"><span class=\"comment\">     * @param maxLen</span></span><br><span class=\"line\"><span class=\"comment\">     * @return</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">recv</span><span class=\"params\">(<span class=\"type\">void</span> *msg, <span class=\"type\">const</span> <span class=\"type\">size_t</span> maxLen)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: not connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> read_byte_number = ::<span class=\"built_in\">recv</span>(client_sock, msg, maxLen, <span class=\"number\">0</span>); <span class=\"comment\">// 返回接收数据的大小，-1表示失败，0表示sock已断开</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read_byte_number &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: receive failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 接收文件</span></span><br><span class=\"line\"><span class=\"comment\">     * @param filePath 文件路径和文件名</span></span><br><span class=\"line\"><span class=\"comment\">     * @param fileSize 文件大小</span></span><br><span class=\"line\"><span class=\"comment\">     * @return</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">receiveFile</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;filePath, <span class=\"type\">const</span> <span class=\"type\">size_t</span> fileSize)</span> </span>&#123;</span><br><span class=\"line\">        ofstream fout;</span><br><span class=\"line\">        fout.<span class=\"built_in\">open</span>(filePath, ios::binary | ios::out);</span><br><span class=\"line\">        fout&lt;&lt;<span class=\"string\">&quot;iii&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!fout.<span class=\"built_in\">is_open</span>()) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;file open failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> totalByte = <span class=\"number\">0</span>;          <span class=\"comment\">// 已接收文件的总字节数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> onRead = <span class=\"number\">0</span>;             <span class=\"comment\">// 本次打算接收的字节数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> bufferSize = <span class=\"number\">4096</span>;  \t<span class=\"comment\">// 缓冲区大小，单位byte</span></span><br><span class=\"line\">        <span class=\"type\">char</span> buffer[bufferSize];             <span class=\"comment\">// 接收文件内容的缓冲区，实际开发中，一般在1000～5000之间。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fileSize - totalByte &gt; bufferSize) &#123;</span><br><span class=\"line\">                onRead = bufferSize;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                onRead = fileSize - totalByte;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">recv</span>(buffer, onRead)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            fout.<span class=\"built_in\">write</span>(buffer, onRead);</span><br><span class=\"line\"></span><br><span class=\"line\">            totalByte += onRead;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (totalByte == fileSize) &#123;</span><br><span class=\"line\">                fout.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">closeListen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listen_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;not listening&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(listen_sock);</span><br><span class=\"line\">        listen_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">closeClient</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;not listening&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(client_sock);</span><br><span class=\"line\">        client_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取string格式的ip地址</span></span><br><span class=\"line\">    [[nodiscard]] <span class=\"function\"><span class=\"type\">const</span> string &amp;<span class=\"title\">clientip</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> client_ip;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">tcpServer tcp_server;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fatherEXIT</span><span class=\"params\">(<span class=\"type\">int</span> sig)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 以下代码是为了防止信号处理函数在执行过程中再次被信号中断</span></span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGINT, SIG_IGN);</span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGTERM, SIG_IGN);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;父进程退出： &quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">kill</span>(<span class=\"number\">0</span>, SIGTERM);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ---------------在这里增加释放资源的代码---------------</span></span><br><span class=\"line\">    tcp_server.<span class=\"built_in\">closeListen</span>();</span><br><span class=\"line\">    <span class=\"comment\">// --------------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">childEXIT</span><span class=\"params\">(<span class=\"type\">int</span> sig)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGINT, SIG_IGN);</span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGTERM, SIG_IGN);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;子进程退出： &quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ------在这里增加释放资源的代码（只释放子进程的资源）------</span></span><br><span class=\"line\">    tcp_server.<span class=\"built_in\">closeClient</span>();       <span class=\"comment\">// 信号处理函数中只能访问全局对象，tcp_server必须定义为全局变量</span></span><br><span class=\"line\">    <span class=\"comment\">// --------------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">initServer</span>(<span class=\"number\">5005</span>)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;initsServer() failed&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 忽略全部信号，不希望被打扰。顺便解决僵尸进程的问题</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">64</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">signal</span>(i, SIG_IGN);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 设置信号，在shell下可以用 &#x27;kill 进程号&#x27; 和 &#x27;Ctrl+C&#x27; 正常终止这些线程</span></span><br><span class=\"line\">    <span class=\"comment\">// 但请不要用 &#x27;kill -9 进程号&#x27; 强行终止线程</span></span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGTERM, fatherEXIT);</span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGINT, fatherEXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 受理(监听)客户端的连接，从已连接的客户端中取出一个客户端</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果没有已连接的客户端，accept函数将阻塞等待</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">accept</span>()) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;accept failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;client connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> pid = fork();</span><br><span class=\"line\">        <span class=\"comment\">// 系统资源不足</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pid == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;fork&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pid &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            tcp_server.<span class=\"built_in\">closeClient</span>();           <span class=\"comment\">// 多进程下，服务器父进程不需要客户端的socket，关闭</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;           <span class=\"comment\">// 父进程返回循环开始位置，继续受理客户端连接</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tcp_server.<span class=\"built_in\">closeListen</span>();           <span class=\"comment\">// 子进程不需要监听socket，关闭</span></span><br><span class=\"line\">        <span class=\"comment\">// 子进程需要重新设置信号</span></span><br><span class=\"line\">        <span class=\"built_in\">signal</span>(SIGTERM, childEXIT);         <span class=\"comment\">// 使用kill命令终止进程时，会产生SIGTERM信号，执行childEXIT函数</span></span><br><span class=\"line\">        <span class=\"built_in\">signal</span>(SIGINT, childEXIT);          <span class=\"comment\">// 按下ctrl+c会触发SIGINT信号，执行childEXIT函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 接收文件</span></span><br><span class=\"line\">        <span class=\"comment\">// 接收客户端发来的文件信息</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">fileInfo</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> fileName[<span class=\"number\">256</span>];     <span class=\"comment\">// 文件名</span></span><br><span class=\"line\">            <span class=\"type\">int</span> fileSize;           <span class=\"comment\">// 文件大小</span></span><br><span class=\"line\">        &#125; fileinfo;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(&amp;fileinfo, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(fileinfo));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">recv</span>(&amp;fileinfo, <span class=\"built_in\">sizeof</span>(fileinfo))) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;fileInfo receive failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(fileinfo.fileName, <span class=\"string\">&quot;test(1).txt&quot;</span>);</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;received: fileName: &quot;</span> &lt;&lt; fileinfo.fileName &lt;&lt; <span class=\"string\">&quot;  fileSize: &quot;</span> &lt;&lt; fileinfo.fileSize &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 给客户端发送确认报文</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">send</span>(<span class=\"string\">&quot;OK&quot;</span>)) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;send error&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 接收文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">receiveFile</span>(fileinfo.fileName, fileinfo.fileSize)) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;received file error&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;file receive success&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 给客户端发送确认报文</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">send</span>(<span class=\"string\">&quot;OK&quot;</span>)) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;send &#x27;OK&#x27; failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;           <span class=\"comment\">// 子进程通信完成后一定要退出，否则就会回到accept()函数的位置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"基本函数和结构体\">基本函数和结构体</h3>\n<ol>\n<li>\n<p>创建socket<br>\n<code>int socket(int domain, int type, int protocol)</code><br>\n成功返回<code>0</code>；失败返回<code>-1</code>，同时设置错误代码<code>errno</code>。<br>\n单个进程能够创建<code>socket</code>连接的数量受系统参数<code>open files</code>的限制（使用<code>ulimit -a</code>查看）。因为<code>socket</code>在<code>Linux</code>中也是文件</p>\n<ul>\n<li><code>domain</code>:通信协议族\n<ul>\n<li><code>PF_INET</code>:<code>ipv4</code>协议族</li>\n<li><code>PF_INET6</code>:<code>ipv6</code>协议族</li>\n<li><code>PF_LOCAL</code>:本地通信的协议族</li>\n<li><code>PF_PACKET</code>:内核底层的协议族</li>\n<li><code>PF_IPX</code>:<code>IPX Novel</code>协议族</li>\n<li>其余协议族不常用</li>\n</ul>\n</li>\n<li><code>type</code>:数据传输的类型\n<ul>\n<li><code>SOCK_STREAM</code>:面向连接的<code>socket</code>，\n<ul>\n<li>数据不会丢失</li>\n<li>数据顺序不会错乱</li>\n<li>双向通道</li>\n</ul>\n</li>\n<li><code>SOCK_DGRAM</code>:无连接的<code>socket</code>，\n<ul>\n<li>传输效率更高</li>\n<li>数据可能丢失</li>\n<li>数据顺序可能错乱</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>protocal</code>:最终使用的协议\n<ul>\n<li>在<code>ipv4</code>协议族中，数据传输方式为<code>SOCK_STREAM</code>的协议只有<code>IPPROTO_TCP</code>，数据传输方式为<code>SOCK_DGRAM</code>的协议只有<code>IPPROTO_UDP</code>.</li>\n<li>该参数也可以为0</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>TCP</code>和<code>UDP</code>.[[TCP协议和UDP协议]]</p>\n</li>\n<li>\n<p>主机字节序和网络字节序</p>\n<ul>\n<li>主机字节序：分为<strong>大端序</strong>和<strong>小端序</strong>。<br>\n每个地址内放<code>1Byte</code>（<code>8bit</code>），大端序和小端序讨论多个字节(<code>Byte</code>)的地址高低问题\n<ul>\n<li>大端序：<mark>低高高低</mark>.<br>\n<mark>低位</mark><code>Byte</code>存放在<mark>高位</mark>，<mark>高位</mark><code>Byte</code>存放在<mark>低位</mark>.</li>\n<li>小端序：<mark>低低高高</mark>.<br>\n<mark>低位</mark><code>Byte</code>存放在<mark>低位</mark>，<mark>高位</mark><code>Byte</code>存放在<mark>高位</mark>.<br>\n<img src=\"image/Pasted_image_20250610210518.png\" alt=\"image\" style=\"zoom:80%;\" /><br>\n总结：<strong>大端序按照原来顺序存储，小端序按字节颠倒顺序存储</strong>。</li>\n<li>造成的问题：同样的数据，大端序的计算机和小端序的计算机解析方式不同，那么得到的内容也不一样。在网络传输中，容易出现问题。</li>\n</ul>\n</li>\n<li><strong>网络字节序（大端序）</strong>：解决不同字节序的计算机之间传输数据的问题<br>\nC语言提供了四个函数用于网络字节序和主机字节序的转换：\n<ul>\n<li><code>uint16_t htons(uint16_t hostshort)</code>:将16位的整数从<em>主机字节序</em>转换为<em>网络字节序</em>。</li>\n<li><code>uint32_t htonl(uint32_t hostlong)</code>:将32位的整数从<em>主机字节序</em>转换为<em>网络字节序</em>。</li>\n<li><code>uint16_t stohs(uint16_t netshort)</code>:将16位的整数从<em>网络字节序</em>转换为<em>主机在字节序</em>。</li>\n<li><code>uint32_t stohl(uint32_t netlong)</code>:将32位的整数从<em>网络字节序</em>转换为<em>主机字节序</em>。<br>\n<code>h: host</code>主机<br>\n<code>n: net</code>网络<br>\n<code>s: short</code>2字节，16位的整数<br>\n<code>l: long</code>4字节，32位的整数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code> ip</code>地址和通讯端口<code>port</code>.<br>\n<code>ipv4</code>地址用4字节(<code>32bit</code>)的整数存放，<code>port</code>用2字节(<code>16bit</code>)的整数存放（0～65535）。<br>\n为什么不用字符串？<br>\n因为<code>192.168.190.134</code>用字符串存储需要15字节，而用整数存储只需要4个字节：3232284294。（<strong>思考<code>ipv4</code>地址最大只能到<code>255.255.255.255</code></strong>）</p>\n</li>\n<li>\n<p>万恶的结构体<br>\n因为平时用到的<code>ip</code>地址都是字符串类型的，而程序中存储的是<code>int</code>类型那么就需要将字符串类型的ip转换为int型ip。主要涉及三个结构体和一个函数</p>\n<ol>\n<li>\n<p><code>sockaddr</code>结构体<br>\n存储协议族、端口、地址信息。客户端的<code>connetc</code>函数和服务端的<code>bind</code>函数都要用到这个结构体。其定义类似下图：</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">short</span> <span class=\"type\">int</span> sa_family;   <span class=\"comment\">// 协议族</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> sa_data[<span class=\"number\">14</span>];  <span class=\"comment\">// 14字节的端口和地址</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>sockaddr_in</code>结构体<br>\n上方的<code>sockaddr</code>是为了统一地址结构的表示方法，统一接口函数。但是很难用，操作不方便。所以定义了等价的<code>sockaddr_in</code>结构体，其大小与<code>sockaddr</code>相同，可以强制转换。</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr_in</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">short</span> <span class=\"type\">int</span> sa_family;   <span class=\"comment\">// 协议族</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">short</span> sin_port;  <span class=\"comment\">// 16bit端口号</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">in_addr</span> sin_addr;  <span class=\"comment\">// 32bit的地址(只能存储ipv4的地址，不能存储ipv6。sockaddr中14个字节的char数组就是预留了ip地址扩展的空间)</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> sin_zero[<span class=\"number\">8</span>];<span class=\"comment\">// 未使用，为了保持与sockaddr长度相同而添加。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">in_addr</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> s_addr; <span class=\"comment\">// 32bit的ip地址，大端序</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>gethostbyname()</code>函数<br>\n根据域名、主机名、字符串<code>ip</code>地址获取大端存储的<code>int32</code>类型<code>ip</code>.</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hostent</span>* <span class=\"built_in\">gethostbyname</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* name);</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>hostent</code>结构体</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hostent</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* h_name; <span class=\"comment\">// 主机名</span></span><br><span class=\"line\">    <span class=\"type\">char</span>** h_aliases; <span class=\"comment\">// 主机所有别名构成的的字符串数组。（同一个ip可以绑定多个域名）</span></span><br><span class=\"line\">    <span class=\"type\">short</span> h_addrtype; <span class=\"comment\">// 主机ip地址的类型，如ipv4(AF_INET)还是ipv6</span></span><br><span class=\"line\">    <span class=\"type\">short</span> h_length; <span class=\"comment\">// 主机ip地址长度，ipv4为4(字节),ipv6为16(字节)</span></span><br><span class=\"line\">    <span class=\"type\">char</span>** h_addr_list; <span class=\"comment\">// 主机的ip地址，以网络字节序存储</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取<code>hostent</code>后，使用以下代码把大端序的地址复制到<code>sockaddr_in</code>结构体的<code>sin_addr</code>成员中</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sockaddr_in serveraddr;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hostent</span>* h = <span class=\"built_in\">gethostbyname</span>(<span class=\"string\">&quot;192.168.1.2&quot;</span>); </span><br><span class=\"line\"><span class=\"built_in\">memcpy</span>(&amp;serveraddr.sin_addr, h-&gt;h_addr_list, h-&gt;h_length);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li>\n<p>字符串<code>ip</code>转大端序<code>ip</code>.<br>\nC语言提供了几个库函数，用于字符串<code>ip</code>和大端序<code>ip</code>的相互转换。通常用于网络通讯的服务端程序中。</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> uint32;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把字符串格式的ip转换成大端序的ip，转换后的ip应该赋值给 sockaddr_in.in_addr.s_addr。不能传入域名</span></span><br><span class=\"line\"><span class=\"function\">uint_32 <span class=\"title\">inet_addr</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* cp)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将字符串格式的ip转换为大端序的ip，转换后的ip直接填充到sockaddr_in.in_addr成员（不需要手动填充）。不能传入域名 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">inet_aton</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* cp, <span class=\"keyword\">struct</span> int_addr * inp)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将大端序ip转换为字符串格式的ip。用于在服务器程序中解析客户端的ip地址  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">char</span>* <span class=\"title\">inet_ntoa</span><span class=\"params\">(<span class=\"keyword\">struct</span> in_addr in)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>bind</code>函数<br>\n绑定服务端的<code>ip</code>和端口，失败返回-1</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr</span> server_addr;</span><br><span class=\"line\"><span class=\"built_in\">bind</span>(listenfd, (<span class=\"keyword\">struct</span> sockaddr *)&amp;server_addr, <span class=\"built_in\">sizeof</span>(server_addr))</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>lieten</code>函数<br>\n把socket设置为可连接(监听)的状态，失败返回-1<br>\n<code>listen(listenfd, 5)</code></p>\n</li>\n</ol>\n<h3 id=\"封装socket客户端\">封装socket客户端</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">tcpClient</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> client_sock;        <span class=\"comment\">// 客户端socket，-1表示未连接或者已断开。&gt;=0表示有效的socket</span></span><br><span class=\"line\">    string ip;              <span class=\"comment\">// 服务端的ip或域名</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">short</span> port;    <span class=\"comment\">// 通讯端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">tcpClient</span>() : <span class=\"built_in\">client_sock</span>(<span class=\"number\">-1</span>), <span class=\"built_in\">port</span>(<span class=\"number\">-1</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">tcpClient</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">close</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @param in_ip 客户端ip/域名</span></span><br><span class=\"line\"><span class=\"comment\">     * @param in_port 端口号</span></span><br><span class=\"line\"><span class=\"comment\">     * @return 成功返回true，失败返回false</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">connect_to</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;in_ip, <span class=\"type\">const</span> <span class=\"type\">unsigned</span> <span class=\"type\">short</span> in_port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: sock connect is already exist&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 保存服务端ip和端口号</span></span><br><span class=\"line\">        ip = in_ip;</span><br><span class=\"line\">        port = in_port;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建客户端Socket</span></span><br><span class=\"line\">        client_sock = <span class=\"built_in\">socket</span>(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;创建Socket失败&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 配置服务器地址</span></span><br><span class=\"line\">        sockaddr_in server_addr&#123;&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(&amp;server_addr, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(server_addr));</span><br><span class=\"line\">        server_addr.sin_family = AF_INET;</span><br><span class=\"line\">        server_addr.sin_port = <span class=\"built_in\">htons</span>(port);</span><br><span class=\"line\">        <span class=\"comment\">// server_addr.sin_addr.s_addr = inet_addr(in_ip.c_str());      // 该方法只能用ip，不能用域名</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">hostent</span> *h;          <span class=\"comment\">// 用于存放服务端的大端序ip的结构体的指针</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((h = <span class=\"built_in\">gethostbyname</span>(ip.<span class=\"built_in\">c_str</span>())) == <span class=\"literal\">nullptr</span>)      <span class=\"comment\">// 把域名、主机名、字符串格式的ip转换为结构体，存储在h中</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ::<span class=\"built_in\">close</span>(client_sock);     <span class=\"comment\">// 关闭sock连接</span></span><br><span class=\"line\">            client_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(&amp;server_addr.sin_addr, h-&gt;h_addr, h-&gt;h_length);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 连接服务器</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">connect</span>(client_sock, (sockaddr *) &amp;server_addr, <span class=\"built_in\">sizeof</span>(server_addr)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;连接服务器失败&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            ::<span class=\"built_in\">close</span>(client_sock);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;msg)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 参数使用string，不使用const char*，因为const char*</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: not connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 或者：if (send(client_sock, msg.c_str(), msg.length(), 0))      // 语义不准确：buffer可以是string，也可以是一块内存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (::<span class=\"built_in\">send</span>(client_sock, msg.<span class=\"built_in\">data</span>(), msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: send failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * @param msg 存放接收到的内容</span></span><br><span class=\"line\"><span class=\"comment\">     * @param maxLen 接收的最大长度</span></span><br><span class=\"line\"><span class=\"comment\">     * @return</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">receive</span><span class=\"params\">(string &amp;msg, <span class=\"type\">const</span> <span class=\"type\">size_t</span> maxLen)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: not connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.<span class=\"built_in\">clear</span>();        <span class=\"comment\">// 清空容器</span></span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(maxLen);     <span class=\"comment\">// 设置容器大小</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果直接操作string对象的内存，需要保证两点：</span></span><br><span class=\"line\"><span class=\"comment\">         *      1. 不能越界</span></span><br><span class=\"line\"><span class=\"comment\">         *      2. 操作后需要手动设置string的大小（resize函数）。(因为直接操作string对象的内存后，string对象自动管理内存的功能就会失效)</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * 传地址除了使用msg[0]，还可以使用msg.c_str()，msg.data()。</span></span><br><span class=\"line\"><span class=\"comment\">         * 但是后两种获取到的都是const类型，无法修改，而recv函数需要将收到的数据写入msg中</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"type\">int</span> read_byte_number = ::<span class=\"built_in\">recv</span>(client_sock, &amp;msg[<span class=\"number\">0</span>], msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>); <span class=\"comment\">// 返回接收数据的大小，-1表示失败，0表示sock已断开</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read_byte_number &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: receive failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            msg.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(read_byte_number);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: not connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ::<span class=\"built_in\">close</span>(client_sock);</span><br><span class=\"line\"></span><br><span class=\"line\">        client_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;------------------- client start -------------------&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    tcpClient tcp_client;</span><br><span class=\"line\">    string ip = <span class=\"string\">&quot;127.0.0.1&quot;</span>;</span><br><span class=\"line\">    string port = <span class=\"string\">&quot;5005&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_client.<span class=\"built_in\">connect_to</span>(ip, <span class=\"built_in\">atoi</span>(port.<span class=\"built_in\">c_str</span>()))) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>((<span class=\"string\">&quot;connect to &quot;</span> + ip + <span class=\"string\">&quot;:&quot;</span> + port + <span class=\"string\">&quot; failed&quot;</span>).<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">char</span> msg[<span class=\"number\">1024</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> iret;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(msg, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(msg));</span><br><span class=\"line\">        <span class=\"built_in\">sprintf</span>(msg, <span class=\"string\">&quot;test message %d&quot;</span>, i + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 向服务端发送请求报文</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_client.<span class=\"built_in\">send</span>(msg)) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> errormsg[<span class=\"number\">32</span>];</span><br><span class=\"line\">            <span class=\"built_in\">sprintf</span>(errormsg, <span class=\"string\">&quot;message %d send failed&quot;</span>, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(errormsg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;send: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">        string received_message;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_client.<span class=\"built_in\">receive</span>(received_message, <span class=\"number\">1024</span>)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;received failed&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;received: &quot;</span> &lt;&lt; received_message &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"封装socket服务端\">封装socket服务端</h3>\n<h4 id=\"单进程单线程服务端\">单进程单线程服务端</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">tcpServer</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> listen_sock;            <span class=\"comment\">// 用于监听的socket。-1表示未初始化</span></span><br><span class=\"line\">    <span class=\"type\">int</span> client_sock;            <span class=\"comment\">// 客户端连上的的socket，用于和客户端通信。-1表示客户端未连接。</span></span><br><span class=\"line\">    string client_ip;           <span class=\"comment\">// 客户端的ip</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">short</span> port;        <span class=\"comment\">// 服务端用于通讯的端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">tcpServer</span>() : <span class=\"built_in\">listen_sock</span>(<span class=\"number\">-1</span>), <span class=\"built_in\">client_sock</span>(<span class=\"number\">-1</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">tcpServer</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listen_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">closeListen</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">closeClient</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">initServer</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">unsigned</span> <span class=\"type\">short</span> &amp;in_port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化服务端用于监听的socket</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((listen_sock = <span class=\"built_in\">socket</span>(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR socket init failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        port = in_port;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将服务端用于通信的ip和端口绑定到socket上</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr_in</span> server_addr;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(&amp;server_addr, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(server_addr));</span><br><span class=\"line\">        server_addr.sin_family = AF_INET;                       <span class=\"comment\">// 协议</span></span><br><span class=\"line\">        server_addr.sin_port = <span class=\"built_in\">htons</span>(port);                     <span class=\"comment\">// 指定服务端的通信端口</span></span><br><span class=\"line\">        server_addr.sin_addr.s_addr = <span class=\"built_in\">htonl</span>(INADDR_ANY);        <span class=\"comment\">// 如果操作系统有多个ip，则多个ip都可以用于通信</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 为socket绑定ip和端口</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">bind</span>(listen_sock, (<span class=\"keyword\">struct</span> sockaddr *) &amp;server_addr, <span class=\"built_in\">sizeof</span>(server_addr)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR socket bind failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"built_in\">close</span>(listen_sock);</span><br><span class=\"line\">            listen_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">listen</span>(listen_sock, <span class=\"number\">5</span>)) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR listening start failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">accept</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr_in</span> client_addr;             <span class=\"comment\">// 客户端的地址信息</span></span><br><span class=\"line\">        <span class=\"type\">socklen_t</span> addrlen = <span class=\"built_in\">sizeof</span>(client_addr);    <span class=\"comment\">// struct sockaddr_in的大小</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意accept函数的第三个参数是指针：因为accept函数需要将实际接收到的消息长度写回addrlen</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((client_sock = ::<span class=\"built_in\">accept</span>(listen_sock, (<span class=\"keyword\">struct</span> sockaddr *) &amp;client_addr, &amp;addrlen)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;accept failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        client_ip = <span class=\"built_in\">inet_ntoa</span>(client_addr.sin_addr);          <span class=\"comment\">// 将客户端的代码从大端序转换为字符串</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;socket no connected&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((::<span class=\"built_in\">send</span>(client_sock, msg.<span class=\"built_in\">data</span>(), msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>) &lt;= <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;send message failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">recv</span><span class=\"params\">(string &amp;msg, <span class=\"type\">const</span> <span class=\"type\">size_t</span> maxLen)</span> </span>&#123;</span><br><span class=\"line\">        msg.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(maxLen);</span><br><span class=\"line\">        <span class=\"type\">int</span> read_byte_number = ::<span class=\"built_in\">recv</span>(client_sock, &amp;msg[<span class=\"number\">0</span>], msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read_byte_number &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            msg.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;receive failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(read_byte_number);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">closeListen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listen_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;not listening&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(listen_sock);</span><br><span class=\"line\">        listen_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">closeClient</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;not listening&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(client_sock);</span><br><span class=\"line\">        client_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取string格式的ip地址</span></span><br><span class=\"line\">    [[nodiscard]] <span class=\"function\"><span class=\"type\">const</span> string &amp;<span class=\"title\">clientip</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> client_ip;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    tcpServer tcp_server;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">initServer</span>(<span class=\"number\">5005</span>)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;initsServer() failed&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">accept</span>()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;accept failed&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;client connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    string msg;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 接收客户端发来的报文，如果客户端没有发来报文，recv将阻塞等待</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">recv</span>(msg, <span class=\"number\">1024</span>)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;receive failed&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;received: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">        msg = <span class=\"string\">&quot;OK&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 向客户端发送报文</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">send</span>(msg)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;send failed&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;send: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"多进程服务端\">多进程服务端</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;csignal&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">tcpServer</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> listen_sock;            <span class=\"comment\">// 用于监听的socket。-1表示未初始化</span></span><br><span class=\"line\">    <span class=\"type\">int</span> client_sock;            <span class=\"comment\">// 客户端连上的的socket，用于和客户端通信。-1表示客户端未连接。</span></span><br><span class=\"line\">    string client_ip;           <span class=\"comment\">// 客户端的ip</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">short</span> port;        <span class=\"comment\">// 服务端用于通讯的端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">tcpServer</span>() : <span class=\"built_in\">listen_sock</span>(<span class=\"number\">-1</span>), <span class=\"built_in\">client_sock</span>(<span class=\"number\">-1</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">tcpServer</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listen_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">closeListen</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">closeClient</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">initServer</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">unsigned</span> <span class=\"type\">short</span> &amp;in_port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化服务端用于监听的socket</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((listen_sock = <span class=\"built_in\">socket</span>(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR socket init failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        port = in_port;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将服务端用于通信的ip和端口绑定到socket上</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr_in</span> server_addr;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(&amp;server_addr, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(server_addr));</span><br><span class=\"line\">        server_addr.sin_family = AF_INET;                       <span class=\"comment\">// 协议</span></span><br><span class=\"line\">        server_addr.sin_port = <span class=\"built_in\">htons</span>(port);                     <span class=\"comment\">// 指定服务端的通信端口</span></span><br><span class=\"line\">        server_addr.sin_addr.s_addr = <span class=\"built_in\">htonl</span>(INADDR_ANY);        <span class=\"comment\">// 如果操作系统有多个ip，则多个ip都可以用于通信</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 为socket绑定ip和端口</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">bind</span>(listen_sock, (<span class=\"keyword\">struct</span> sockaddr *) &amp;server_addr, <span class=\"built_in\">sizeof</span>(server_addr)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR socket bind failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"built_in\">close</span>(listen_sock);</span><br><span class=\"line\">            listen_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">listen</span>(listen_sock, <span class=\"number\">5</span>)) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR listening start failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">accept</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr_in</span> client_addr;             <span class=\"comment\">// 客户端的地址信息</span></span><br><span class=\"line\">        <span class=\"type\">socklen_t</span> addrlen = <span class=\"built_in\">sizeof</span>(client_addr);    <span class=\"comment\">// struct sockaddr_in的大小</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意accept函数的第三个参数是指针：因为accept函数需要将实际接收到的消息长度写回addrlen</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((client_sock = ::<span class=\"built_in\">accept</span>(listen_sock, (<span class=\"keyword\">struct</span> sockaddr *) &amp;client_addr, &amp;addrlen)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;accept failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        client_ip = <span class=\"built_in\">inet_ntoa</span>(client_addr.sin_addr);          <span class=\"comment\">// 将客户端的代码从大端序转换为字符串</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;socket no connected&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((::<span class=\"built_in\">send</span>(client_sock, msg.<span class=\"built_in\">data</span>(), msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>) &lt;= <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;send message failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">recv</span><span class=\"params\">(string &amp;msg, <span class=\"type\">const</span> <span class=\"type\">size_t</span> maxLen)</span> </span>&#123;</span><br><span class=\"line\">        msg.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(maxLen);</span><br><span class=\"line\">        <span class=\"type\">int</span> read_byte_number = ::<span class=\"built_in\">recv</span>(client_sock, &amp;msg[<span class=\"number\">0</span>], msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read_byte_number &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            msg.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;receive failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(read_byte_number);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">closeListen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listen_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;not listening&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(listen_sock);</span><br><span class=\"line\">        listen_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">closeClient</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;not listening&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(client_sock);</span><br><span class=\"line\">        client_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取string格式的ip地址</span></span><br><span class=\"line\">    [[nodiscard]] <span class=\"function\"><span class=\"type\">const</span> string &amp;<span class=\"title\">clientip</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> client_ip;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">tcpServer tcp_server;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fatherEXIT</span><span class=\"params\">(<span class=\"type\">int</span> sig)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 以下代码是为了防止信号处理函数在执行过程中再次被信号中断</span></span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGINT, SIG_IGN);</span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGTERM, SIG_IGN);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;父进程退出： &quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">kill</span>(<span class=\"number\">0</span>, SIGTERM);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ---------------在这里增加释放资源的代码---------------</span></span><br><span class=\"line\">    tcp_server.<span class=\"built_in\">closeListen</span>();</span><br><span class=\"line\">    <span class=\"comment\">// --------------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">childEXIT</span><span class=\"params\">(<span class=\"type\">int</span> sig)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGINT, SIG_IGN);</span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGTERM, SIG_IGN);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;子进程退出： &quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ------在这里增加释放资源的代码（只释放子进程的资源）------</span></span><br><span class=\"line\">    tcp_server.<span class=\"built_in\">closeClient</span>();       <span class=\"comment\">// 信号处理函数中只能访问全局对象，tcp_server必须定义为全局变量</span></span><br><span class=\"line\">    <span class=\"comment\">// --------------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">initServer</span>(<span class=\"number\">5005</span>)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;initsServer() failed&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 忽略全部信号，不希望被打扰。顺便解决僵尸进程的问题</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">64</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">signal</span>(i, SIG_IGN);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 设置信号，在shell下可以用 &#x27;kill 进程号&#x27; 和 &#x27;Ctrl+C&#x27; 正常终止这些线程</span></span><br><span class=\"line\">    <span class=\"comment\">// 但请不要用 &#x27;kill -9 进程号&#x27; 强行终止线程</span></span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGTERM, fatherEXIT);</span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGINT, fatherEXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 受理(监听)客户端的连接，从已连接的客户端中取出一个客户端</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果没有已连接的客户端，accept函数将阻塞等待</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">accept</span>()) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;accept failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;client connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> pid = fork();</span><br><span class=\"line\">        <span class=\"comment\">// 系统资源不足</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pid == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;fork&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pid &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            tcp_server.<span class=\"built_in\">closeClient</span>();           <span class=\"comment\">// 多进程下，服务器父进程不需要客户端的socket，关闭</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;           <span class=\"comment\">// 父进程返回循环开始位置，继续受理客户端连接</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tcp_server.<span class=\"built_in\">closeListen</span>();           <span class=\"comment\">// 子进程不需要监听socket，关闭</span></span><br><span class=\"line\">        <span class=\"comment\">// 子进程需要重新设置信号</span></span><br><span class=\"line\">        <span class=\"built_in\">signal</span>(SIGTERM, childEXIT);         <span class=\"comment\">// 使用kill命令终止进程时，会产生SIGTERM信号，执行childEXIT函数</span></span><br><span class=\"line\">        <span class=\"built_in\">signal</span>(SIGINT, childEXIT);          <span class=\"comment\">// 按下ctrl+c会触发SIGINT信号，执行childEXIT函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 子进程负责与客户端进行通讯</span></span><br><span class=\"line\">        string msg;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 接收客户端发来的报文，如果客户端没有发来报文，recv将阻塞等待</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">recv</span>(msg, <span class=\"number\">1024</span>)) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;receive failed&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cout &lt;&lt; <span class=\"string\">&quot;received: &quot;</span> &lt;&lt; msg &lt;&lt; <span class=\"string\">&quot;------thread id: &quot;</span> &lt;&lt; <span class=\"built_in\">getpid</span>() &lt;&lt; endl;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            msg = <span class=\"string\">&quot;OK&quot;</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 向客户端发送报文</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">send</span>(msg)) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;send failed&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cout &lt;&lt; <span class=\"string\">&quot;send: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;           <span class=\"comment\">// 子进程通信完成后一定要退出，否则就会回到accept()函数的位置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"文件传输\">文件传输</h4>\n<h5 id=\"客户端\">客户端</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">tcpClient</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> client_sock;        <span class=\"comment\">// 客户端socket，-1表示未连接或者已断开。&gt;=0表示有效的socket</span></span><br><span class=\"line\">    string ip;              <span class=\"comment\">// 服务端的ip或域名</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">short</span> port;    <span class=\"comment\">// 通讯端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">tcpClient</span>() : <span class=\"built_in\">client_sock</span>(<span class=\"number\">-1</span>), <span class=\"built_in\">port</span>(<span class=\"number\">-1</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">tcpClient</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">close</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @param in_ip 客户端ip/域名</span></span><br><span class=\"line\"><span class=\"comment\">     * @param in_port 端口号</span></span><br><span class=\"line\"><span class=\"comment\">     * @return 成功返回true，失败返回false</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">connect_to</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;in_ip, <span class=\"type\">const</span> <span class=\"type\">unsigned</span> <span class=\"type\">short</span> in_port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: sock connect is already exist&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 保存服务端ip和端口号</span></span><br><span class=\"line\">        ip = in_ip;</span><br><span class=\"line\">        port = in_port;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建客户端Socket</span></span><br><span class=\"line\">        client_sock = <span class=\"built_in\">socket</span>(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;创建Socket失败&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 配置服务器地址</span></span><br><span class=\"line\">        sockaddr_in server_addr&#123;&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(&amp;server_addr, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(server_addr));</span><br><span class=\"line\">        server_addr.sin_family = AF_INET;</span><br><span class=\"line\">        server_addr.sin_port = <span class=\"built_in\">htons</span>(port);</span><br><span class=\"line\">        <span class=\"comment\">// server_addr.sin_addr.s_addr = inet_addr(in_ip.c_str());      // 该方法只能用ip，不能用域名</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">hostent</span> *h;          <span class=\"comment\">// 用于存放服务端的大端序ip的结构体的指针</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((h = <span class=\"built_in\">gethostbyname</span>(ip.<span class=\"built_in\">c_str</span>())) == <span class=\"literal\">nullptr</span>)      <span class=\"comment\">// 把域名、主机名、字符串格式的ip转换为结构体，存储在h中</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ::<span class=\"built_in\">close</span>(client_sock);     <span class=\"comment\">// 关闭sock连接</span></span><br><span class=\"line\">            client_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(&amp;server_addr.sin_addr, h-&gt;h_addr, h-&gt;h_length);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 连接服务器</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">connect</span>(client_sock, (sockaddr *) &amp;server_addr, <span class=\"built_in\">sizeof</span>(server_addr)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;连接服务器失败&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            ::<span class=\"built_in\">close</span>(client_sock);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;msg)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 参数使用string，不使用const char*，因为const char*</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: not connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 或者：if (send(client_sock, msg.c_str(), msg.length(), 0))      // 语义不准确：buffer可以是string，也可以是一块内存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (::<span class=\"built_in\">send</span>(client_sock, msg.<span class=\"built_in\">data</span>(), msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: send failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 用于传输二进制</span></span><br><span class=\"line\"><span class=\"comment\">     * @param msg 要传输的数据（可以是结构体）</span></span><br><span class=\"line\"><span class=\"comment\">     * @param size 数据大小</span></span><br><span class=\"line\"><span class=\"comment\">     * @return</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"type\">void</span> *msg, <span class=\"type\">const</span> <span class=\"type\">size_t</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 参数使用string，不使用const char*，因为const char*</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: not connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 或者：if (send(client_sock, msg.c_str(), msg.length(), 0))      // 语义不准确：buffer可以是string，也可以是一块内存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (::<span class=\"built_in\">send</span>(client_sock, msg, size, <span class=\"number\">0</span>) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: send failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">sendFile</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;filePath, <span class=\"type\">const</span> <span class=\"type\">size_t</span> fileSize)</span> </span>&#123;</span><br><span class=\"line\">        ifstream fin;</span><br><span class=\"line\">        fin.<span class=\"built_in\">open</span>(filePath, ios::in | ios::binary);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!fin.<span class=\"built_in\">is_open</span>()) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;file open failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> onRead = <span class=\"number\">0</span>;         <span class=\"comment\">// 每次调用 fin.read() 打算读取的字节数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> totalByte = <span class=\"number\">0</span>;      <span class=\"comment\">// 从文件中已读取的总字节数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> bufferSize = <span class=\"number\">4096</span>;  <span class=\"comment\">// 缓冲区大小，单位byte</span></span><br><span class=\"line\">        <span class=\"type\">char</span> buffer[bufferSize];         <span class=\"comment\">// 存放读取数据的buffer。实际开发中，一般在1000～5000之间。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">memset</span>(buffer, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(buffer));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fileSize - totalByte &gt; bufferSize) &#123;</span><br><span class=\"line\">                onRead = bufferSize;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                onRead = fileSize - totalByte;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            fin.<span class=\"built_in\">read</span>(buffer, onRead);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">send</span>(buffer, onRead)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            totalByte += onRead;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (totalByte == fileSize) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        fin.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * @param msg 存放接收到的内容</span></span><br><span class=\"line\"><span class=\"comment\">     * @param maxLen 接收的最大长度</span></span><br><span class=\"line\"><span class=\"comment\">     * @return</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">receive</span><span class=\"params\">(string &amp;msg, <span class=\"type\">const</span> <span class=\"type\">size_t</span> maxLen)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: not connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.<span class=\"built_in\">clear</span>();        <span class=\"comment\">// 清空容器</span></span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(maxLen);     <span class=\"comment\">// 设置容器大小</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果直接操作string对象的内存，需要保证亮点：</span></span><br><span class=\"line\"><span class=\"comment\">         *      1. 不能越界</span></span><br><span class=\"line\"><span class=\"comment\">         *      2. 操作后需要手动设置string的大小（resize函数）。(因为直接操作string对象的内存后，string对象自动管理内存的功能就会失效)</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * 传地址除了使用msg[0]，还可以使用msg.c_str()，msg.data()。</span></span><br><span class=\"line\"><span class=\"comment\">         * 但是后两种获取到的都是const类型，无法修改，而recv函数需要将收到的数据写入msg中</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"type\">int</span> read_byte_number = ::<span class=\"built_in\">recv</span>(client_sock, &amp;msg[<span class=\"number\">0</span>], msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>); <span class=\"comment\">// 返回接收数据的大小，-1表示失败，0表示sock已断开</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read_byte_number &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: receive failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            msg.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(read_byte_number);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: not connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ::<span class=\"built_in\">close</span>(client_sock);</span><br><span class=\"line\"></span><br><span class=\"line\">        client_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过stat结构体 获得文件大小，单位字节</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">getFileSize</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *fileName)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fileName == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这是一个存储文件(夹)信息的结构体，其中有文件大小和创建时间、访问时间、修改时间等</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">stat</span> statbuf;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 提供文件名字符串，获得文件属性结构体</span></span><br><span class=\"line\">    <span class=\"built_in\">stat</span>(fileName, &amp;statbuf);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取文件大小</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> filesize = statbuf.st_size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> filesize;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;------------------- client start -------------------&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    tcpClient tcp_client;</span><br><span class=\"line\">    string ip = <span class=\"string\">&quot;127.0.0.1&quot;</span>;</span><br><span class=\"line\">    string port = <span class=\"string\">&quot;5005&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_client.<span class=\"built_in\">connect_to</span>(ip, <span class=\"built_in\">atoi</span>(port.<span class=\"built_in\">c_str</span>()))) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>((<span class=\"string\">&quot;connect to &quot;</span> + ip + <span class=\"string\">&quot;:&quot;</span> + port + <span class=\"string\">&quot; failed&quot;</span>).<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送文件</span></span><br><span class=\"line\">    <span class=\"comment\">// 把待传文件名和文件大小发送给服务端</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">fileInfo</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> fileName[<span class=\"number\">256</span>];     <span class=\"comment\">// 文件目录和文件名。与程序运行位置(工作目录)联系紧密，工作目录不同，fileName对应的路径也不同</span></span><br><span class=\"line\">        <span class=\"type\">int</span> fileSize;           <span class=\"comment\">// 文件大小</span></span><br><span class=\"line\">    &#125; fileinfo;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;fileinfo, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(fileInfo));</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(fileinfo.fileName, <span class=\"string\">&quot;test.txt&quot;</span>);</span><br><span class=\"line\">    fileinfo.fileSize = (<span class=\"type\">int</span>) <span class=\"built_in\">getFileSize</span>(fileinfo.fileName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_client.<span class=\"built_in\">send</span>(&amp;fileinfo, <span class=\"built_in\">sizeof</span>(fileinfo))) &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> errormsg[<span class=\"number\">32</span>];</span><br><span class=\"line\">        <span class=\"built_in\">sprintf</span>(errormsg, <span class=\"string\">&quot;fileInfo send failed&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(errormsg);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;发送文件信息: fileName: &quot;</span> &lt;&lt; fileinfo.fileName &lt;&lt; <span class=\"string\">&quot;  fileSize: &quot;</span> &lt;&lt; fileinfo.fileSize &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待服务端的确认</span></span><br><span class=\"line\">    string buffer;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_client.<span class=\"built_in\">receive</span>(buffer, <span class=\"number\">2</span>)) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;receive error&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buffer != <span class=\"string\">&quot;OK&quot;</span>) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;receive message error&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送文件给服务端</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_client.<span class=\"built_in\">sendFile</span>(fileinfo.fileName, fileinfo.fileSize)) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;file send error&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待服务端的确认</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_client.<span class=\"built_in\">receive</span>(buffer, <span class=\"number\">2</span>)) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;no &#x27;OK&#x27; received&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buffer != <span class=\"string\">&quot;OK&quot;</span>) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;ERROR receive&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;received &#x27;OK&#x27;&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"服务端\">服务端</h5>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;csignal&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">tcpServer</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> listen_sock;            <span class=\"comment\">// 用于监听的socket。-1表示未初始化</span></span><br><span class=\"line\">    <span class=\"type\">int</span> client_sock;            <span class=\"comment\">// 客户端连上的的socket，用于和客户端通信。-1表示客户端未连接。</span></span><br><span class=\"line\">    string client_ip;           <span class=\"comment\">// 客户端的ip</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">short</span> port;        <span class=\"comment\">// 服务端用于通讯的端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">tcpServer</span>() : <span class=\"built_in\">listen_sock</span>(<span class=\"number\">-1</span>), <span class=\"built_in\">client_sock</span>(<span class=\"number\">-1</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">tcpServer</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listen_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">closeListen</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">closeClient</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">initServer</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">unsigned</span> <span class=\"type\">short</span> &amp;in_port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化服务端用于监听的socket</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((listen_sock = <span class=\"built_in\">socket</span>(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR socket init failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        port = in_port;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将服务端用于通信的ip和端口绑定到socket上</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr_in</span> server_addr;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(&amp;server_addr, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(server_addr));</span><br><span class=\"line\">        server_addr.sin_family = AF_INET;                       <span class=\"comment\">// 协议</span></span><br><span class=\"line\">        server_addr.sin_port = <span class=\"built_in\">htons</span>(port);                     <span class=\"comment\">// 指定服务端的通信端口</span></span><br><span class=\"line\">        server_addr.sin_addr.s_addr = <span class=\"built_in\">htonl</span>(INADDR_ANY);        <span class=\"comment\">// 如果操作系统有多个ip，则多个ip都可以用于通信</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 为socket绑定ip和端口</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">bind</span>(listen_sock, (<span class=\"keyword\">struct</span> sockaddr *) &amp;server_addr, <span class=\"built_in\">sizeof</span>(server_addr)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR socket bind failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"built_in\">close</span>(listen_sock);</span><br><span class=\"line\">            listen_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">listen</span>(listen_sock, <span class=\"number\">5</span>)) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR listening start failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">accept</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr_in</span> client_addr;             <span class=\"comment\">// 客户端的地址信息</span></span><br><span class=\"line\">        <span class=\"type\">socklen_t</span> addrlen = <span class=\"built_in\">sizeof</span>(client_addr);    <span class=\"comment\">// struct sockaddr_in的大小</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意accept函数的第三个参数是指针：因为accept函数需要将实际接收到的消息长度写回addrlen</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((client_sock = ::<span class=\"built_in\">accept</span>(listen_sock, (<span class=\"keyword\">struct</span> sockaddr *) &amp;client_addr, &amp;addrlen)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;accept failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        client_ip = <span class=\"built_in\">inet_ntoa</span>(client_addr.sin_addr);          <span class=\"comment\">// 将客户端的代码从大端序转换为字符串</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;socket no connected&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((::<span class=\"built_in\">send</span>(client_sock, msg.<span class=\"built_in\">data</span>(), msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>) &lt;= <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;send message failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 存放接收到的字符串数据</span></span><br><span class=\"line\"><span class=\"comment\">     * @param msg</span></span><br><span class=\"line\"><span class=\"comment\">     * @param maxLen</span></span><br><span class=\"line\"><span class=\"comment\">     * @return</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">recv</span><span class=\"params\">(string &amp;msg, <span class=\"type\">const</span> <span class=\"type\">size_t</span> maxLen)</span> </span>&#123;</span><br><span class=\"line\">        msg.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(maxLen);</span><br><span class=\"line\">        <span class=\"type\">int</span> read_byte_number = ::<span class=\"built_in\">recv</span>(client_sock, &amp;msg[<span class=\"number\">0</span>], msg.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read_byte_number &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            msg.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;receive failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        msg.<span class=\"built_in\">resize</span>(read_byte_number);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 存放接收到的二进制数据</span></span><br><span class=\"line\"><span class=\"comment\">     * @param msg</span></span><br><span class=\"line\"><span class=\"comment\">     * @param maxLen</span></span><br><span class=\"line\"><span class=\"comment\">     * @return</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">recv</span><span class=\"params\">(<span class=\"type\">void</span> *msg, <span class=\"type\">const</span> <span class=\"type\">size_t</span> maxLen)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: not connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> read_byte_number = ::<span class=\"built_in\">recv</span>(client_sock, msg, maxLen, <span class=\"number\">0</span>); <span class=\"comment\">// 返回接收数据的大小，-1表示失败，0表示sock已断开</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read_byte_number &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;ERROR: receive failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 接收文件</span></span><br><span class=\"line\"><span class=\"comment\">     * @param filePath 文件路径和文件名</span></span><br><span class=\"line\"><span class=\"comment\">     * @param fileSize 文件大小</span></span><br><span class=\"line\"><span class=\"comment\">     * @return</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">receiveFile</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;filePath, <span class=\"type\">const</span> <span class=\"type\">size_t</span> fileSize)</span> </span>&#123;</span><br><span class=\"line\">        ofstream fout;</span><br><span class=\"line\">        fout.<span class=\"built_in\">open</span>(filePath, ios::binary | ios::out);</span><br><span class=\"line\">        fout&lt;&lt;<span class=\"string\">&quot;iii&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!fout.<span class=\"built_in\">is_open</span>()) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;file open failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> totalByte = <span class=\"number\">0</span>;          <span class=\"comment\">// 已接收文件的总字节数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> onRead = <span class=\"number\">0</span>;             <span class=\"comment\">// 本次打算接收的字节数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> bufferSize = <span class=\"number\">4096</span>;  \t<span class=\"comment\">// 缓冲区大小，单位byte</span></span><br><span class=\"line\">        <span class=\"type\">char</span> buffer[bufferSize];             <span class=\"comment\">// 接收文件内容的缓冲区，实际开发中，一般在1000～5000之间。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fileSize - totalByte &gt; bufferSize) &#123;</span><br><span class=\"line\">                onRead = bufferSize;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                onRead = fileSize - totalByte;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">recv</span>(buffer, onRead)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            fout.<span class=\"built_in\">write</span>(buffer, onRead);</span><br><span class=\"line\"></span><br><span class=\"line\">            totalByte += onRead;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (totalByte == fileSize) &#123;</span><br><span class=\"line\">                fout.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">closeListen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listen_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;not listening&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(listen_sock);</span><br><span class=\"line\">        listen_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">closeClient</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_sock == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;not listening&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(client_sock);</span><br><span class=\"line\">        client_sock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取string格式的ip地址</span></span><br><span class=\"line\">    [[nodiscard]] <span class=\"function\"><span class=\"type\">const</span> string &amp;<span class=\"title\">clientip</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> client_ip;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">tcpServer tcp_server;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fatherEXIT</span><span class=\"params\">(<span class=\"type\">int</span> sig)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 以下代码是为了防止信号处理函数在执行过程中再次被信号中断</span></span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGINT, SIG_IGN);</span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGTERM, SIG_IGN);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;父进程退出： &quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">kill</span>(<span class=\"number\">0</span>, SIGTERM);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ---------------在这里增加释放资源的代码---------------</span></span><br><span class=\"line\">    tcp_server.<span class=\"built_in\">closeListen</span>();</span><br><span class=\"line\">    <span class=\"comment\">// --------------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">childEXIT</span><span class=\"params\">(<span class=\"type\">int</span> sig)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGINT, SIG_IGN);</span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGTERM, SIG_IGN);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;子进程退出： &quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ------在这里增加释放资源的代码（只释放子进程的资源）------</span></span><br><span class=\"line\">    tcp_server.<span class=\"built_in\">closeClient</span>();       <span class=\"comment\">// 信号处理函数中只能访问全局对象，tcp_server必须定义为全局变量</span></span><br><span class=\"line\">    <span class=\"comment\">// --------------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">initServer</span>(<span class=\"number\">5005</span>)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;initsServer() failed&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 忽略全部信号，不希望被打扰。顺便解决僵尸进程的问题</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">64</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">signal</span>(i, SIG_IGN);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 设置信号，在shell下可以用 &#x27;kill 进程号&#x27; 和 &#x27;Ctrl+C&#x27; 正常终止这些线程</span></span><br><span class=\"line\">    <span class=\"comment\">// 但请不要用 &#x27;kill -9 进程号&#x27; 强行终止线程</span></span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGTERM, fatherEXIT);</span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGINT, fatherEXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 受理(监听)客户端的连接，从已连接的客户端中取出一个客户端</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果没有已连接的客户端，accept函数将阻塞等待</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">accept</span>()) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;accept failed&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;client connected&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> pid = fork();</span><br><span class=\"line\">        <span class=\"comment\">// 系统资源不足</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pid == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">perror</span>(<span class=\"string\">&quot;fork&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pid &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            tcp_server.<span class=\"built_in\">closeClient</span>();           <span class=\"comment\">// 多进程下，服务器父进程不需要客户端的socket，关闭</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;           <span class=\"comment\">// 父进程返回循环开始位置，继续受理客户端连接</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tcp_server.<span class=\"built_in\">closeListen</span>();           <span class=\"comment\">// 子进程不需要监听socket，关闭</span></span><br><span class=\"line\">        <span class=\"comment\">// 子进程需要重新设置信号</span></span><br><span class=\"line\">        <span class=\"built_in\">signal</span>(SIGTERM, childEXIT);         <span class=\"comment\">// 使用kill命令终止进程时，会产生SIGTERM信号，执行childEXIT函数</span></span><br><span class=\"line\">        <span class=\"built_in\">signal</span>(SIGINT, childEXIT);          <span class=\"comment\">// 按下ctrl+c会触发SIGINT信号，执行childEXIT函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 接收文件</span></span><br><span class=\"line\">        <span class=\"comment\">// 接收客户端发来的文件信息</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">fileInfo</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> fileName[<span class=\"number\">256</span>];     <span class=\"comment\">// 文件名</span></span><br><span class=\"line\">            <span class=\"type\">int</span> fileSize;           <span class=\"comment\">// 文件大小</span></span><br><span class=\"line\">        &#125; fileinfo;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(&amp;fileinfo, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(fileinfo));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">recv</span>(&amp;fileinfo, <span class=\"built_in\">sizeof</span>(fileinfo))) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;fileInfo receive failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(fileinfo.fileName, <span class=\"string\">&quot;test(1).txt&quot;</span>);</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;received: fileName: &quot;</span> &lt;&lt; fileinfo.fileName &lt;&lt; <span class=\"string\">&quot;  fileSize: &quot;</span> &lt;&lt; fileinfo.fileSize &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 给客户端发送确认报文</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">send</span>(<span class=\"string\">&quot;OK&quot;</span>)) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;send error&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 接收文件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">receiveFile</span>(fileinfo.fileName, fileinfo.fileSize)) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;received file error&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;file receive success&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 给客户端发送确认报文</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tcp_server.<span class=\"built_in\">send</span>(<span class=\"string\">&quot;OK&quot;</span>)) &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;send &#x27;OK&#x27; failed&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;           <span class=\"comment\">// 子进程通信完成后一定要退出，否则就会回到accept()函数的位置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Linux多进程编程","date":"2025-07-05T16:00:00.000Z","_content":"\n## Linux多进程\n\n### 基本函数\n\n#### fork()函数\n\n用于创建一个进程，所创建的进程复制父进程的**代码段/数据段/BSS段/堆/栈等所有用户空间信息**；在内核中操作系统重新为其申请了一个PCB，并使用父进程的PCB进行初始化。\n\n```cpp\npid_t fork();\t\t// pid_t实际上时int类型\n```\n\n> `fork`时可以看作==父进程在fork执行的位置进行了一次分裂，分裂出一个子进程==。父进程从`fork`的返回值得到子进程的`pid`，子进程在`fork`位置得到返回值0,并且从fork的下一句开始执行。\n\n- 使用实例：\n\n```cpp\nint main()\n{\n\tpid_t fpid; //fpid表示fork函数返回的值\n    int count = 0;\n    fpid = fork();\n    if (fpid < 0)\n        cout << \"error in fork!\" << endl;\n    else if (fpid == 0) {\n        cout << \"i am the child process, my process id is \" << getpid() << endl;\n        cout << \"我子进程\" << endl;\n        count++;\n    } else {\n        cout << \"i am the parent process, my process id is \" << getpid() << endl;\n        cout << \"我是父进程\" << endl;\n        count++;\n    }\n    cout << \"统计结果是: \" << count << endl;\n\treturn 0;\n}\n```\n\n#### `getpid()`和`gitppid()`\n\n- `gitpid()`: 获取当前进程的`pid`值\n- `gitppid()`: 获取当前进程的父进程的`pid`值\n\n### 进程间通信\n\n","source":"_posts/系统编程/多进程.md","raw":"---\ntitle: Linux多进程编程\ndate: 2025-07-06\ntags: [Linux, 并发, C++]\ncategories: 系统编程\n---\n\n## Linux多进程\n\n### 基本函数\n\n#### fork()函数\n\n用于创建一个进程，所创建的进程复制父进程的**代码段/数据段/BSS段/堆/栈等所有用户空间信息**；在内核中操作系统重新为其申请了一个PCB，并使用父进程的PCB进行初始化。\n\n```cpp\npid_t fork();\t\t// pid_t实际上时int类型\n```\n\n> `fork`时可以看作==父进程在fork执行的位置进行了一次分裂，分裂出一个子进程==。父进程从`fork`的返回值得到子进程的`pid`，子进程在`fork`位置得到返回值0,并且从fork的下一句开始执行。\n\n- 使用实例：\n\n```cpp\nint main()\n{\n\tpid_t fpid; //fpid表示fork函数返回的值\n    int count = 0;\n    fpid = fork();\n    if (fpid < 0)\n        cout << \"error in fork!\" << endl;\n    else if (fpid == 0) {\n        cout << \"i am the child process, my process id is \" << getpid() << endl;\n        cout << \"我子进程\" << endl;\n        count++;\n    } else {\n        cout << \"i am the parent process, my process id is \" << getpid() << endl;\n        cout << \"我是父进程\" << endl;\n        count++;\n    }\n    cout << \"统计结果是: \" << count << endl;\n\treturn 0;\n}\n```\n\n#### `getpid()`和`gitppid()`\n\n- `gitpid()`: 获取当前进程的`pid`值\n- `gitppid()`: 获取当前进程的父进程的`pid`值\n\n### 进程间通信\n\n","slug":"系统编程/多进程","published":1,"updated":"2025-09-14T02:36:11.049Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpt00104e4p409sdmhj","content":"<h2 id=\"Linux多进程\">Linux多进程</h2>\n<h3 id=\"基本函数\">基本函数</h3>\n<h4 id=\"fork-函数\">fork()函数</h4>\n<p>用于创建一个进程，所创建的进程复制父进程的<strong>代码段/数据段/BSS段/堆/栈等所有用户空间信息</strong>；在内核中操作系统重新为其申请了一个PCB，并使用父进程的PCB进行初始化。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">pid_t</span> <span class=\"title\">fork</span><span class=\"params\">()</span></span>;\t\t<span class=\"comment\">// pid_t实际上时int类型</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>fork</code>时可以看作<mark>父进程在fork执行的位置进行了一次分裂，分裂出一个子进程</mark>。父进程从<code>fork</code>的返回值得到子进程的<code>pid</code>，子进程在<code>fork</code>位置得到返回值0,并且从fork的下一句开始执行。</p>\n</blockquote>\n<ul>\n<li>使用实例：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">pid_t</span> fpid; <span class=\"comment\">//fpid表示fork函数返回的值</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    fpid = fork();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fpid &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;error in fork!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fpid == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;i am the child process, my process id is &quot;</span> &lt;&lt; <span class=\"built_in\">getpid</span>() &lt;&lt; endl;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;我子进程&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;i am the parent process, my process id is &quot;</span> &lt;&lt; <span class=\"built_in\">getpid</span>() &lt;&lt; endl;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;我是父进程&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;统计结果是: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"getpid-和gitppid\"><code>getpid()</code>和<code>gitppid()</code></h4>\n<ul>\n<li><code>gitpid()</code>: 获取当前进程的<code>pid</code>值</li>\n<li><code>gitppid()</code>: 获取当前进程的父进程的<code>pid</code>值</li>\n</ul>\n<h3 id=\"进程间通信\">进程间通信</h3>\n","excerpt":"","more":"<h2 id=\"Linux多进程\">Linux多进程</h2>\n<h3 id=\"基本函数\">基本函数</h3>\n<h4 id=\"fork-函数\">fork()函数</h4>\n<p>用于创建一个进程，所创建的进程复制父进程的<strong>代码段/数据段/BSS段/堆/栈等所有用户空间信息</strong>；在内核中操作系统重新为其申请了一个PCB，并使用父进程的PCB进行初始化。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">pid_t</span> <span class=\"title\">fork</span><span class=\"params\">()</span></span>;\t\t<span class=\"comment\">// pid_t实际上时int类型</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>fork</code>时可以看作<mark>父进程在fork执行的位置进行了一次分裂，分裂出一个子进程</mark>。父进程从<code>fork</code>的返回值得到子进程的<code>pid</code>，子进程在<code>fork</code>位置得到返回值0,并且从fork的下一句开始执行。</p>\n</blockquote>\n<ul>\n<li>使用实例：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">pid_t</span> fpid; <span class=\"comment\">//fpid表示fork函数返回的值</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    fpid = fork();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fpid &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;error in fork!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fpid == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;i am the child process, my process id is &quot;</span> &lt;&lt; <span class=\"built_in\">getpid</span>() &lt;&lt; endl;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;我子进程&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;i am the parent process, my process id is &quot;</span> &lt;&lt; <span class=\"built_in\">getpid</span>() &lt;&lt; endl;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;我是父进程&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;统计结果是: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"getpid-和gitppid\"><code>getpid()</code>和<code>gitppid()</code></h4>\n<ul>\n<li><code>gitpid()</code>: 获取当前进程的<code>pid</code>值</li>\n<li><code>gitppid()</code>: 获取当前进程的父进程的<code>pid</code>值</li>\n</ul>\n<h3 id=\"进程间通信\">进程间通信</h3>\n"},{"title":"标准IO","date":"2025-07-05T16:00:00.000Z","_content":"\n> 详细信息请参考man手册\n\n- `fopen(...)`\n    - 具体参数参考`man fopen`\n    - 返回 `FILE*` 类型，FILE是文件流\n    - 在不更改默认的设置的情况下，一个进程中能打开的文件个数最多是1024个（每个文件都是一个流），因为存在`stdin,stdout,stderr`三个流。所以实际能打开1021个。\n        - 可以使用`ulimit -a`查看进程对资源的限制\n    - 如果用`fopen()`创建新文件，则新文件的访问权限由`0666 & ~umask`(8进制位运算)(`umask`的值默认为`0002`)决定，所以一般得到的文件权限为：`rw-rw-r--`(八进制`0664`的后三位)\n- `fclose(FILE *)`\n    - 关闭传入的文件流，释放`FILE *`指向的内存\n    - 成功返回0，不成功返回`EOF`，（多数系统中`EOF`为-1）\n- `fputc()`\n    - \n- `fgetc()`\n    - \n- ","source":"_posts/系统编程/标准IO.md","raw":"---\ntitle: 标准IO\ndate: 2025-07-06\ntags: [Linux, C]\ncategories: 系统编程\n---\n\n> 详细信息请参考man手册\n\n- `fopen(...)`\n    - 具体参数参考`man fopen`\n    - 返回 `FILE*` 类型，FILE是文件流\n    - 在不更改默认的设置的情况下，一个进程中能打开的文件个数最多是1024个（每个文件都是一个流），因为存在`stdin,stdout,stderr`三个流。所以实际能打开1021个。\n        - 可以使用`ulimit -a`查看进程对资源的限制\n    - 如果用`fopen()`创建新文件，则新文件的访问权限由`0666 & ~umask`(8进制位运算)(`umask`的值默认为`0002`)决定，所以一般得到的文件权限为：`rw-rw-r--`(八进制`0664`的后三位)\n- `fclose(FILE *)`\n    - 关闭传入的文件流，释放`FILE *`指向的内存\n    - 成功返回0，不成功返回`EOF`，（多数系统中`EOF`为-1）\n- `fputc()`\n    - \n- `fgetc()`\n    - \n- ","slug":"系统编程/标准IO","published":1,"updated":"2025-09-14T02:36:11.049Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpu00124e4pgjpaea2r","content":"<blockquote>\n<p>详细信息请参考man手册</p>\n</blockquote>\n<ul>\n<li><code>fopen(...)</code>\n<ul>\n<li>具体参数参考<code>man fopen</code></li>\n<li>返回 <code>FILE*</code> 类型，FILE是文件流</li>\n<li>在不更改默认的设置的情况下，一个进程中能打开的文件个数最多是1024个（每个文件都是一个流），因为存在<code>stdin,stdout,stderr</code>三个流。所以实际能打开1021个。\n<ul>\n<li>可以使用<code>ulimit -a</code>查看进程对资源的限制</li>\n</ul>\n</li>\n<li>如果用<code>fopen()</code>创建新文件，则新文件的访问权限由<code>0666 &amp; ~umask</code>(8进制位运算)(<code>umask</code>的值默认为<code>0002</code>)决定，所以一般得到的文件权限为：<code>rw-rw-r--</code>(八进制<code>0664</code>的后三位)</li>\n</ul>\n</li>\n<li><code>fclose(FILE *)</code>\n<ul>\n<li>关闭传入的文件流，释放<code>FILE *</code>指向的内存</li>\n<li>成功返回0，不成功返回<code>EOF</code>，（多数系统中<code>EOF</code>为-1）</li>\n</ul>\n</li>\n<li>\n<h2 id=\"fputc\"><code>fputc()</code></h2>\n</li>\n<li>\n<h2 id=\"fgetc\"><code>fgetc()</code></h2>\n</li>\n<li></li>\n</ul>\n","excerpt":"","more":"<blockquote>\n<p>详细信息请参考man手册</p>\n</blockquote>\n<ul>\n<li><code>fopen(...)</code>\n<ul>\n<li>具体参数参考<code>man fopen</code></li>\n<li>返回 <code>FILE*</code> 类型，FILE是文件流</li>\n<li>在不更改默认的设置的情况下，一个进程中能打开的文件个数最多是1024个（每个文件都是一个流），因为存在<code>stdin,stdout,stderr</code>三个流。所以实际能打开1021个。\n<ul>\n<li>可以使用<code>ulimit -a</code>查看进程对资源的限制</li>\n</ul>\n</li>\n<li>如果用<code>fopen()</code>创建新文件，则新文件的访问权限由<code>0666 &amp; ~umask</code>(8进制位运算)(<code>umask</code>的值默认为<code>0002</code>)决定，所以一般得到的文件权限为：<code>rw-rw-r--</code>(八进制<code>0664</code>的后三位)</li>\n</ul>\n</li>\n<li><code>fclose(FILE *)</code>\n<ul>\n<li>关闭传入的文件流，释放<code>FILE *</code>指向的内存</li>\n<li>成功返回0，不成功返回<code>EOF</code>，（多数系统中<code>EOF</code>为-1）</li>\n</ul>\n</li>\n<li>\n<h2 id=\"fputc\"><code>fputc()</code></h2>\n</li>\n<li>\n<h2 id=\"fgetc\"><code>fgetc()</code></h2>\n</li>\n<li></li>\n</ul>\n"},{"title":"C++ Linux 系统调用","date":"2025-07-05T16:00:00.000Z","_content":"\n> 前置知识：[./标准IO](标准IO)\n> 详细系统调用请查阅man手册\n## open()\n打开文件\n```cpp\n# include <unistd.h> // close函数\n# include <fcntl.> // open函数\n# include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n\tint fd = open(\"./dict.txt\",O_RDONLY);  // 以只读模式打开dict.txt，参数里面是字母O，不是数字0\n\t// int fd = open(\"./dict.txt\",O_RDONLY|O_CREAT, 0644); // 创建并打开文件dict.txt，设置权限为：rw-r--r--\n    if(fd==-1)\n\t{\n\t\tprintf(\"file open error!\");\n\t}\n\tclose(fd);  // 关闭文件描述符\n\treturn 0;\n}\n```\n\n## close()\n关闭文件\n见上述代码\n\n## \n","source":"_posts/系统编程/系统调用.md","raw":"---\ntitle: C++ Linux 系统调用\ndate: 2025-07-06\ncategories: 系统编程\ntags: [Linux, C++]\n---\n\n> 前置知识：[./标准IO](标准IO)\n> 详细系统调用请查阅man手册\n## open()\n打开文件\n```cpp\n# include <unistd.h> // close函数\n# include <fcntl.> // open函数\n# include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n\tint fd = open(\"./dict.txt\",O_RDONLY);  // 以只读模式打开dict.txt，参数里面是字母O，不是数字0\n\t// int fd = open(\"./dict.txt\",O_RDONLY|O_CREAT, 0644); // 创建并打开文件dict.txt，设置权限为：rw-r--r--\n    if(fd==-1)\n\t{\n\t\tprintf(\"file open error!\");\n\t}\n\tclose(fd);  // 关闭文件描述符\n\treturn 0;\n}\n```\n\n## close()\n关闭文件\n见上述代码\n\n## \n","slug":"系统编程/系统调用","published":1,"updated":"2025-09-14T02:36:11.049Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpv00174e4p5ejsdewd","content":"<blockquote>\n<p>前置知识：<a href=\"%E6%A0%87%E5%87%86IO\">./标准IO</a><br>\n详细系统调用请查阅man手册</p>\n</blockquote>\n<h2 id=\"open\">open()</h2>\n<p>打开文件</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span> <span class=\"comment\">// close函数</span></span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.&gt;</span> <span class=\"comment\">// open函数</span></span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> fd = <span class=\"built_in\">open</span>(<span class=\"string\">&quot;./dict.txt&quot;</span>,O_RDONLY);  <span class=\"comment\">// 以只读模式打开dict.txt，参数里面是字母O，不是数字0</span></span><br><span class=\"line\">\t<span class=\"comment\">// int fd = open(&quot;./dict.txt&quot;,O_RDONLY|O_CREAT, 0644); // 创建并打开文件dict.txt，设置权限为：rw-r--r--</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fd==<span class=\"number\">-1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;file open error!&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(fd);  <span class=\"comment\">// 关闭文件描述符</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"close\">close()</h2>\n<p>关闭文件<br>\n见上述代码</p>\n<h2 id=\"\"></h2>\n","excerpt":"","more":"<blockquote>\n<p>前置知识：<a href=\"%E6%A0%87%E5%87%86IO\">./标准IO</a><br>\n详细系统调用请查阅man手册</p>\n</blockquote>\n<h2 id=\"open\">open()</h2>\n<p>打开文件</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span> <span class=\"comment\">// close函数</span></span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.&gt;</span> <span class=\"comment\">// open函数</span></span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> fd = <span class=\"built_in\">open</span>(<span class=\"string\">&quot;./dict.txt&quot;</span>,O_RDONLY);  <span class=\"comment\">// 以只读模式打开dict.txt，参数里面是字母O，不是数字0</span></span><br><span class=\"line\">\t<span class=\"comment\">// int fd = open(&quot;./dict.txt&quot;,O_RDONLY|O_CREAT, 0644); // 创建并打开文件dict.txt，设置权限为：rw-r--r--</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fd==<span class=\"number\">-1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;file open error!&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(fd);  <span class=\"comment\">// 关闭文件描述符</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"close\">close()</h2>\n<p>关闭文件<br>\n见上述代码</p>\n<h2 id=\"\"></h2>\n"},{"title":"STL-map","date":"2025-07-05T16:00:00.000Z","description":"C++ 四种map","_content":"\n#### map\n\n> 存储 `key-value`，==key唯一==\n>\n> 底层：红黑树。红黑树参考：[RBTree](../../数据结构/RBTree)\n>\n> 是否有序：有序（key升序）\n\n#### unordered_map\n\n> 存储`key-value`，==key唯一==\n>\n> 底层：**哈希表**。\n>\n> 是否有序：无序\n\n#### multimap\n\n> 存储`key-value`，==key不唯一==（一个key对应多个value）\n>\n> 底层：红黑树。\n>\n> 是否有序：有序（key升序）\n\n#### unordered_multimap\n\n> 存储`key-vlaue`，==key不唯一==（一个key对应多个value）\n>\n> 底层：**哈希表**。\n\n#### 总结：\n\n- 带有`unordered`就是哈希表，没有`unordered`就是红黑树\n- 带有`multi`就是可重复key\n\n#### 横向对比\n\n> **有序用树，高速用哈希，重复用multi，唯一用map**\n\n|        **特性**         |        **`map`**         |   **`multimap`**   |    **`unordered_map`**     |  **`unordered_multimap`**  |\n| :---------------------: | :----------------------: | :----------------: | :------------------------: | :------------------------: |\n|      **底层结构**       | 红黑树（平衡二叉搜索树） |       红黑树       |    哈希表（Hash Table）    |           哈希表           |\n|      **元素顺序**       |     有序（默认升序）     |        有序        |            无序            |            无序            |\n|      **键唯一性**       |           唯一           |       可重复       |            唯一            |           可重复           |\n| **插入/查找时间复杂度** |         O(log n)         |      O(log n)      | O(1)（平均），O(n)（最坏） | O(1)（平均），O(n)（最坏） |\n|      **内存占用**       |  较高（树节点额外信息）  |        较高        | 较低（但需预留哈希桶空间） |            较低            |\n|  **`operator[]`支持**   |            ✅             |         ❌          |             ✅              |             ❌              |\n|      **适用场景**       |   需有序遍历或范围查询   | 需有序且允许键重复 |     高频查找且无需顺序     | 高频插入/删除且允许键重复  |","source":"_posts/C-Plus-Plus/STL/map.md","raw":"---\ntitle: STL-map\ndate: 2025-07-06\ndescription: C++ 四种map\n---\n\n#### map\n\n> 存储 `key-value`，==key唯一==\n>\n> 底层：红黑树。红黑树参考：[RBTree](../../数据结构/RBTree)\n>\n> 是否有序：有序（key升序）\n\n#### unordered_map\n\n> 存储`key-value`，==key唯一==\n>\n> 底层：**哈希表**。\n>\n> 是否有序：无序\n\n#### multimap\n\n> 存储`key-value`，==key不唯一==（一个key对应多个value）\n>\n> 底层：红黑树。\n>\n> 是否有序：有序（key升序）\n\n#### unordered_multimap\n\n> 存储`key-vlaue`，==key不唯一==（一个key对应多个value）\n>\n> 底层：**哈希表**。\n\n#### 总结：\n\n- 带有`unordered`就是哈希表，没有`unordered`就是红黑树\n- 带有`multi`就是可重复key\n\n#### 横向对比\n\n> **有序用树，高速用哈希，重复用multi，唯一用map**\n\n|        **特性**         |        **`map`**         |   **`multimap`**   |    **`unordered_map`**     |  **`unordered_multimap`**  |\n| :---------------------: | :----------------------: | :----------------: | :------------------------: | :------------------------: |\n|      **底层结构**       | 红黑树（平衡二叉搜索树） |       红黑树       |    哈希表（Hash Table）    |           哈希表           |\n|      **元素顺序**       |     有序（默认升序）     |        有序        |            无序            |            无序            |\n|      **键唯一性**       |           唯一           |       可重复       |            唯一            |           可重复           |\n| **插入/查找时间复杂度** |         O(log n)         |      O(log n)      | O(1)（平均），O(n)（最坏） | O(1)（平均），O(n)（最坏） |\n|      **内存占用**       |  较高（树节点额外信息）  |        较高        | 较低（但需预留哈希桶空间） |            较低            |\n|  **`operator[]`支持**   |            ✅             |         ❌          |             ✅              |             ❌              |\n|      **适用场景**       |   需有序遍历或范围查询   | 需有序且允许键重复 |     高频查找且无需顺序     | 高频插入/删除且允许键重复  |","slug":"C-Plus-Plus/STL/map","published":1,"updated":"2025-09-14T02:36:11.008Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpw00194e4pddlrca4g","content":"<h4 id=\"map\">map</h4>\n<blockquote>\n<p>存储 <code>key-value</code>，<mark>key唯一</mark></p>\n<p>底层：红黑树。红黑树参考：<a href=\"../../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/RBTree\">RBTree</a></p>\n<p>是否有序：有序（key升序）</p>\n</blockquote>\n<h4 id=\"unordered-map\">unordered_map</h4>\n<blockquote>\n<p>存储<code>key-value</code>，<mark>key唯一</mark></p>\n<p>底层：<strong>哈希表</strong>。</p>\n<p>是否有序：无序</p>\n</blockquote>\n<h4 id=\"multimap\">multimap</h4>\n<blockquote>\n<p>存储<code>key-value</code>，<mark>key不唯一</mark>（一个key对应多个value）</p>\n<p>底层：红黑树。</p>\n<p>是否有序：有序（key升序）</p>\n</blockquote>\n<h4 id=\"unordered-multimap\">unordered_multimap</h4>\n<blockquote>\n<p>存储<code>key-vlaue</code>，<mark>key不唯一</mark>（一个key对应多个value）</p>\n<p>底层：<strong>哈希表</strong>。</p>\n</blockquote>\n<h4 id=\"总结：\">总结：</h4>\n<ul>\n<li>带有<code>unordered</code>就是哈希表，没有<code>unordered</code>就是红黑树</li>\n<li>带有<code>multi</code>就是可重复key</li>\n</ul>\n<h4 id=\"横向对比\">横向对比</h4>\n<blockquote>\n<p><strong>有序用树，高速用哈希，重复用multi，唯一用map</strong></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>特性</strong></th>\n<th style=\"text-align:center\"><strong><code>map</code></strong></th>\n<th style=\"text-align:center\"><strong><code>multimap</code></strong></th>\n<th style=\"text-align:center\"><strong><code>unordered_map</code></strong></th>\n<th style=\"text-align:center\"><strong><code>unordered_multimap</code></strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>底层结构</strong></td>\n<td style=\"text-align:center\">红黑树（平衡二叉搜索树）</td>\n<td style=\"text-align:center\">红黑树</td>\n<td style=\"text-align:center\">哈希表（Hash Table）</td>\n<td style=\"text-align:center\">哈希表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>元素顺序</strong></td>\n<td style=\"text-align:center\">有序（默认升序）</td>\n<td style=\"text-align:center\">有序</td>\n<td style=\"text-align:center\">无序</td>\n<td style=\"text-align:center\">无序</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>键唯一性</strong></td>\n<td style=\"text-align:center\">唯一</td>\n<td style=\"text-align:center\">可重复</td>\n<td style=\"text-align:center\">唯一</td>\n<td style=\"text-align:center\">可重复</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>插入/查找时间复杂度</strong></td>\n<td style=\"text-align:center\">O(log n)</td>\n<td style=\"text-align:center\">O(log n)</td>\n<td style=\"text-align:center\">O(1)（平均），O(n)（最坏）</td>\n<td style=\"text-align:center\">O(1)（平均），O(n)（最坏）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>内存占用</strong></td>\n<td style=\"text-align:center\">较高（树节点额外信息）</td>\n<td style=\"text-align:center\">较高</td>\n<td style=\"text-align:center\">较低（但需预留哈希桶空间）</td>\n<td style=\"text-align:center\">较低</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong><code>operator[]</code>支持</strong></td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>适用场景</strong></td>\n<td style=\"text-align:center\">需有序遍历或范围查询</td>\n<td style=\"text-align:center\">需有序且允许键重复</td>\n<td style=\"text-align:center\">高频查找且无需顺序</td>\n<td style=\"text-align:center\">高频插入/删除且允许键重复</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<h4 id=\"map\">map</h4>\n<blockquote>\n<p>存储 <code>key-value</code>，<mark>key唯一</mark></p>\n<p>底层：红黑树。红黑树参考：<a href=\"../../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/RBTree\">RBTree</a></p>\n<p>是否有序：有序（key升序）</p>\n</blockquote>\n<h4 id=\"unordered-map\">unordered_map</h4>\n<blockquote>\n<p>存储<code>key-value</code>，<mark>key唯一</mark></p>\n<p>底层：<strong>哈希表</strong>。</p>\n<p>是否有序：无序</p>\n</blockquote>\n<h4 id=\"multimap\">multimap</h4>\n<blockquote>\n<p>存储<code>key-value</code>，<mark>key不唯一</mark>（一个key对应多个value）</p>\n<p>底层：红黑树。</p>\n<p>是否有序：有序（key升序）</p>\n</blockquote>\n<h4 id=\"unordered-multimap\">unordered_multimap</h4>\n<blockquote>\n<p>存储<code>key-vlaue</code>，<mark>key不唯一</mark>（一个key对应多个value）</p>\n<p>底层：<strong>哈希表</strong>。</p>\n</blockquote>\n<h4 id=\"总结：\">总结：</h4>\n<ul>\n<li>带有<code>unordered</code>就是哈希表，没有<code>unordered</code>就是红黑树</li>\n<li>带有<code>multi</code>就是可重复key</li>\n</ul>\n<h4 id=\"横向对比\">横向对比</h4>\n<blockquote>\n<p><strong>有序用树，高速用哈希，重复用multi，唯一用map</strong></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>特性</strong></th>\n<th style=\"text-align:center\"><strong><code>map</code></strong></th>\n<th style=\"text-align:center\"><strong><code>multimap</code></strong></th>\n<th style=\"text-align:center\"><strong><code>unordered_map</code></strong></th>\n<th style=\"text-align:center\"><strong><code>unordered_multimap</code></strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>底层结构</strong></td>\n<td style=\"text-align:center\">红黑树（平衡二叉搜索树）</td>\n<td style=\"text-align:center\">红黑树</td>\n<td style=\"text-align:center\">哈希表（Hash Table）</td>\n<td style=\"text-align:center\">哈希表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>元素顺序</strong></td>\n<td style=\"text-align:center\">有序（默认升序）</td>\n<td style=\"text-align:center\">有序</td>\n<td style=\"text-align:center\">无序</td>\n<td style=\"text-align:center\">无序</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>键唯一性</strong></td>\n<td style=\"text-align:center\">唯一</td>\n<td style=\"text-align:center\">可重复</td>\n<td style=\"text-align:center\">唯一</td>\n<td style=\"text-align:center\">可重复</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>插入/查找时间复杂度</strong></td>\n<td style=\"text-align:center\">O(log n)</td>\n<td style=\"text-align:center\">O(log n)</td>\n<td style=\"text-align:center\">O(1)（平均），O(n)（最坏）</td>\n<td style=\"text-align:center\">O(1)（平均），O(n)（最坏）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>内存占用</strong></td>\n<td style=\"text-align:center\">较高（树节点额外信息）</td>\n<td style=\"text-align:center\">较高</td>\n<td style=\"text-align:center\">较低（但需预留哈希桶空间）</td>\n<td style=\"text-align:center\">较低</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong><code>operator[]</code>支持</strong></td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>适用场景</strong></td>\n<td style=\"text-align:center\">需有序遍历或范围查询</td>\n<td style=\"text-align:center\">需有序且允许键重复</td>\n<td style=\"text-align:center\">高频查找且无需顺序</td>\n<td style=\"text-align:center\">高频插入/删除且允许键重复</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"STL-set","date":"2025-07-05T16:00:00.000Z","description":"C++ 四种set","_content":"\n#### set\n\n> 集合。存储指定的类型：`std::set<int> mySet;`.\n\n#### 横向对比\n\n\n|        **特性**         |        **`set`**         |  **`multiset`**  |    **`unordered_set`**     |  **`unordered_multiset`**  |\n| :---------------------: | :----------------------: | :--------------: | :------------------------: | :------------------------: |\n|      **底层结构**       | 红黑树（平衡二叉搜索树） |      红黑树      |    哈希表（Hash Table）    |           哈希表           |\n|      **元素顺序**       |     有序（默认升序）     |       有序       |            无序            |            无序            |\n|     **元素唯一性**      |           唯一           |      可重复      |            唯一            |           可重复           |\n| **插入/查找时间复杂度** |         O(log n)         |     O(log n)     | O(1)（平均），O(n)（最坏） | O(1)（平均），O(n)（最坏） |\n|    **迭代器稳定性**     |   稳定（除删除元素外）   |       稳定       |   不稳定（rehash时失效）   |           不稳定           |\n|      **内存占用**       |    较低（树结构紧凑）    |       较低       |   较高（需预分配哈希桶）   |            较高            |\n|      **适用场景**       |   需有序遍历或范围查询   | 需有序且允许重复 |     高频查找且无需顺序     |  高频插入/删除且允许重复   |","source":"_posts/C-Plus-Plus/STL/set.md","raw":"---\ntitle: STL-set\ndate: 2025-07-06\ndescription: C++ 四种set\n---\n\n#### set\n\n> 集合。存储指定的类型：`std::set<int> mySet;`.\n\n#### 横向对比\n\n\n|        **特性**         |        **`set`**         |  **`multiset`**  |    **`unordered_set`**     |  **`unordered_multiset`**  |\n| :---------------------: | :----------------------: | :--------------: | :------------------------: | :------------------------: |\n|      **底层结构**       | 红黑树（平衡二叉搜索树） |      红黑树      |    哈希表（Hash Table）    |           哈希表           |\n|      **元素顺序**       |     有序（默认升序）     |       有序       |            无序            |            无序            |\n|     **元素唯一性**      |           唯一           |      可重复      |            唯一            |           可重复           |\n| **插入/查找时间复杂度** |         O(log n)         |     O(log n)     | O(1)（平均），O(n)（最坏） | O(1)（平均），O(n)（最坏） |\n|    **迭代器稳定性**     |   稳定（除删除元素外）   |       稳定       |   不稳定（rehash时失效）   |           不稳定           |\n|      **内存占用**       |    较低（树结构紧凑）    |       较低       |   较高（需预分配哈希桶）   |            较高            |\n|      **适用场景**       |   需有序遍历或范围查询   | 需有序且允许重复 |     高频查找且无需顺序     |  高频插入/删除且允许重复   |","slug":"C-Plus-Plus/STL/set","published":1,"updated":"2025-09-14T02:36:11.008Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpw001d4e4pdoee0y7a","content":"<h4 id=\"set\">set</h4>\n<blockquote>\n<p>集合。存储指定的类型：<code>std::set&lt;int&gt; mySet;</code>.</p>\n</blockquote>\n<h4 id=\"横向对比\">横向对比</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>特性</strong></th>\n<th style=\"text-align:center\"><strong><code>set</code></strong></th>\n<th style=\"text-align:center\"><strong><code>multiset</code></strong></th>\n<th style=\"text-align:center\"><strong><code>unordered_set</code></strong></th>\n<th style=\"text-align:center\"><strong><code>unordered_multiset</code></strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>底层结构</strong></td>\n<td style=\"text-align:center\">红黑树（平衡二叉搜索树）</td>\n<td style=\"text-align:center\">红黑树</td>\n<td style=\"text-align:center\">哈希表（Hash Table）</td>\n<td style=\"text-align:center\">哈希表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>元素顺序</strong></td>\n<td style=\"text-align:center\">有序（默认升序）</td>\n<td style=\"text-align:center\">有序</td>\n<td style=\"text-align:center\">无序</td>\n<td style=\"text-align:center\">无序</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>元素唯一性</strong></td>\n<td style=\"text-align:center\">唯一</td>\n<td style=\"text-align:center\">可重复</td>\n<td style=\"text-align:center\">唯一</td>\n<td style=\"text-align:center\">可重复</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>插入/查找时间复杂度</strong></td>\n<td style=\"text-align:center\">O(log n)</td>\n<td style=\"text-align:center\">O(log n)</td>\n<td style=\"text-align:center\">O(1)（平均），O(n)（最坏）</td>\n<td style=\"text-align:center\">O(1)（平均），O(n)（最坏）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>迭代器稳定性</strong></td>\n<td style=\"text-align:center\">稳定（除删除元素外）</td>\n<td style=\"text-align:center\">稳定</td>\n<td style=\"text-align:center\">不稳定（rehash时失效）</td>\n<td style=\"text-align:center\">不稳定</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>内存占用</strong></td>\n<td style=\"text-align:center\">较低（树结构紧凑）</td>\n<td style=\"text-align:center\">较低</td>\n<td style=\"text-align:center\">较高（需预分配哈希桶）</td>\n<td style=\"text-align:center\">较高</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>适用场景</strong></td>\n<td style=\"text-align:center\">需有序遍历或范围查询</td>\n<td style=\"text-align:center\">需有序且允许重复</td>\n<td style=\"text-align:center\">高频查找且无需顺序</td>\n<td style=\"text-align:center\">高频插入/删除且允许重复</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<h4 id=\"set\">set</h4>\n<blockquote>\n<p>集合。存储指定的类型：<code>std::set&lt;int&gt; mySet;</code>.</p>\n</blockquote>\n<h4 id=\"横向对比\">横向对比</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>特性</strong></th>\n<th style=\"text-align:center\"><strong><code>set</code></strong></th>\n<th style=\"text-align:center\"><strong><code>multiset</code></strong></th>\n<th style=\"text-align:center\"><strong><code>unordered_set</code></strong></th>\n<th style=\"text-align:center\"><strong><code>unordered_multiset</code></strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>底层结构</strong></td>\n<td style=\"text-align:center\">红黑树（平衡二叉搜索树）</td>\n<td style=\"text-align:center\">红黑树</td>\n<td style=\"text-align:center\">哈希表（Hash Table）</td>\n<td style=\"text-align:center\">哈希表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>元素顺序</strong></td>\n<td style=\"text-align:center\">有序（默认升序）</td>\n<td style=\"text-align:center\">有序</td>\n<td style=\"text-align:center\">无序</td>\n<td style=\"text-align:center\">无序</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>元素唯一性</strong></td>\n<td style=\"text-align:center\">唯一</td>\n<td style=\"text-align:center\">可重复</td>\n<td style=\"text-align:center\">唯一</td>\n<td style=\"text-align:center\">可重复</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>插入/查找时间复杂度</strong></td>\n<td style=\"text-align:center\">O(log n)</td>\n<td style=\"text-align:center\">O(log n)</td>\n<td style=\"text-align:center\">O(1)（平均），O(n)（最坏）</td>\n<td style=\"text-align:center\">O(1)（平均），O(n)（最坏）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>迭代器稳定性</strong></td>\n<td style=\"text-align:center\">稳定（除删除元素外）</td>\n<td style=\"text-align:center\">稳定</td>\n<td style=\"text-align:center\">不稳定（rehash时失效）</td>\n<td style=\"text-align:center\">不稳定</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>内存占用</strong></td>\n<td style=\"text-align:center\">较低（树结构紧凑）</td>\n<td style=\"text-align:center\">较低</td>\n<td style=\"text-align:center\">较高（需预分配哈希桶）</td>\n<td style=\"text-align:center\">较高</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>适用场景</strong></td>\n<td style=\"text-align:center\">需有序遍历或范围查询</td>\n<td style=\"text-align:center\">需有序且允许重复</td>\n<td style=\"text-align:center\">高频查找且无需顺序</td>\n<td style=\"text-align:center\">高频插入/删除且允许重复</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"shared_lock","date":"2025-07-05T16:00:00.000Z","_content":"\n### shared_lock\n\n专门用于管理 `std::shared_timed_mutex` 或 `std::shared_mutex` 的共享锁。它简化了获取和释放共享锁的操作，并提供了一些附加功能，比如延迟锁定、超时锁定等。\n\n成员函数：\n\n- `shared_lock()`: 创建一个未锁定的`shared_lock`。\n\n- `shared_lock(mutex_type& m)`: \n\n  创建一个`shared_lock` 并尝试锁定给定的`mutex_type`（`std::shared_timed_mutex` 或 `std::shared_mutex`）。如果锁定失败，则抛出异常。\n\n- `shared_lock(mutex_type& m, std::defer_lock_t t)`: \n\n  创建一个未锁定的 shared_lock，但关联到给定的`mutex_type`。\n\n- `shared_lock(mutex_type& m, std::try_to_lock_t t)`: \n\n  尝试锁定给定的 mutex_type，如果成功则锁定，否则创建一个未锁定的`shared_lock`。\n\n- `shared_lock(mutex_type& m, const std::chrono::time_point<Clock, Duration>& abs_time)`:\n\n  尝试在给定的绝对时间点之前锁定给定的`mutex_type`。如果成功则锁定，否则创建一个未锁定的`shared_lock`。\n\n- `shared_lock(mutex_type& m, const std::chrono::duration<Rep, Period>& rel_time)`: \n\n  尝试在给定的相对时间段内锁定给定的 mutex_type。如果成功则锁定，否则创建一个未锁定的`shared_lock`。\n\n- `lock()`: 锁定关联的互斥量（如果尚未锁定）。\n\n- `try_lock()`: 尝试锁定关联的互斥量，如果成功则返回`true`，否则返回`false`。\n\n- `try_lock_for(duration)`: 尝试在指定的时间段内锁定关联的互斥量，如果成功则返回`true`，否则返回`false`。\n\n- `try_lock_until(time_point)`: 尝试在给定的时间点之前锁定关联的互斥量，如果成功则返回`true`，否则返回`false`。\n\n- `unlock()`: 释放锁（如果持有）。\n\n- `owns_lock()`: 检查 shared_lock 是否持有锁。\n\n- `operator bool()`: 检查 shared_lock 是否持有锁（返回 owns_lock() 的结果）。","source":"_posts/C-Plus-Plus/c-plus-plus-14/shared_lock.md","raw":"---\ntitle: shared_lock\ndate: 2025-07-06\n---\n\n### shared_lock\n\n专门用于管理 `std::shared_timed_mutex` 或 `std::shared_mutex` 的共享锁。它简化了获取和释放共享锁的操作，并提供了一些附加功能，比如延迟锁定、超时锁定等。\n\n成员函数：\n\n- `shared_lock()`: 创建一个未锁定的`shared_lock`。\n\n- `shared_lock(mutex_type& m)`: \n\n  创建一个`shared_lock` 并尝试锁定给定的`mutex_type`（`std::shared_timed_mutex` 或 `std::shared_mutex`）。如果锁定失败，则抛出异常。\n\n- `shared_lock(mutex_type& m, std::defer_lock_t t)`: \n\n  创建一个未锁定的 shared_lock，但关联到给定的`mutex_type`。\n\n- `shared_lock(mutex_type& m, std::try_to_lock_t t)`: \n\n  尝试锁定给定的 mutex_type，如果成功则锁定，否则创建一个未锁定的`shared_lock`。\n\n- `shared_lock(mutex_type& m, const std::chrono::time_point<Clock, Duration>& abs_time)`:\n\n  尝试在给定的绝对时间点之前锁定给定的`mutex_type`。如果成功则锁定，否则创建一个未锁定的`shared_lock`。\n\n- `shared_lock(mutex_type& m, const std::chrono::duration<Rep, Period>& rel_time)`: \n\n  尝试在给定的相对时间段内锁定给定的 mutex_type。如果成功则锁定，否则创建一个未锁定的`shared_lock`。\n\n- `lock()`: 锁定关联的互斥量（如果尚未锁定）。\n\n- `try_lock()`: 尝试锁定关联的互斥量，如果成功则返回`true`，否则返回`false`。\n\n- `try_lock_for(duration)`: 尝试在指定的时间段内锁定关联的互斥量，如果成功则返回`true`，否则返回`false`。\n\n- `try_lock_until(time_point)`: 尝试在给定的时间点之前锁定关联的互斥量，如果成功则返回`true`，否则返回`false`。\n\n- `unlock()`: 释放锁（如果持有）。\n\n- `owns_lock()`: 检查 shared_lock 是否持有锁。\n\n- `operator bool()`: 检查 shared_lock 是否持有锁（返回 owns_lock() 的结果）。","slug":"C-Plus-Plus/c-plus-plus-14/shared_lock","published":1,"updated":"2025-09-14T02:36:11.008Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpx001f4e4p7uzpeqay","content":"<h3 id=\"shared-lock\">shared_lock</h3>\n<p>专门用于管理 <code>std::shared_timed_mutex</code> 或 <code>std::shared_mutex</code> 的共享锁。它简化了获取和释放共享锁的操作，并提供了一些附加功能，比如延迟锁定、超时锁定等。</p>\n<p>成员函数：</p>\n<ul>\n<li>\n<p><code>shared_lock()</code>: 创建一个未锁定的<code>shared_lock</code>。</p>\n</li>\n<li>\n<p><code>shared_lock(mutex_type&amp; m)</code>:</p>\n<p>创建一个<code>shared_lock</code> 并尝试锁定给定的<code>mutex_type</code>（<code>std::shared_timed_mutex</code> 或 <code>std::shared_mutex</code>）。如果锁定失败，则抛出异常。</p>\n</li>\n<li>\n<p><code>shared_lock(mutex_type&amp; m, std::defer_lock_t t)</code>:</p>\n<p>创建一个未锁定的 shared_lock，但关联到给定的<code>mutex_type</code>。</p>\n</li>\n<li>\n<p><code>shared_lock(mutex_type&amp; m, std::try_to_lock_t t)</code>:</p>\n<p>尝试锁定给定的 mutex_type，如果成功则锁定，否则创建一个未锁定的<code>shared_lock</code>。</p>\n</li>\n<li>\n<p><code>shared_lock(mutex_type&amp; m, const std::chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)</code>:</p>\n<p>尝试在给定的绝对时间点之前锁定给定的<code>mutex_type</code>。如果成功则锁定，否则创建一个未锁定的<code>shared_lock</code>。</p>\n</li>\n<li>\n<p><code>shared_lock(mutex_type&amp; m, const std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</code>:</p>\n<p>尝试在给定的相对时间段内锁定给定的 mutex_type。如果成功则锁定，否则创建一个未锁定的<code>shared_lock</code>。</p>\n</li>\n<li>\n<p><code>lock()</code>: 锁定关联的互斥量（如果尚未锁定）。</p>\n</li>\n<li>\n<p><code>try_lock()</code>: 尝试锁定关联的互斥量，如果成功则返回<code>true</code>，否则返回<code>false</code>。</p>\n</li>\n<li>\n<p><code>try_lock_for(duration)</code>: 尝试在指定的时间段内锁定关联的互斥量，如果成功则返回<code>true</code>，否则返回<code>false</code>。</p>\n</li>\n<li>\n<p><code>try_lock_until(time_point)</code>: 尝试在给定的时间点之前锁定关联的互斥量，如果成功则返回<code>true</code>，否则返回<code>false</code>。</p>\n</li>\n<li>\n<p><code>unlock()</code>: 释放锁（如果持有）。</p>\n</li>\n<li>\n<p><code>owns_lock()</code>: 检查 shared_lock 是否持有锁。</p>\n</li>\n<li>\n<p><code>operator bool()</code>: 检查 shared_lock 是否持有锁（返回 owns_lock() 的结果）。</p>\n</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"shared-lock\">shared_lock</h3>\n<p>专门用于管理 <code>std::shared_timed_mutex</code> 或 <code>std::shared_mutex</code> 的共享锁。它简化了获取和释放共享锁的操作，并提供了一些附加功能，比如延迟锁定、超时锁定等。</p>\n<p>成员函数：</p>\n<ul>\n<li>\n<p><code>shared_lock()</code>: 创建一个未锁定的<code>shared_lock</code>。</p>\n</li>\n<li>\n<p><code>shared_lock(mutex_type&amp; m)</code>:</p>\n<p>创建一个<code>shared_lock</code> 并尝试锁定给定的<code>mutex_type</code>（<code>std::shared_timed_mutex</code> 或 <code>std::shared_mutex</code>）。如果锁定失败，则抛出异常。</p>\n</li>\n<li>\n<p><code>shared_lock(mutex_type&amp; m, std::defer_lock_t t)</code>:</p>\n<p>创建一个未锁定的 shared_lock，但关联到给定的<code>mutex_type</code>。</p>\n</li>\n<li>\n<p><code>shared_lock(mutex_type&amp; m, std::try_to_lock_t t)</code>:</p>\n<p>尝试锁定给定的 mutex_type，如果成功则锁定，否则创建一个未锁定的<code>shared_lock</code>。</p>\n</li>\n<li>\n<p><code>shared_lock(mutex_type&amp; m, const std::chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)</code>:</p>\n<p>尝试在给定的绝对时间点之前锁定给定的<code>mutex_type</code>。如果成功则锁定，否则创建一个未锁定的<code>shared_lock</code>。</p>\n</li>\n<li>\n<p><code>shared_lock(mutex_type&amp; m, const std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</code>:</p>\n<p>尝试在给定的相对时间段内锁定给定的 mutex_type。如果成功则锁定，否则创建一个未锁定的<code>shared_lock</code>。</p>\n</li>\n<li>\n<p><code>lock()</code>: 锁定关联的互斥量（如果尚未锁定）。</p>\n</li>\n<li>\n<p><code>try_lock()</code>: 尝试锁定关联的互斥量，如果成功则返回<code>true</code>，否则返回<code>false</code>。</p>\n</li>\n<li>\n<p><code>try_lock_for(duration)</code>: 尝试在指定的时间段内锁定关联的互斥量，如果成功则返回<code>true</code>，否则返回<code>false</code>。</p>\n</li>\n<li>\n<p><code>try_lock_until(time_point)</code>: 尝试在给定的时间点之前锁定关联的互斥量，如果成功则返回<code>true</code>，否则返回<code>false</code>。</p>\n</li>\n<li>\n<p><code>unlock()</code>: 释放锁（如果持有）。</p>\n</li>\n<li>\n<p><code>owns_lock()</code>: 检查 shared_lock 是否持有锁。</p>\n</li>\n<li>\n<p><code>operator bool()</code>: 检查 shared_lock 是否持有锁（返回 owns_lock() 的结果）。</p>\n</li>\n</ul>\n"},{"title":"shared_timed_mutex","date":"2025-07-05T16:00:00.000Z","_content":"\n### shared_timed_mutex\n\n共享超时互斥锁（具备超时功能的读写锁）\n\n成员函数：\n\n- `lock_shared()`: 获取==共享锁==，如果当前有独占锁，则阻塞。\n- `try_lock_shared()`: 尝试获取共享锁，如果成功则返回`true`，否则返回`false`，不阻塞。\n- `try_lock_shared_for(duration)`: 尝试在指定的时间段内获取共享锁，如果成功则返回`true`，否则返回`false`。\n- `lock()`: 获取==独占锁==，如果当前有共享锁或独占锁，则阻塞。\n- `try_lock()`: 尝试获取独占锁，如果成功则返回`true`，否则返回`false`，不阻塞。\n- `try_lock_for(duration)`: 尝试在指定的时间段内获取独占锁，如果成功则返回`true`，否则返回`false`。\n- `unlock()`: 释放当前持有的锁（无论是共享锁还是独占锁）。","source":"_posts/C-Plus-Plus/c-plus-plus-14/shared_timed_mutex.md","raw":"---\ntitle: shared_timed_mutex\ndate: 2025-07-06\n---\n\n### shared_timed_mutex\n\n共享超时互斥锁（具备超时功能的读写锁）\n\n成员函数：\n\n- `lock_shared()`: 获取==共享锁==，如果当前有独占锁，则阻塞。\n- `try_lock_shared()`: 尝试获取共享锁，如果成功则返回`true`，否则返回`false`，不阻塞。\n- `try_lock_shared_for(duration)`: 尝试在指定的时间段内获取共享锁，如果成功则返回`true`，否则返回`false`。\n- `lock()`: 获取==独占锁==，如果当前有共享锁或独占锁，则阻塞。\n- `try_lock()`: 尝试获取独占锁，如果成功则返回`true`，否则返回`false`，不阻塞。\n- `try_lock_for(duration)`: 尝试在指定的时间段内获取独占锁，如果成功则返回`true`，否则返回`false`。\n- `unlock()`: 释放当前持有的锁（无论是共享锁还是独占锁）。","slug":"C-Plus-Plus/c-plus-plus-14/shared_timed_mutex","published":1,"updated":"2025-09-14T02:36:11.008Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpy001k4e4pew8394ii","content":"<h3 id=\"shared-timed-mutex\">shared_timed_mutex</h3>\n<p>共享超时互斥锁（具备超时功能的读写锁）</p>\n<p>成员函数：</p>\n<ul>\n<li><code>lock_shared()</code>: 获取<mark>共享锁</mark>，如果当前有独占锁，则阻塞。</li>\n<li><code>try_lock_shared()</code>: 尝试获取共享锁，如果成功则返回<code>true</code>，否则返回<code>false</code>，不阻塞。</li>\n<li><code>try_lock_shared_for(duration)</code>: 尝试在指定的时间段内获取共享锁，如果成功则返回<code>true</code>，否则返回<code>false</code>。</li>\n<li><code>lock()</code>: 获取<mark>独占锁</mark>，如果当前有共享锁或独占锁，则阻塞。</li>\n<li><code>try_lock()</code>: 尝试获取独占锁，如果成功则返回<code>true</code>，否则返回<code>false</code>，不阻塞。</li>\n<li><code>try_lock_for(duration)</code>: 尝试在指定的时间段内获取独占锁，如果成功则返回<code>true</code>，否则返回<code>false</code>。</li>\n<li><code>unlock()</code>: 释放当前持有的锁（无论是共享锁还是独占锁）。</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"shared-timed-mutex\">shared_timed_mutex</h3>\n<p>共享超时互斥锁（具备超时功能的读写锁）</p>\n<p>成员函数：</p>\n<ul>\n<li><code>lock_shared()</code>: 获取<mark>共享锁</mark>，如果当前有独占锁，则阻塞。</li>\n<li><code>try_lock_shared()</code>: 尝试获取共享锁，如果成功则返回<code>true</code>，否则返回<code>false</code>，不阻塞。</li>\n<li><code>try_lock_shared_for(duration)</code>: 尝试在指定的时间段内获取共享锁，如果成功则返回<code>true</code>，否则返回<code>false</code>。</li>\n<li><code>lock()</code>: 获取<mark>独占锁</mark>，如果当前有共享锁或独占锁，则阻塞。</li>\n<li><code>try_lock()</code>: 尝试获取独占锁，如果成功则返回<code>true</code>，否则返回<code>false</code>，不阻塞。</li>\n<li><code>try_lock_for(duration)</code>: 尝试在指定的时间段内获取独占锁，如果成功则返回<code>true</code>，否则返回<code>false</code>。</li>\n<li><code>unlock()</code>: 释放当前持有的锁（无论是共享锁还是独占锁）。</li>\n</ul>\n"},{"title":"C++ nodiscard","date":"2025-07-05T16:00:00.000Z","_content":"\n## nodiscard\n\n#### 用于标记函数的返回值：\n\n`[[nodiscard]] int Compute();`\n\n当调用该函数却不赋值返回结果时，将收到警告：\n\n``````cpp\nvoid Foo() {\n    Compute();\n}\n``````\n\n````cpp\nwarning: ignoring return value of 'int Compute()', declared with attribute nodiscard\n````\n\n#### 标记整个类型\n\n```cpp\n[[nodiscard]]\nstruct ImportantType {};\n\nImportantType CalcSuperImportant();\n```\n\n每当调用任何返回`ImportantType`的函数时，都会收到警告。\n\n#### 使用注意\n\n过多使用该关键字可能导致编译器编译时出现大量`warning`。","source":"_posts/C-Plus-Plus/c-plus-plus-17/nodiscard.md","raw":"---\ntitle: C++ nodiscard\ndate: 2025-07-06\n---\n\n## nodiscard\n\n#### 用于标记函数的返回值：\n\n`[[nodiscard]] int Compute();`\n\n当调用该函数却不赋值返回结果时，将收到警告：\n\n``````cpp\nvoid Foo() {\n    Compute();\n}\n``````\n\n````cpp\nwarning: ignoring return value of 'int Compute()', declared with attribute nodiscard\n````\n\n#### 标记整个类型\n\n```cpp\n[[nodiscard]]\nstruct ImportantType {};\n\nImportantType CalcSuperImportant();\n```\n\n每当调用任何返回`ImportantType`的函数时，都会收到警告。\n\n#### 使用注意\n\n过多使用该关键字可能导致编译器编译时出现大量`warning`。","slug":"C-Plus-Plus/c-plus-plus-17/nodiscard","published":1,"updated":"2025-09-14T02:36:11.008Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpy001m4e4payu5f7p2","content":"<h2 id=\"nodiscard\">nodiscard</h2>\n<h4 id=\"用于标记函数的返回值：\">用于标记函数的返回值：</h4>\n<p><code>[[nodiscard]] int Compute();</code></p>\n<p>当调用该函数却不赋值返回结果时，将收到警告：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Compute</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">warning: ignoring <span class=\"keyword\">return</span> value of <span class=\"string\">&#x27;int Compute()&#x27;</span>, declared with attribute nodiscard</span><br></pre></td></tr></table></figure>\n<h4 id=\"标记整个类型\">标记整个类型</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[nodiscard]]</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ImportantType</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ImportantType <span class=\"title\">CalcSuperImportant</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<p>每当调用任何返回<code>ImportantType</code>的函数时，都会收到警告。</p>\n<h4 id=\"使用注意\">使用注意</h4>\n<p>过多使用该关键字可能导致编译器编译时出现大量<code>warning</code>。</p>\n","excerpt":"","more":"<h2 id=\"nodiscard\">nodiscard</h2>\n<h4 id=\"用于标记函数的返回值：\">用于标记函数的返回值：</h4>\n<p><code>[[nodiscard]] int Compute();</code></p>\n<p>当调用该函数却不赋值返回结果时，将收到警告：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Compute</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">warning: ignoring <span class=\"keyword\">return</span> value of <span class=\"string\">&#x27;int Compute()&#x27;</span>, declared with attribute nodiscard</span><br></pre></td></tr></table></figure>\n<h4 id=\"标记整个类型\">标记整个类型</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[nodiscard]]</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ImportantType</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ImportantType <span class=\"title\">CalcSuperImportant</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<p>每当调用任何返回<code>ImportantType</code>的函数时，都会收到警告。</p>\n<h4 id=\"使用注意\">使用注意</h4>\n<p>过多使用该关键字可能导致编译器编译时出现大量<code>warning</code>。</p>\n"},{"title":"C++ 内存对齐","date":"2025-07-05T16:00:00.000Z","_content":"\n### C++ 内存对齐\n\n","source":"_posts/C-Plus-Plus/对象模型/内存对齐.md","raw":"---\ntitle: C++ 内存对齐\ndate: 2025-07-06\ntags: [C++, 对象模型]\ncategories: C++\n---\n\n### C++ 内存对齐\n\n","slug":"C-Plus-Plus/对象模型/内存对齐","published":1,"updated":"2025-09-14T02:36:11.008Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpz001p4e4p76mrfy0p","content":"<h3 id=\"C-内存对齐\">C++ 内存对齐</h3>\n","excerpt":"","more":"<h3 id=\"C-内存对齐\">C++ 内存对齐</h3>\n"},{"title":"内存序","date":"2025-07-05T16:00:00.000Z","description":"C++ 内存序","_content":"\n### 什么是内存序\n\n内存顺序是指在并发编程中, 对内存读写操作的执行顺序。这个顺序可以被编译器和处理器进行优化, 可能会与代码中的顺序不同, 这被称为指令重排.","source":"_posts/C-Plus-Plus/并发/内存序.md","raw":"---\ntitle: 内存序\ndate: 2025-07-06\ndescription: C++ 内存序\n---\n\n### 什么是内存序\n\n内存顺序是指在并发编程中, 对内存读写操作的执行顺序。这个顺序可以被编译器和处理器进行优化, 可能会与代码中的顺序不同, 这被称为指令重排.","slug":"C-Plus-Plus/并发/内存序","published":1,"updated":"2025-09-14T02:36:11.008Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lpz001s4e4p2a0405he","content":"<h3 id=\"什么是内存序\">什么是内存序</h3>\n<p>内存顺序是指在并发编程中, 对内存读写操作的执行顺序。这个顺序可以被编译器和处理器进行优化, 可能会与代码中的顺序不同, 这被称为指令重排.</p>\n","excerpt":"","more":"<h3 id=\"什么是内存序\">什么是内存序</h3>\n<p>内存顺序是指在并发编程中, 对内存读写操作的执行顺序。这个顺序可以被编译器和处理器进行优化, 可能会与代码中的顺序不同, 这被称为指令重排.</p>\n"},{"title":"原子操作","date":"2025-07-05T16:00:00.000Z","description":"原子操作","_content":"\n### 原子操作","source":"_posts/C-Plus-Plus/并发/原子操作.md","raw":"---\ntitle: 原子操作\ndate: 2025-07-06\ndescription: 原子操作\n---\n\n### 原子操作","slug":"C-Plus-Plus/并发/原子操作","published":1,"updated":"2025-09-14T02:36:11.009Z","comments":1,"layout":"post","photos":[],"_id":"cmfja9lq0001w4e4pd6zwben6","content":"<h3 id=\"原子操作\">原子操作</h3>\n","excerpt":"","more":"<h3 id=\"原子操作\">原子操作</h3>\n"},{"title":"大顶堆/小顶堆","date":"2025-07-19T16:00:00.000Z","updated":"2025-07-20T16:00:00.000Z","_content":"\n### 堆\n\n","source":"_posts/数据结构/堆/大顶堆.md","raw":"---\ntitle: 大顶堆/小顶堆\ndate: 2025-07-20\nupdated: 2025-07-21\ntags: [数据结构, 堆, 优先级队列, C++]\ncategories: 数据结构\n---\n\n### 堆\n\n","slug":"数据结构/堆/大顶堆","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfja9lq0001z4e4phr0lhziv","content":"<h3 id=\"堆\">堆</h3>\n","excerpt":"","more":"<h3 id=\"堆\">堆</h3>\n"},{"title":"平衡二叉树(AVL)","date":"2025-07-11T16:00:00.000Z","updated":"2025-07-15T16:00:00.000Z","_content":"\n\n如果插入二叉搜索树的元素在插入之前就已经有序，那么插入后的二叉搜索树会退化为链表。在这种情况下，所有操作的时间复杂度将从 $O(log_2n)$ 劣化为 $O(n)$ 。因此产生了平衡二叉树，能够实现在插入、删除时保持树的平衡，避免树退化为链表。平衡二叉树全称为：平衡二叉搜索树(`Balanced Binary Search Tree`).\n\n### 特点：\n\n1. **自平衡**：在插入或删除节点时，`AVL`树会通过旋转操作（如左旋、右旋、左右旋、右左旋）来保持树的平衡。\n2. 如果一个树是`AVL`树，那么它的左右子树都是`AVL`树。\n3. 树中任意一个节点的平衡因子绝对值不超过1。\n\n   平衡因子：默认每个节点的平衡因子=`左子树高度-右子树高度`。（或者`右子树高度-左子树高度`）\n\n### 实现\n\n基本节点：\n\n```cpp\ntypedef struct AVLNode {\n    int data;\n    int height{1}; // 节点高度：表示从当前节点到距离他最远的叶子节点的距离+1（叶子节点高度为1，空节点高度为0）\n    AVLNode *left;\n    AVLNode *right;\n    AVLNode *parent; // 当前节点的双亲节点\n    AVLNode(int data) : data(data), left(nullptr), right(nullptr) {}\n    AVLNode(int data, AVLNode *left, AVLNode *right, AVLNode *parent) : AVLNode(data) {\n        this->parent = parent;\n        height = 1;\n    };\n} Node;\n```\n\n#### 插入\n\n##### 递归插入\n\n###### 逻辑\n\n- 调用递归函数，传入**要插入的树的根节点`root`**和**要插入的值`data`**。因为此处`AVLNode`还用到了`parent`指针，所以还需要传入`parent`指针，方便新建节点时指定其`parent`指针的值。\n\n- 如果`root==nullptr`说明是叶子节点。在该位置新建节点。存储要插入的值`data`,指定`height`为`1`(叶子节点高度为1)，同时指定`parent`指针为传入的`parent`参数。<mark>递归结束</mark>。\n\n  > 因为此处新增了叶子节点，叶子节点高度指定为1，所以可以直接结束递归，不需要更新`root`(叶子节点)的高度。至于`root->parent`的高度，会在上层递归中更新。\n\n- 判断要插入的值`data`和当前树的根节点`root->data`的大小关系。\n\n  - `data < root->data`：递归插入到左子树`root->left`。插入到`root->left`后，需要判断`root`是否失衡。此处因为知晓插入到了`root->left`子树，所以只存在两种失衡情况：\n    - 新增节点插入到了`root->left->left`子树上，符合`LL`情况，执行**右旋**。\n    - 新增节点插入到了`root->left->right`子树上，符合`LR`情况，执行**左右双旋**。\n  - `data > root->data`：递归插入到右子树`root->right`。插入到`root->right`后，需要判断`root`是否失衡。此处因为知晓插入到了`root->right`子树，所以只存在两种失衡情况：\n    - 新增节点插入到了`root->right->right`子树上，符合`RR`情况，执行**左旋**。\n    - 新增节点插入到了`root->right->left`子树上，符合`RL`情况，执行**右左双旋**。\n  - `data == root->data`：提示要插入的值已经存在。**插入失败**。\n\n- 插入并且旋转完成后，更新`root`节点的高度。（因为新增节点肯定插入了`root->left`或者`root->right`子树，可能导致`root`的高度发生变化）。<mark>递归结束</mark>。\n\n###### 代码实现\n\n```cpp\n// 插入(递归实现)\nNode *insert_recursion(Node *root, Node *parent, int data) {\n    if (root == nullptr) {\n        // 新插入一个节点。新插入的节点一定是叶子节点，所以该节点的高度为1（类内初始化）\n        return new Node(data, nullptr, nullptr, parent);\n    } else if (root->data > data) {\n        root->left = insert_recursion(root->left, root, data);\n        // 插入后判断root是否失衡。因为插入的是root->left，所以只需要考虑root左边过高的情况\n        if (abs(get_balance(root)) == 2) { // root节点失衡\n            if (root->left != nullptr && data < root->left->data) {\n                // 执行右单旋操作。\n                root = right_rotate(root);\n            } else {\n                // 执行左右旋操作。\n                root = left_right_rotate(root);\n            }\n        }\n    } else if (root->data < data) {\n        root->right = insert_recursion(root->right, root, data);\n        // 判断root是否失衡\n        if (abs(get_balance(root)) == 2) {\n            if (root->right != nullptr && data > root->right->data) {\n                // 执行左单旋。\n                root = left_rotate(root);\n            } else {\n                // 执行右左旋。\n                root = right_left_rotate(root);\n            }\n        }\n    } else {\n        printf(\"ERROR! data already exist.\\n\");\n    }\n    // 无论插入情况如何，都要在插入后更新root节点的节点高度\n    update_height(root);\n    return root;\n}\n```\n\n\n\n##### 非递归插入\n\n> 待补充\n\n#### 删除\n\n##### 递归删除\n\n###### 逻辑\n\n- 调用**删除函数**。传入根节点指针`root`和要删除的值`data`。\n\n- 如果`root==nullptr`，说明没有找到`data`，删除失败。<mark>递归结束</mark>。\n\n- 如果`root!=nullptr`，比较`root->data`和`data`的大小关系。\n\n  - `root->data == data`，找到了要删除的节点。判断节点情况：\n\n    - `root`是叶子节点：将root节点从树中删除。然后`delete root`.\n\n    - `root`只有左子树，没有右子树：\n\n      - 判断`root`是否是整个`AVL`树的根节点(`root->parent==nullptr`)：如果不是，则在执行下面一段。否则跳过下面一段。\n\n        - 判断`root`是`root->parent`的左子树还是右子树：\n        - 左子树：执行`root->parent->left = root->left`从树中删除`root`节点，然后<mark>更新`root->parent`节点的高度</mark>。\n        - 右子树：执行`root->parent->right = root->left`从树中删除`root`节点，然后<mark>更新`root->parent`节点的高度</mark>。\n\n      - 更新`root->left`的父节点指针`parent`。然后`delete root`.\n\n        > 此处删除了`root`，但对`root->left`的平衡性没有影响。只是将`root->left`整体向上提高一层，取代`root`的位置。（因为`root->right==nullptr`）.\n        >\n        > 反倒是`root->parent`的平衡性可能受到影响，但是**`root->parent`的平衡性会在递归返回时被调整**。\n\n    - `root`只有右子树，没有左子树：\n\n      与上方逻辑类似\n\n    - `root`的左右子树都存在：\n\n      找到右子树中最小的值，覆盖`root->data`，然后再将右子树中最小的值(`minData`)删去：递归调用删除函数，传入`root->right`和`minData`。\n  \n  - `data < root->data`：\n  \n    - 要删除的`data`在`root`的左子树上。**递归调用删除函数**，传入左子树指针`root->left`和`data`。\n    - 递归删除完成后，更新`root`的高度，\n    - 然后平衡`root`节点（因为`root`的左子树删除了一个节点，高度可能发生变化，可能会影响`root`所在子树的平衡性）\n  \n  - `root->data < data`，要删除的`data`在`root`的右子树上。\n  \n    - **递归调用删除函数**，传入右子树指针`root->right`和`data`。\n    - 递归删除完成后，更新`root`的高度，\n    - 然后平衡`root`节点（因为`root`的右子树删除了一个节点，高度可能发生变化，可能会影响`root`所在子树的平衡性）\n\n###### 代码实现\n\n```cpp\n// 删除(递归实现)\nNode *delete_recursion(Node *root, int data) {\n    if (root != nullptr) {\n        if (root->data == data) { // 找到要删除的节点\n            printf(\"delete: %d\\n\", data);\n            if (root->right == nullptr && root->left != nullptr) { // root只有左孩子，没有右孩子\n                if (root->parent != nullptr) { // 考虑root是否是整个树的根节点\n                    if (root->data > root->parent->data) { // root是root->parent的右孩子\n                        root->parent->right = root->left;\n                    } else { // root是root->parent的左孩子\n                        root->parent->left = root->left;\n                    }\n                    update_height(root->parent); // 因为删除了root节点，所以要更新root->parent节点的高度\n                }\n                root->left->parent = root->parent; // 更新父节点指针\n                // 执行平衡操作? 似乎多余? root->left本来就是平衡的，只是取代了root，对root->left的平衡性没有影响。\n                // root->left = balance(root->left);\n                Node *temp = root->left;\n                delete root;\n                root = temp; // root节点从树中删除，root->left取代root\n            } else if (root->left == nullptr && root->right != nullptr) { // root只有右孩子，没有左孩子\n                if (root->parent != nullptr) {\n                    if (root->data > root->parent->data) {\n                        root->parent->right = root->right;\n                    } else {\n                        root->parent->left = root->right;\n                    }\n                    update_height(root->parent);\n                }\n                root->right->parent = root->parent;\n                // root->right = balance(root->right);\n                Node *temp = root->right;\n                delete root;\n                root = temp;\n            } else if (root->left != nullptr && root->right != nullptr) { // 左右孩子都有\n                Node *temp = root->right;\n                while (temp->left != nullptr) { // 找到root的右子树中的最小节点\n                    temp = temp->left;\n                }\n                int val = temp->data;\n                root->right = delete_recursion(root->right, val);\n                root->data = val;\n                update_height(root); // root的右子树发生了变动，更新root的高度\n                root = balance(root);\n            } else { // root是叶子节点\n                if (root->parent != nullptr) { // root存在父节点\n                    if (root->parent->data < root->data) { // root是其父亲节点的右孩子\n                        root->parent->right = nullptr; // 删去root节点\n                    } else { // root是其父亲节点的左孩子\n                        root->parent->left = nullptr;\n                    }\n                    update_height(root->parent);\n                }\n                delete root;\n                root = nullptr;\n            }\n\n        } else if (data < root->data) {\n            root->left = delete_recursion(root->left, data);\n            update_height(root);\n            root = balance(root);\n        } else {\n            root->right = delete_recursion(root->right, data);\n            update_height(root);\n            root = balance(root);\n        }\n    } else {\n        printf(\"Key to be deleted could not be found.\\n\");\n    }\n\n    return root;\n}\n\n// 平衡root节点\nNode *balance(Node *root) {\n    int balance_factor = get_balance(root);\n    if (abs(balance_factor) == 2) {\n        if (balance_factor < 0) { // root节点的右子树高度 > 左子树高度\n            if (get_balance(root->right) == 1) { // root->right的左子树高度 > 右子树高度，root节点符合RL失衡，执行左右双旋\n                root = right_left_rotate(root);\n            } else { // root->right的右子树高度 > 左子树高度，root节点符合RR失衡，执行左单旋\n                root = left_rotate(root);\n            }\n        } else { // root节点的右子树高度 < 左子树高度\n            if (get_balance(root->left) == 1) { // root->left的左子树高度 > 右子树高度，root节点符合LL失衡，执行右单旋\n                root = right_rotate(root);\n            } else { // root->right的右子树高度 > 左子树高度，root节点符合LR失衡，执行右左双旋\n                root = left_right_rotate(root);\n            }\n        }\n    }\n    return root;\n}\n```\n\n\n\n##### 非递归删除\n\n> 待补充\n\n#### 查询\n\n##### 递归查询\n\n###### 逻辑\n\n- 调用递归查询函数，传入树的根节点`root`和要查询的值`data`。\n- 如果`root==nullptr`，说明递归到了叶子节点下的空节点，或者整个树为空，即：没有找到目标值。返回`false`，递归结束。\n  - 如果`root->data==data`，找到目标值，返回`true`，递归结束。\n  - 如果`root->data > data`，递归左子树。返回左子树的递归结果。\n  - 如果`root->data < data`，递归右子树。返回右子树的递归结果。\n\n###### 代码实现：\n\n```cpp\n// 查询(递归实现)\nbool search(const Node *root, const int &data) {\n    if (root == nullptr) {\n        return false;\n    }\n    if (root->data == data) {\n        return true;\n    } else if (data < root->data) {\n        return search(root->left, data);\n    } else {\n        return search(root->right, data);\n    }\n}\n```\n\n\n\n##### 非递归查询\n\n待补充\n\n#### 核心算法：旋转操作\n\n##### 左旋\n\n![左旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250721222714402.png)\n\nC++实现：\n\n```cpp\n/**\n * @brief root节点失衡，对root和root->right进行左旋操作。\n * @param root 失衡节点\n */\nNode *left_rotate(Node *root) {\n    Node *childR = root->right;\n    Node *childRL = childR->left;\n\n    root->right = childRL;\n    childR->left = root;\n\n    if (childRL != nullptr) {\n        childRL->parent = root;\n    }\n    childR->parent = root->parent;\n    root->parent = childR;\n    if (childR->parent != nullptr) {\n        if (childR->data < childR->parent->data) {\n            childR->parent->left = childR;\n        } else {\n            childR->parent->right = childR;\n        }\n    }\n\n    root = childR;\n    update_height(root->left);\n    update_height(root->right);\n    update_height(root);\n    update_height(root->parent);\n\n    return root;\n}\n```\n\n\n\n##### 右旋\n\n![右旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250721222747055.png)\n\nC++实现：\n\n```cpp\n/**\n * @brief root节点失衡，对root和root->left执行右旋操作。\n * @param root 失衡节点\n */\nNode *right_rotate(Node *root) {\n    Node *childL = root->left;\n    Node *childLR = childL->right;\n\n    /**\n     * 如果只使用了height属性，没有使用parent属性，则只需要 下面两行语句 和 root=Lchild 以及 四个update_height()即可完成旋转。\n     * 如果使用了parent则需要加入剩余的代码。\n     */\n    root->left = childLR;\n    childL->right = root;\n\n    if (childLR != nullptr) {\n        // 说明原root->left->right非空，需要更新它的父节点指针。\n        childLR->parent = root;\n    }\n    childL->parent = root->parent;\n    root->parent = childL;\n    if (childL->parent != nullptr) {\n        if (root->data < childL->parent->data) {\n            // 原root节点挂载在root->parent的左边，旋转后将新树也挂载在左边\n            childL->parent->left = childL;\n        } else {\n            // 否则挂载到右边\n            childL->parent->right = childL;\n        }\n    }\n\n    root = childL;\n    update_height(root->left);\n    update_height(root->right);\n    update_height(root);\n    update_height(root->parent); // 注意此处需要更新root->parent的高度，因为root->parent的其中一个子树(也就是root)高度改变，所以会影响root->parent的高度\n\n    return root;\n}\n```\n\n\n\n##### 左右双旋\n\n先左旋，再右旋\n\n![左右双旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250721223004318.png)\n\nC++实现：\n\n```cpp\n/**\n * @brief 左右旋\n */\nNode *left_right_rotate(Node *root) {\n    // 先对root->left和root->left->right进行左单旋\n    root->left = left_rotate(root->left);\n    // 在对root和root->left进行右单旋\n    return right_rotate(root);\n}\n```\n\n\n\n##### 右左双旋\n\n先右旋，再左旋\n\n![右左双旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250721222927312.png)\n\nC++实现：\n\n```cpp\n/**\n * @brief 右左旋\n */\nNode *right_left_rotate(Node *root) {\n    // 先对root->right和root->right->left进行右单旋\n    root->right = right_rotate(root->right);\n    // 再对root和root->right进行左单旋\n    return left_rotate(root);\n}\n```\n\n#### 完整代码实现：\n\n```cpp\n#include <iostream>\n#include <queue>\n#include <iomanip>\n#include <cstring>\nusing namespace std;\n\nclass AVLTree {\npublic:\n    typedef struct AVLNode {\n        int data;\n        int height{1}; // 节点高度：表示从当前节点到距离他最远的叶子节点的距离+1（叶子节点高度为1，空节点高度为0）\n        AVLNode *left;\n        AVLNode *right;\n        AVLNode *parent; // 当前节点的双亲节点\n        AVLNode(int data) : data(data), left(nullptr), right(nullptr) {}\n        AVLNode(int data, AVLNode *left, AVLNode *right, AVLNode *parent) : AVLNode(data) {\n            this->parent = parent;\n            height = 1;\n        };\n    } Node;\n\n    AVLTree() : root(nullptr) {}\n\n    AVLTree(int data) {\n        root = new Node(data);\n    }\n\n    ~AVLTree() {\n        delete_tree(root);\n    }\n\n    void insert_node(int data) {\n        root = insert_recursion(root, nullptr, data); // 直接调用递归函数进行插入\n\n        /**\n         * 待补充: 非递归的插入方法\n         */\n    }\n\n    void delete_node(int data) {\n        root = delete_recursion(root, data); // 调用递归的删除方法\n\n        /**\n         * 待补充: 非递归的删除方法\n         */\n    }\n\n    bool search(int data) {\n        return search(root, data); // 调用递归的查询方法\n\n        /**\n         * 待补充: 非递归的查询方法\n         */\n    }\n\n    Node *get_root() {\n        return this->root;\n    }\n\nprivate:\n    Node *root;\n\n    // 插入(递归实现)\n    Node *insert_recursion(Node *root, Node *parent, int data) {\n        if (root == nullptr) {\n            // 新插入一个节点。新插入的节点一定是叶子节点，所以该节点的高度为1（类内初始化）\n            return new Node(data, nullptr, nullptr, parent);\n        } else if (root->data > data) {\n            root->left = insert_recursion(root->left, root, data);\n            // 插入后判断root是否失衡。因为插入的是root->left，所以只需要考虑root左边过高的情况\n            if (abs(get_balance(root)) == 2) { // root节点失衡\n                if (root->left != nullptr && data < root->left->data) {\n                    // 执行右单旋操作。\n                    root = right_rotate(root);\n                } else {\n                    // 执行左右旋操作。\n                    root = left_right_rotate(root);\n                }\n            }\n        } else if (root->data < data) {\n            root->right = insert_recursion(root->right, root, data);\n            // 判断root是否失衡\n            if (abs(get_balance(root)) == 2) {\n                if (root->right != nullptr && data > root->right->data) {\n                    // 执行左单旋。\n                    root = left_rotate(root);\n                } else {\n                    // 执行右左旋。\n                    root = right_left_rotate(root);\n                }\n            }\n        } else {\n            printf(\"ERROR! data already exist.\\n\");\n        }\n        // 无论插入情况如何，都要在插入后更新root节点的节点高度\n        update_height(root);\n        return root;\n    }\n\n    // 删除(递归实现)\n    Node *delete_recursion(Node *root, int data) {\n        if (root != nullptr) {\n            if (root->data == data) { // 找到要删除的节点\n                printf(\"delete: %d\\n\", data);\n                if (root->right == nullptr && root->left != nullptr) { // root只有左孩子，没有右孩子\n                    if (root->parent != nullptr) { // 考虑root是否是整个树的根节点\n                        if (root->data > root->parent->data) { // root是root->parent的右孩子\n                            root->parent->right = root->left;\n                        } else { // root是root->parent的左孩子\n                            root->parent->left = root->left;\n                        }\n                        update_height(root->parent); // 因为删除了root节点，所以要更新root->parent节点的高度\n                    }\n                    root->left->parent = root->parent; // 更新父节点指针\n                    // 执行平衡操作? 似乎多余? root->left本来就是平衡的，只是取代了root，对root->left的平衡性没有影响。\n                    // root->left = balance(root->left);\n                    Node *temp = root->left;\n                    delete root;\n                    root = temp; // root节点从树中删除，root->left取代root\n                } else if (root->left == nullptr && root->right != nullptr) { // root只有右孩子，没有左孩子\n                    if (root->parent != nullptr) {\n                        if (root->data > root->parent->data) {\n                            root->parent->right = root->right;\n                        } else {\n                            root->parent->left = root->right;\n                        }\n                        update_height(root->parent);\n                    }\n                    root->right->parent = root->parent;\n                    // root->right = balance(root->right);\n                    Node *temp = root->right;\n                    delete root;\n                    root = temp;\n                } else if (root->left != nullptr && root->right != nullptr) { // 左右孩子都有\n                    Node *temp = root->right;\n                    while (temp->left != nullptr) { // 找到root的右子树中的最小节点\n                        temp = temp->left;\n                    }\n                    int val = temp->data;\n                    root->right = delete_recursion(root->right, val);\n                    root->data = val;\n                    update_height(root); // root的右子树发生了变动，更新root的高度\n                    root = balance(root);\n                } else { // root是叶子节点\n                    if (root->parent != nullptr) { // root存在父节点\n                        if (root->parent->data < root->data) { // root是其父亲节点的右孩子\n                            root->parent->right = nullptr; // 删去root节点\n                        } else { // root是其父亲节点的左孩子\n                            root->parent->left = nullptr;\n                        }\n                        update_height(root->parent);\n                    }\n                    delete root;\n                    root = nullptr;\n                }\n\n            } else if (data < root->data) {\n                root->left = delete_recursion(root->left, data);\n                update_height(root);\n                root = balance(root);\n            } else {\n                root->right = delete_recursion(root->right, data);\n                update_height(root);\n                root = balance(root);\n            }\n        } else {\n            printf(\"Key to be deleted could not be found.\\n\");\n        }\n\n        return root;\n    }\n\n    // 查询(递归实现)\n    bool search(const Node *root, const int &data) {\n        if (root == nullptr) {\n            return false;\n        }\n        if (root->data == data) {\n            return true;\n        } else if (data < root->data) {\n            return search(root->left, data);\n        } else {\n            return search(root->right, data);\n        }\n    }\n\n    // 获取节点高度\n    int node_height(Node *node) {\n        if (node == nullptr) {\n            return 0;\n        }\n        return node->height;\n    }\n\n    // 更新节点高度\n    void update_height(Node *root) {\n        if (root != nullptr) {\n            // update height\n            root->height = std::max(node_height(root->left), node_height(root->right)) + 1;\n        }\n    }\n\n    /**\n     * @brief 获取node节点的平衡因子。\n     * @param node 要获取平衡因子的节点\n     * @return  - 如果node是非叶子节点，平衡因子 = 左子树高度 - 右子树高度;\n     *\n     *          - 如果node是叶子节点，平衡因子 = 1\n     *\n     *          - 如果node是空节点，平衡因子 = 0\n     */\n    int get_balance(Node *node) {\n        if (node == nullptr) {\n            return 0;\n        }\n        return node_height(node->left) - node_height(node->right);\n    }\n\n    /**\n     * @brief root节点失衡，对root和root->left执行右旋操作。\n     * @param root 失衡节点\n     */\n    Node *right_rotate(Node *root) {\n        Node *childL = root->left;\n        Node *childLR = childL->right;\n\n        /**\n         * 如果只使用了height属性，没有使用parent属性，则只需要 下面两行语句 和 root=Lchild 以及 四个update_height()即可完成旋转。\n         * 如果使用了parent则需要加入剩余的代码。\n         */\n        root->left = childLR;\n        childL->right = root;\n\n        if (childLR != nullptr) {\n            // 说明原root->left->right非空，需要更新它的父节点指针。\n            childLR->parent = root;\n        }\n        childL->parent = root->parent;\n        root->parent = childL;\n        if (childL->parent != nullptr) {\n            if (root->data < childL->parent->data) {\n                // 原root节点挂载在root->parent的左边，旋转后将新树也挂载在左边\n                childL->parent->left = childL;\n            } else {\n                // 否则挂载到右边\n                childL->parent->right = childL;\n            }\n        }\n\n        root = childL;\n        update_height(root->left);\n        update_height(root->right);\n        update_height(root);\n        update_height(root->parent); // 注意此处需要更新root->parent的高度，因为root->parent的其中一个子树(也就是root)高度改变，所以会影响root->parent的高度\n\n        return root;\n    }\n\n    /**\n     * @brief root节点失衡，对root和root->right进行左旋操作。\n     * @param root 失衡节点\n     */\n    Node *left_rotate(Node *root) {\n        Node *childR = root->right;\n        Node *childRL = childR->left;\n\n        root->right = childRL;\n        childR->left = root;\n\n        if (childRL != nullptr) {\n            childRL->parent = root;\n        }\n        childR->parent = root->parent;\n        root->parent = childR;\n        if (childR->parent != nullptr) {\n            if (childR->data < childR->parent->data) {\n                childR->parent->left = childR;\n            } else {\n                childR->parent->right = childR;\n            }\n        }\n\n        root = childR;\n        update_height(root->left);\n        update_height(root->right);\n        update_height(root);\n        update_height(root->parent);\n\n        return root;\n    }\n\n    /**\n     * @brief 左右旋\n     */\n    Node *left_right_rotate(Node *root) {\n        // 先对root->left和root->left->right进行左单旋\n        root->left = left_rotate(root->left);\n        // 在对root和root->left进行右单旋\n        return right_rotate(root);\n    }\n\n    /**\n     * @brief 右左旋\n     */\n    Node *right_left_rotate(Node *root) {\n        // 先对root->right和root->right->left进行右单旋\n        root->right = right_rotate(root->right);\n        // 再对root和root->right进行左单旋\n        return left_rotate(root);\n    }\n\n    // 平衡root节点\n    Node *balance(Node *root) {\n        int balance_factor = get_balance(root);\n        if (abs(balance_factor) == 2) {\n            if (balance_factor < 0) { // root节点的右子树高度 > 左子树高度\n                if (get_balance(root->right) == 1) { // root->right的左子树高度 > 右子树高度，root节点符合RL失衡，执行左右双旋\n                    root = right_left_rotate(root);\n                } else { // root->right的右子树高度 > 左子树高度，root节点符合RR失衡，执行左单旋\n                    root = left_rotate(root);\n                }\n            } else { // root节点的右子树高度 < 左子树高度\n                if (get_balance(root->left) == 1) { // root->left的左子树高度 > 右子树高度，root节点符合LL失衡，执行右单旋\n                    root = right_rotate(root);\n                } else { // root->right的右子树高度 > 左子树高度，root节点符合LR失衡，执行右左双旋\n                    root = left_right_rotate(root);\n                }\n            }\n        }\n        return root;\n    }\n\n    void delete_tree(AVLTree::Node *root) {\n        if (root == nullptr) {\n            return;\n        }\n        delete_tree(root->left);\n        delete_tree(root->right);\n        printf(\"released node: %d\\n\", root->data);\n        delete root;\n    }\n};\n\nvoid printInOrder(AVLTree::Node *root) {\n    if (root == nullptr) {\n        return;\n    }\n    printInOrder(root->left);\n    printf(\"%d \", root->data);\n    printInOrder(root->right);\n}\n\nint main() {\n    AVLTree avl;\n\n    int *arr = new int[12]{10, 20, 45, 30, 12, 40, 50, 25, 14, 52, 75, 19};\n\n    for (int i = 0; i < 12; ++i) {\n        avl.insert_node(arr[i]);\n    }\n\n    for (int i = 0; i < 12; ++i) {\n        if (avl.search(arr[i])) {\n            printf(\"find: %d\\n\", arr[i]);\n            avl.delete_node(arr[i]);\n        }\n    }\n\n    delete[] arr;\n\n    return 0;\n}\n```\n\n","source":"_posts/数据结构/树/BalancedBinarySearchTree(AVL).md","raw":"---\ntitle: 平衡二叉树(AVL)\ndate: 2025-07-12\nupdated: 2025-07-16\ntags: [数据结构, 二叉树, C++, 树]\ncategories: 数据结构\n---\n\n\n如果插入二叉搜索树的元素在插入之前就已经有序，那么插入后的二叉搜索树会退化为链表。在这种情况下，所有操作的时间复杂度将从 $O(log_2n)$ 劣化为 $O(n)$ 。因此产生了平衡二叉树，能够实现在插入、删除时保持树的平衡，避免树退化为链表。平衡二叉树全称为：平衡二叉搜索树(`Balanced Binary Search Tree`).\n\n### 特点：\n\n1. **自平衡**：在插入或删除节点时，`AVL`树会通过旋转操作（如左旋、右旋、左右旋、右左旋）来保持树的平衡。\n2. 如果一个树是`AVL`树，那么它的左右子树都是`AVL`树。\n3. 树中任意一个节点的平衡因子绝对值不超过1。\n\n   平衡因子：默认每个节点的平衡因子=`左子树高度-右子树高度`。（或者`右子树高度-左子树高度`）\n\n### 实现\n\n基本节点：\n\n```cpp\ntypedef struct AVLNode {\n    int data;\n    int height{1}; // 节点高度：表示从当前节点到距离他最远的叶子节点的距离+1（叶子节点高度为1，空节点高度为0）\n    AVLNode *left;\n    AVLNode *right;\n    AVLNode *parent; // 当前节点的双亲节点\n    AVLNode(int data) : data(data), left(nullptr), right(nullptr) {}\n    AVLNode(int data, AVLNode *left, AVLNode *right, AVLNode *parent) : AVLNode(data) {\n        this->parent = parent;\n        height = 1;\n    };\n} Node;\n```\n\n#### 插入\n\n##### 递归插入\n\n###### 逻辑\n\n- 调用递归函数，传入**要插入的树的根节点`root`**和**要插入的值`data`**。因为此处`AVLNode`还用到了`parent`指针，所以还需要传入`parent`指针，方便新建节点时指定其`parent`指针的值。\n\n- 如果`root==nullptr`说明是叶子节点。在该位置新建节点。存储要插入的值`data`,指定`height`为`1`(叶子节点高度为1)，同时指定`parent`指针为传入的`parent`参数。<mark>递归结束</mark>。\n\n  > 因为此处新增了叶子节点，叶子节点高度指定为1，所以可以直接结束递归，不需要更新`root`(叶子节点)的高度。至于`root->parent`的高度，会在上层递归中更新。\n\n- 判断要插入的值`data`和当前树的根节点`root->data`的大小关系。\n\n  - `data < root->data`：递归插入到左子树`root->left`。插入到`root->left`后，需要判断`root`是否失衡。此处因为知晓插入到了`root->left`子树，所以只存在两种失衡情况：\n    - 新增节点插入到了`root->left->left`子树上，符合`LL`情况，执行**右旋**。\n    - 新增节点插入到了`root->left->right`子树上，符合`LR`情况，执行**左右双旋**。\n  - `data > root->data`：递归插入到右子树`root->right`。插入到`root->right`后，需要判断`root`是否失衡。此处因为知晓插入到了`root->right`子树，所以只存在两种失衡情况：\n    - 新增节点插入到了`root->right->right`子树上，符合`RR`情况，执行**左旋**。\n    - 新增节点插入到了`root->right->left`子树上，符合`RL`情况，执行**右左双旋**。\n  - `data == root->data`：提示要插入的值已经存在。**插入失败**。\n\n- 插入并且旋转完成后，更新`root`节点的高度。（因为新增节点肯定插入了`root->left`或者`root->right`子树，可能导致`root`的高度发生变化）。<mark>递归结束</mark>。\n\n###### 代码实现\n\n```cpp\n// 插入(递归实现)\nNode *insert_recursion(Node *root, Node *parent, int data) {\n    if (root == nullptr) {\n        // 新插入一个节点。新插入的节点一定是叶子节点，所以该节点的高度为1（类内初始化）\n        return new Node(data, nullptr, nullptr, parent);\n    } else if (root->data > data) {\n        root->left = insert_recursion(root->left, root, data);\n        // 插入后判断root是否失衡。因为插入的是root->left，所以只需要考虑root左边过高的情况\n        if (abs(get_balance(root)) == 2) { // root节点失衡\n            if (root->left != nullptr && data < root->left->data) {\n                // 执行右单旋操作。\n                root = right_rotate(root);\n            } else {\n                // 执行左右旋操作。\n                root = left_right_rotate(root);\n            }\n        }\n    } else if (root->data < data) {\n        root->right = insert_recursion(root->right, root, data);\n        // 判断root是否失衡\n        if (abs(get_balance(root)) == 2) {\n            if (root->right != nullptr && data > root->right->data) {\n                // 执行左单旋。\n                root = left_rotate(root);\n            } else {\n                // 执行右左旋。\n                root = right_left_rotate(root);\n            }\n        }\n    } else {\n        printf(\"ERROR! data already exist.\\n\");\n    }\n    // 无论插入情况如何，都要在插入后更新root节点的节点高度\n    update_height(root);\n    return root;\n}\n```\n\n\n\n##### 非递归插入\n\n> 待补充\n\n#### 删除\n\n##### 递归删除\n\n###### 逻辑\n\n- 调用**删除函数**。传入根节点指针`root`和要删除的值`data`。\n\n- 如果`root==nullptr`，说明没有找到`data`，删除失败。<mark>递归结束</mark>。\n\n- 如果`root!=nullptr`，比较`root->data`和`data`的大小关系。\n\n  - `root->data == data`，找到了要删除的节点。判断节点情况：\n\n    - `root`是叶子节点：将root节点从树中删除。然后`delete root`.\n\n    - `root`只有左子树，没有右子树：\n\n      - 判断`root`是否是整个`AVL`树的根节点(`root->parent==nullptr`)：如果不是，则在执行下面一段。否则跳过下面一段。\n\n        - 判断`root`是`root->parent`的左子树还是右子树：\n        - 左子树：执行`root->parent->left = root->left`从树中删除`root`节点，然后<mark>更新`root->parent`节点的高度</mark>。\n        - 右子树：执行`root->parent->right = root->left`从树中删除`root`节点，然后<mark>更新`root->parent`节点的高度</mark>。\n\n      - 更新`root->left`的父节点指针`parent`。然后`delete root`.\n\n        > 此处删除了`root`，但对`root->left`的平衡性没有影响。只是将`root->left`整体向上提高一层，取代`root`的位置。（因为`root->right==nullptr`）.\n        >\n        > 反倒是`root->parent`的平衡性可能受到影响，但是**`root->parent`的平衡性会在递归返回时被调整**。\n\n    - `root`只有右子树，没有左子树：\n\n      与上方逻辑类似\n\n    - `root`的左右子树都存在：\n\n      找到右子树中最小的值，覆盖`root->data`，然后再将右子树中最小的值(`minData`)删去：递归调用删除函数，传入`root->right`和`minData`。\n  \n  - `data < root->data`：\n  \n    - 要删除的`data`在`root`的左子树上。**递归调用删除函数**，传入左子树指针`root->left`和`data`。\n    - 递归删除完成后，更新`root`的高度，\n    - 然后平衡`root`节点（因为`root`的左子树删除了一个节点，高度可能发生变化，可能会影响`root`所在子树的平衡性）\n  \n  - `root->data < data`，要删除的`data`在`root`的右子树上。\n  \n    - **递归调用删除函数**，传入右子树指针`root->right`和`data`。\n    - 递归删除完成后，更新`root`的高度，\n    - 然后平衡`root`节点（因为`root`的右子树删除了一个节点，高度可能发生变化，可能会影响`root`所在子树的平衡性）\n\n###### 代码实现\n\n```cpp\n// 删除(递归实现)\nNode *delete_recursion(Node *root, int data) {\n    if (root != nullptr) {\n        if (root->data == data) { // 找到要删除的节点\n            printf(\"delete: %d\\n\", data);\n            if (root->right == nullptr && root->left != nullptr) { // root只有左孩子，没有右孩子\n                if (root->parent != nullptr) { // 考虑root是否是整个树的根节点\n                    if (root->data > root->parent->data) { // root是root->parent的右孩子\n                        root->parent->right = root->left;\n                    } else { // root是root->parent的左孩子\n                        root->parent->left = root->left;\n                    }\n                    update_height(root->parent); // 因为删除了root节点，所以要更新root->parent节点的高度\n                }\n                root->left->parent = root->parent; // 更新父节点指针\n                // 执行平衡操作? 似乎多余? root->left本来就是平衡的，只是取代了root，对root->left的平衡性没有影响。\n                // root->left = balance(root->left);\n                Node *temp = root->left;\n                delete root;\n                root = temp; // root节点从树中删除，root->left取代root\n            } else if (root->left == nullptr && root->right != nullptr) { // root只有右孩子，没有左孩子\n                if (root->parent != nullptr) {\n                    if (root->data > root->parent->data) {\n                        root->parent->right = root->right;\n                    } else {\n                        root->parent->left = root->right;\n                    }\n                    update_height(root->parent);\n                }\n                root->right->parent = root->parent;\n                // root->right = balance(root->right);\n                Node *temp = root->right;\n                delete root;\n                root = temp;\n            } else if (root->left != nullptr && root->right != nullptr) { // 左右孩子都有\n                Node *temp = root->right;\n                while (temp->left != nullptr) { // 找到root的右子树中的最小节点\n                    temp = temp->left;\n                }\n                int val = temp->data;\n                root->right = delete_recursion(root->right, val);\n                root->data = val;\n                update_height(root); // root的右子树发生了变动，更新root的高度\n                root = balance(root);\n            } else { // root是叶子节点\n                if (root->parent != nullptr) { // root存在父节点\n                    if (root->parent->data < root->data) { // root是其父亲节点的右孩子\n                        root->parent->right = nullptr; // 删去root节点\n                    } else { // root是其父亲节点的左孩子\n                        root->parent->left = nullptr;\n                    }\n                    update_height(root->parent);\n                }\n                delete root;\n                root = nullptr;\n            }\n\n        } else if (data < root->data) {\n            root->left = delete_recursion(root->left, data);\n            update_height(root);\n            root = balance(root);\n        } else {\n            root->right = delete_recursion(root->right, data);\n            update_height(root);\n            root = balance(root);\n        }\n    } else {\n        printf(\"Key to be deleted could not be found.\\n\");\n    }\n\n    return root;\n}\n\n// 平衡root节点\nNode *balance(Node *root) {\n    int balance_factor = get_balance(root);\n    if (abs(balance_factor) == 2) {\n        if (balance_factor < 0) { // root节点的右子树高度 > 左子树高度\n            if (get_balance(root->right) == 1) { // root->right的左子树高度 > 右子树高度，root节点符合RL失衡，执行左右双旋\n                root = right_left_rotate(root);\n            } else { // root->right的右子树高度 > 左子树高度，root节点符合RR失衡，执行左单旋\n                root = left_rotate(root);\n            }\n        } else { // root节点的右子树高度 < 左子树高度\n            if (get_balance(root->left) == 1) { // root->left的左子树高度 > 右子树高度，root节点符合LL失衡，执行右单旋\n                root = right_rotate(root);\n            } else { // root->right的右子树高度 > 左子树高度，root节点符合LR失衡，执行右左双旋\n                root = left_right_rotate(root);\n            }\n        }\n    }\n    return root;\n}\n```\n\n\n\n##### 非递归删除\n\n> 待补充\n\n#### 查询\n\n##### 递归查询\n\n###### 逻辑\n\n- 调用递归查询函数，传入树的根节点`root`和要查询的值`data`。\n- 如果`root==nullptr`，说明递归到了叶子节点下的空节点，或者整个树为空，即：没有找到目标值。返回`false`，递归结束。\n  - 如果`root->data==data`，找到目标值，返回`true`，递归结束。\n  - 如果`root->data > data`，递归左子树。返回左子树的递归结果。\n  - 如果`root->data < data`，递归右子树。返回右子树的递归结果。\n\n###### 代码实现：\n\n```cpp\n// 查询(递归实现)\nbool search(const Node *root, const int &data) {\n    if (root == nullptr) {\n        return false;\n    }\n    if (root->data == data) {\n        return true;\n    } else if (data < root->data) {\n        return search(root->left, data);\n    } else {\n        return search(root->right, data);\n    }\n}\n```\n\n\n\n##### 非递归查询\n\n待补充\n\n#### 核心算法：旋转操作\n\n##### 左旋\n\n![左旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250721222714402.png)\n\nC++实现：\n\n```cpp\n/**\n * @brief root节点失衡，对root和root->right进行左旋操作。\n * @param root 失衡节点\n */\nNode *left_rotate(Node *root) {\n    Node *childR = root->right;\n    Node *childRL = childR->left;\n\n    root->right = childRL;\n    childR->left = root;\n\n    if (childRL != nullptr) {\n        childRL->parent = root;\n    }\n    childR->parent = root->parent;\n    root->parent = childR;\n    if (childR->parent != nullptr) {\n        if (childR->data < childR->parent->data) {\n            childR->parent->left = childR;\n        } else {\n            childR->parent->right = childR;\n        }\n    }\n\n    root = childR;\n    update_height(root->left);\n    update_height(root->right);\n    update_height(root);\n    update_height(root->parent);\n\n    return root;\n}\n```\n\n\n\n##### 右旋\n\n![右旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250721222747055.png)\n\nC++实现：\n\n```cpp\n/**\n * @brief root节点失衡，对root和root->left执行右旋操作。\n * @param root 失衡节点\n */\nNode *right_rotate(Node *root) {\n    Node *childL = root->left;\n    Node *childLR = childL->right;\n\n    /**\n     * 如果只使用了height属性，没有使用parent属性，则只需要 下面两行语句 和 root=Lchild 以及 四个update_height()即可完成旋转。\n     * 如果使用了parent则需要加入剩余的代码。\n     */\n    root->left = childLR;\n    childL->right = root;\n\n    if (childLR != nullptr) {\n        // 说明原root->left->right非空，需要更新它的父节点指针。\n        childLR->parent = root;\n    }\n    childL->parent = root->parent;\n    root->parent = childL;\n    if (childL->parent != nullptr) {\n        if (root->data < childL->parent->data) {\n            // 原root节点挂载在root->parent的左边，旋转后将新树也挂载在左边\n            childL->parent->left = childL;\n        } else {\n            // 否则挂载到右边\n            childL->parent->right = childL;\n        }\n    }\n\n    root = childL;\n    update_height(root->left);\n    update_height(root->right);\n    update_height(root);\n    update_height(root->parent); // 注意此处需要更新root->parent的高度，因为root->parent的其中一个子树(也就是root)高度改变，所以会影响root->parent的高度\n\n    return root;\n}\n```\n\n\n\n##### 左右双旋\n\n先左旋，再右旋\n\n![左右双旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250721223004318.png)\n\nC++实现：\n\n```cpp\n/**\n * @brief 左右旋\n */\nNode *left_right_rotate(Node *root) {\n    // 先对root->left和root->left->right进行左单旋\n    root->left = left_rotate(root->left);\n    // 在对root和root->left进行右单旋\n    return right_rotate(root);\n}\n```\n\n\n\n##### 右左双旋\n\n先右旋，再左旋\n\n![右左双旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250721222927312.png)\n\nC++实现：\n\n```cpp\n/**\n * @brief 右左旋\n */\nNode *right_left_rotate(Node *root) {\n    // 先对root->right和root->right->left进行右单旋\n    root->right = right_rotate(root->right);\n    // 再对root和root->right进行左单旋\n    return left_rotate(root);\n}\n```\n\n#### 完整代码实现：\n\n```cpp\n#include <iostream>\n#include <queue>\n#include <iomanip>\n#include <cstring>\nusing namespace std;\n\nclass AVLTree {\npublic:\n    typedef struct AVLNode {\n        int data;\n        int height{1}; // 节点高度：表示从当前节点到距离他最远的叶子节点的距离+1（叶子节点高度为1，空节点高度为0）\n        AVLNode *left;\n        AVLNode *right;\n        AVLNode *parent; // 当前节点的双亲节点\n        AVLNode(int data) : data(data), left(nullptr), right(nullptr) {}\n        AVLNode(int data, AVLNode *left, AVLNode *right, AVLNode *parent) : AVLNode(data) {\n            this->parent = parent;\n            height = 1;\n        };\n    } Node;\n\n    AVLTree() : root(nullptr) {}\n\n    AVLTree(int data) {\n        root = new Node(data);\n    }\n\n    ~AVLTree() {\n        delete_tree(root);\n    }\n\n    void insert_node(int data) {\n        root = insert_recursion(root, nullptr, data); // 直接调用递归函数进行插入\n\n        /**\n         * 待补充: 非递归的插入方法\n         */\n    }\n\n    void delete_node(int data) {\n        root = delete_recursion(root, data); // 调用递归的删除方法\n\n        /**\n         * 待补充: 非递归的删除方法\n         */\n    }\n\n    bool search(int data) {\n        return search(root, data); // 调用递归的查询方法\n\n        /**\n         * 待补充: 非递归的查询方法\n         */\n    }\n\n    Node *get_root() {\n        return this->root;\n    }\n\nprivate:\n    Node *root;\n\n    // 插入(递归实现)\n    Node *insert_recursion(Node *root, Node *parent, int data) {\n        if (root == nullptr) {\n            // 新插入一个节点。新插入的节点一定是叶子节点，所以该节点的高度为1（类内初始化）\n            return new Node(data, nullptr, nullptr, parent);\n        } else if (root->data > data) {\n            root->left = insert_recursion(root->left, root, data);\n            // 插入后判断root是否失衡。因为插入的是root->left，所以只需要考虑root左边过高的情况\n            if (abs(get_balance(root)) == 2) { // root节点失衡\n                if (root->left != nullptr && data < root->left->data) {\n                    // 执行右单旋操作。\n                    root = right_rotate(root);\n                } else {\n                    // 执行左右旋操作。\n                    root = left_right_rotate(root);\n                }\n            }\n        } else if (root->data < data) {\n            root->right = insert_recursion(root->right, root, data);\n            // 判断root是否失衡\n            if (abs(get_balance(root)) == 2) {\n                if (root->right != nullptr && data > root->right->data) {\n                    // 执行左单旋。\n                    root = left_rotate(root);\n                } else {\n                    // 执行右左旋。\n                    root = right_left_rotate(root);\n                }\n            }\n        } else {\n            printf(\"ERROR! data already exist.\\n\");\n        }\n        // 无论插入情况如何，都要在插入后更新root节点的节点高度\n        update_height(root);\n        return root;\n    }\n\n    // 删除(递归实现)\n    Node *delete_recursion(Node *root, int data) {\n        if (root != nullptr) {\n            if (root->data == data) { // 找到要删除的节点\n                printf(\"delete: %d\\n\", data);\n                if (root->right == nullptr && root->left != nullptr) { // root只有左孩子，没有右孩子\n                    if (root->parent != nullptr) { // 考虑root是否是整个树的根节点\n                        if (root->data > root->parent->data) { // root是root->parent的右孩子\n                            root->parent->right = root->left;\n                        } else { // root是root->parent的左孩子\n                            root->parent->left = root->left;\n                        }\n                        update_height(root->parent); // 因为删除了root节点，所以要更新root->parent节点的高度\n                    }\n                    root->left->parent = root->parent; // 更新父节点指针\n                    // 执行平衡操作? 似乎多余? root->left本来就是平衡的，只是取代了root，对root->left的平衡性没有影响。\n                    // root->left = balance(root->left);\n                    Node *temp = root->left;\n                    delete root;\n                    root = temp; // root节点从树中删除，root->left取代root\n                } else if (root->left == nullptr && root->right != nullptr) { // root只有右孩子，没有左孩子\n                    if (root->parent != nullptr) {\n                        if (root->data > root->parent->data) {\n                            root->parent->right = root->right;\n                        } else {\n                            root->parent->left = root->right;\n                        }\n                        update_height(root->parent);\n                    }\n                    root->right->parent = root->parent;\n                    // root->right = balance(root->right);\n                    Node *temp = root->right;\n                    delete root;\n                    root = temp;\n                } else if (root->left != nullptr && root->right != nullptr) { // 左右孩子都有\n                    Node *temp = root->right;\n                    while (temp->left != nullptr) { // 找到root的右子树中的最小节点\n                        temp = temp->left;\n                    }\n                    int val = temp->data;\n                    root->right = delete_recursion(root->right, val);\n                    root->data = val;\n                    update_height(root); // root的右子树发生了变动，更新root的高度\n                    root = balance(root);\n                } else { // root是叶子节点\n                    if (root->parent != nullptr) { // root存在父节点\n                        if (root->parent->data < root->data) { // root是其父亲节点的右孩子\n                            root->parent->right = nullptr; // 删去root节点\n                        } else { // root是其父亲节点的左孩子\n                            root->parent->left = nullptr;\n                        }\n                        update_height(root->parent);\n                    }\n                    delete root;\n                    root = nullptr;\n                }\n\n            } else if (data < root->data) {\n                root->left = delete_recursion(root->left, data);\n                update_height(root);\n                root = balance(root);\n            } else {\n                root->right = delete_recursion(root->right, data);\n                update_height(root);\n                root = balance(root);\n            }\n        } else {\n            printf(\"Key to be deleted could not be found.\\n\");\n        }\n\n        return root;\n    }\n\n    // 查询(递归实现)\n    bool search(const Node *root, const int &data) {\n        if (root == nullptr) {\n            return false;\n        }\n        if (root->data == data) {\n            return true;\n        } else if (data < root->data) {\n            return search(root->left, data);\n        } else {\n            return search(root->right, data);\n        }\n    }\n\n    // 获取节点高度\n    int node_height(Node *node) {\n        if (node == nullptr) {\n            return 0;\n        }\n        return node->height;\n    }\n\n    // 更新节点高度\n    void update_height(Node *root) {\n        if (root != nullptr) {\n            // update height\n            root->height = std::max(node_height(root->left), node_height(root->right)) + 1;\n        }\n    }\n\n    /**\n     * @brief 获取node节点的平衡因子。\n     * @param node 要获取平衡因子的节点\n     * @return  - 如果node是非叶子节点，平衡因子 = 左子树高度 - 右子树高度;\n     *\n     *          - 如果node是叶子节点，平衡因子 = 1\n     *\n     *          - 如果node是空节点，平衡因子 = 0\n     */\n    int get_balance(Node *node) {\n        if (node == nullptr) {\n            return 0;\n        }\n        return node_height(node->left) - node_height(node->right);\n    }\n\n    /**\n     * @brief root节点失衡，对root和root->left执行右旋操作。\n     * @param root 失衡节点\n     */\n    Node *right_rotate(Node *root) {\n        Node *childL = root->left;\n        Node *childLR = childL->right;\n\n        /**\n         * 如果只使用了height属性，没有使用parent属性，则只需要 下面两行语句 和 root=Lchild 以及 四个update_height()即可完成旋转。\n         * 如果使用了parent则需要加入剩余的代码。\n         */\n        root->left = childLR;\n        childL->right = root;\n\n        if (childLR != nullptr) {\n            // 说明原root->left->right非空，需要更新它的父节点指针。\n            childLR->parent = root;\n        }\n        childL->parent = root->parent;\n        root->parent = childL;\n        if (childL->parent != nullptr) {\n            if (root->data < childL->parent->data) {\n                // 原root节点挂载在root->parent的左边，旋转后将新树也挂载在左边\n                childL->parent->left = childL;\n            } else {\n                // 否则挂载到右边\n                childL->parent->right = childL;\n            }\n        }\n\n        root = childL;\n        update_height(root->left);\n        update_height(root->right);\n        update_height(root);\n        update_height(root->parent); // 注意此处需要更新root->parent的高度，因为root->parent的其中一个子树(也就是root)高度改变，所以会影响root->parent的高度\n\n        return root;\n    }\n\n    /**\n     * @brief root节点失衡，对root和root->right进行左旋操作。\n     * @param root 失衡节点\n     */\n    Node *left_rotate(Node *root) {\n        Node *childR = root->right;\n        Node *childRL = childR->left;\n\n        root->right = childRL;\n        childR->left = root;\n\n        if (childRL != nullptr) {\n            childRL->parent = root;\n        }\n        childR->parent = root->parent;\n        root->parent = childR;\n        if (childR->parent != nullptr) {\n            if (childR->data < childR->parent->data) {\n                childR->parent->left = childR;\n            } else {\n                childR->parent->right = childR;\n            }\n        }\n\n        root = childR;\n        update_height(root->left);\n        update_height(root->right);\n        update_height(root);\n        update_height(root->parent);\n\n        return root;\n    }\n\n    /**\n     * @brief 左右旋\n     */\n    Node *left_right_rotate(Node *root) {\n        // 先对root->left和root->left->right进行左单旋\n        root->left = left_rotate(root->left);\n        // 在对root和root->left进行右单旋\n        return right_rotate(root);\n    }\n\n    /**\n     * @brief 右左旋\n     */\n    Node *right_left_rotate(Node *root) {\n        // 先对root->right和root->right->left进行右单旋\n        root->right = right_rotate(root->right);\n        // 再对root和root->right进行左单旋\n        return left_rotate(root);\n    }\n\n    // 平衡root节点\n    Node *balance(Node *root) {\n        int balance_factor = get_balance(root);\n        if (abs(balance_factor) == 2) {\n            if (balance_factor < 0) { // root节点的右子树高度 > 左子树高度\n                if (get_balance(root->right) == 1) { // root->right的左子树高度 > 右子树高度，root节点符合RL失衡，执行左右双旋\n                    root = right_left_rotate(root);\n                } else { // root->right的右子树高度 > 左子树高度，root节点符合RR失衡，执行左单旋\n                    root = left_rotate(root);\n                }\n            } else { // root节点的右子树高度 < 左子树高度\n                if (get_balance(root->left) == 1) { // root->left的左子树高度 > 右子树高度，root节点符合LL失衡，执行右单旋\n                    root = right_rotate(root);\n                } else { // root->right的右子树高度 > 左子树高度，root节点符合LR失衡，执行右左双旋\n                    root = left_right_rotate(root);\n                }\n            }\n        }\n        return root;\n    }\n\n    void delete_tree(AVLTree::Node *root) {\n        if (root == nullptr) {\n            return;\n        }\n        delete_tree(root->left);\n        delete_tree(root->right);\n        printf(\"released node: %d\\n\", root->data);\n        delete root;\n    }\n};\n\nvoid printInOrder(AVLTree::Node *root) {\n    if (root == nullptr) {\n        return;\n    }\n    printInOrder(root->left);\n    printf(\"%d \", root->data);\n    printInOrder(root->right);\n}\n\nint main() {\n    AVLTree avl;\n\n    int *arr = new int[12]{10, 20, 45, 30, 12, 40, 50, 25, 14, 52, 75, 19};\n\n    for (int i = 0; i < 12; ++i) {\n        avl.insert_node(arr[i]);\n    }\n\n    for (int i = 0; i < 12; ++i) {\n        if (avl.search(arr[i])) {\n            printf(\"find: %d\\n\", arr[i]);\n            avl.delete_node(arr[i]);\n        }\n    }\n\n    delete[] arr;\n\n    return 0;\n}\n```\n\n","slug":"数据结构/树/BalancedBinarySearchTree(AVL)","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfja9lq100224e4p61pl7j9i","content":"<p>如果插入二叉搜索树的元素在插入之前就已经有序，那么插入后的二叉搜索树会退化为链表。在这种情况下，所有操作的时间复杂度将从 $O(log_2n)$ 劣化为 $O(n)$ 。因此产生了平衡二叉树，能够实现在插入、删除时保持树的平衡，避免树退化为链表。平衡二叉树全称为：平衡二叉搜索树(<code>Balanced Binary Search Tree</code>).</p>\n<h3 id=\"特点：\">特点：</h3>\n<ol>\n<li>\n<p><strong>自平衡</strong>：在插入或删除节点时，<code>AVL</code>树会通过旋转操作（如左旋、右旋、左右旋、右左旋）来保持树的平衡。</p>\n</li>\n<li>\n<p>如果一个树是<code>AVL</code>树，那么它的左右子树都是<code>AVL</code>树。</p>\n</li>\n<li>\n<p>树中任意一个节点的平衡因子绝对值不超过1。</p>\n<p>平衡因子：默认每个节点的平衡因子=<code>左子树高度-右子树高度</code>。（或者<code>右子树高度-左子树高度</code>）</p>\n</li>\n</ol>\n<h3 id=\"实现\">实现</h3>\n<p>基本节点：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">AVLNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> data;</span><br><span class=\"line\">    <span class=\"type\">int</span> height&#123;<span class=\"number\">1</span>&#125;; <span class=\"comment\">// 节点高度：表示从当前节点到距离他最远的叶子节点的距离+1（叶子节点高度为1，空节点高度为0）</span></span><br><span class=\"line\">    AVLNode *left;</span><br><span class=\"line\">    AVLNode *right;</span><br><span class=\"line\">    AVLNode *parent; <span class=\"comment\">// 当前节点的双亲节点</span></span><br><span class=\"line\">    <span class=\"built_in\">AVLNode</span>(<span class=\"type\">int</span> data) : <span class=\"built_in\">data</span>(data), <span class=\"built_in\">left</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">AVLNode</span>(<span class=\"type\">int</span> data, AVLNode *left, AVLNode *right, AVLNode *parent) : <span class=\"built_in\">AVLNode</span>(data) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;parent = parent;</span><br><span class=\"line\">        height = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125; Node;</span><br></pre></td></tr></table></figure>\n<h4 id=\"插入\">插入</h4>\n<h5 id=\"递归插入\">递归插入</h5>\n<h6 id=\"逻辑\">逻辑</h6>\n<ul>\n<li>\n<p>调用递归函数，传入<strong>要插入的树的根节点<code>root</code><strong>和</strong>要插入的值<code>data</code></strong>。因为此处<code>AVLNode</code>还用到了<code>parent</code>指针，所以还需要传入<code>parent</code>指针，方便新建节点时指定其<code>parent</code>指针的值。</p>\n</li>\n<li>\n<p>如果<code>root==nullptr</code>说明是叶子节点。在该位置新建节点。存储要插入的值<code>data</code>,指定<code>height</code>为<code>1</code>(叶子节点高度为1)，同时指定<code>parent</code>指针为传入的<code>parent</code>参数。<mark>递归结束</mark>。</p>\n<blockquote>\n<p>因为此处新增了叶子节点，叶子节点高度指定为1，所以可以直接结束递归，不需要更新<code>root</code>(叶子节点)的高度。至于<code>root-&gt;parent</code>的高度，会在上层递归中更新。</p>\n</blockquote>\n</li>\n<li>\n<p>判断要插入的值<code>data</code>和当前树的根节点<code>root-&gt;data</code>的大小关系。</p>\n<ul>\n<li><code>data &lt; root-&gt;data</code>：递归插入到左子树<code>root-&gt;left</code>。插入到<code>root-&gt;left</code>后，需要判断<code>root</code>是否失衡。此处因为知晓插入到了<code>root-&gt;left</code>子树，所以只存在两种失衡情况：\n<ul>\n<li>新增节点插入到了<code>root-&gt;left-&gt;left</code>子树上，符合<code>LL</code>情况，执行<strong>右旋</strong>。</li>\n<li>新增节点插入到了<code>root-&gt;left-&gt;right</code>子树上，符合<code>LR</code>情况，执行<strong>左右双旋</strong>。</li>\n</ul>\n</li>\n<li><code>data &gt; root-&gt;data</code>：递归插入到右子树<code>root-&gt;right</code>。插入到<code>root-&gt;right</code>后，需要判断<code>root</code>是否失衡。此处因为知晓插入到了<code>root-&gt;right</code>子树，所以只存在两种失衡情况：\n<ul>\n<li>新增节点插入到了<code>root-&gt;right-&gt;right</code>子树上，符合<code>RR</code>情况，执行<strong>左旋</strong>。</li>\n<li>新增节点插入到了<code>root-&gt;right-&gt;left</code>子树上，符合<code>RL</code>情况，执行<strong>右左双旋</strong>。</li>\n</ul>\n</li>\n<li><code>data == root-&gt;data</code>：提示要插入的值已经存在。<strong>插入失败</strong>。</li>\n</ul>\n</li>\n<li>\n<p>插入并且旋转完成后，更新<code>root</code>节点的高度。（因为新增节点肯定插入了<code>root-&gt;left</code>或者<code>root-&gt;right</code>子树，可能导致<code>root</code>的高度发生变化）。<mark>递归结束</mark>。</p>\n</li>\n</ul>\n<h6 id=\"代码实现\">代码实现</h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 插入(递归实现)</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">insert_recursion</span><span class=\"params\">(Node *root, Node *parent, <span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 新插入一个节点。新插入的节点一定是叶子节点，所以该节点的高度为1（类内初始化）</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(data, <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>, parent);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;data &gt; data) &#123;</span><br><span class=\"line\">        root-&gt;left = <span class=\"built_in\">insert_recursion</span>(root-&gt;left, root, data);</span><br><span class=\"line\">        <span class=\"comment\">// 插入后判断root是否失衡。因为插入的是root-&gt;left，所以只需要考虑root左边过高的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(<span class=\"built_in\">get_balance</span>(root)) == <span class=\"number\">2</span>) &#123; <span class=\"comment\">// root节点失衡</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;left != <span class=\"literal\">nullptr</span> &amp;&amp; data &lt; root-&gt;left-&gt;data) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 执行右单旋操作。</span></span><br><span class=\"line\">                root = <span class=\"built_in\">right_rotate</span>(root);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 执行左右旋操作。</span></span><br><span class=\"line\">                root = <span class=\"built_in\">left_right_rotate</span>(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;data &lt; data) &#123;</span><br><span class=\"line\">        root-&gt;right = <span class=\"built_in\">insert_recursion</span>(root-&gt;right, root, data);</span><br><span class=\"line\">        <span class=\"comment\">// 判断root是否失衡</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(<span class=\"built_in\">get_balance</span>(root)) == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;right != <span class=\"literal\">nullptr</span> &amp;&amp; data &gt; root-&gt;right-&gt;data) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 执行左单旋。</span></span><br><span class=\"line\">                root = <span class=\"built_in\">left_rotate</span>(root);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 执行右左旋。</span></span><br><span class=\"line\">                root = <span class=\"built_in\">right_left_rotate</span>(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ERROR! data already exist.\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 无论插入情况如何，都要在插入后更新root节点的节点高度</span></span><br><span class=\"line\">    <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"非递归插入\">非递归插入</h5>\n<blockquote>\n<p>待补充</p>\n</blockquote>\n<h4 id=\"删除\">删除</h4>\n<h5 id=\"递归删除\">递归删除</h5>\n<h6 id=\"逻辑-2\">逻辑</h6>\n<ul>\n<li>\n<p>调用<strong>删除函数</strong>。传入根节点指针<code>root</code>和要删除的值<code>data</code>。</p>\n</li>\n<li>\n<p>如果<code>root==nullptr</code>，说明没有找到<code>data</code>，删除失败。<mark>递归结束</mark>。</p>\n</li>\n<li>\n<p>如果<code>root!=nullptr</code>，比较<code>root-&gt;data</code>和<code>data</code>的大小关系。</p>\n<ul>\n<li>\n<p><code>root-&gt;data == data</code>，找到了要删除的节点。判断节点情况：</p>\n<ul>\n<li>\n<p><code>root</code>是叶子节点：将root节点从树中删除。然后<code>delete root</code>.</p>\n</li>\n<li>\n<p><code>root</code>只有左子树，没有右子树：</p>\n<ul>\n<li>\n<p>判断<code>root</code>是否是整个<code>AVL</code>树的根节点(<code>root-&gt;parent==nullptr</code>)：如果不是，则在执行下面一段。否则跳过下面一段。</p>\n<ul>\n<li>判断<code>root</code>是<code>root-&gt;parent</code>的左子树还是右子树：</li>\n<li>左子树：执行<code>root-&gt;parent-&gt;left = root-&gt;left</code>从树中删除<code>root</code>节点，然后<mark>更新<code>root-&gt;parent</code>节点的高度</mark>。</li>\n<li>右子树：执行<code>root-&gt;parent-&gt;right = root-&gt;left</code>从树中删除<code>root</code>节点，然后<mark>更新<code>root-&gt;parent</code>节点的高度</mark>。</li>\n</ul>\n</li>\n<li>\n<p>更新<code>root-&gt;left</code>的父节点指针<code>parent</code>。然后<code>delete root</code>.</p>\n<blockquote>\n<p>此处删除了<code>root</code>，但对<code>root-&gt;left</code>的平衡性没有影响。只是将<code>root-&gt;left</code>整体向上提高一层，取代<code>root</code>的位置。（因为<code>root-&gt;right==nullptr</code>）.</p>\n<p>反倒是<code>root-&gt;parent</code>的平衡性可能受到影响，但是**<code>root-&gt;parent</code>的平衡性会在递归返回时被调整**。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><code>root</code>只有右子树，没有左子树：</p>\n<p>与上方逻辑类似</p>\n</li>\n<li>\n<p><code>root</code>的左右子树都存在：</p>\n<p>找到右子树中最小的值，覆盖<code>root-&gt;data</code>，然后再将右子树中最小的值(<code>minData</code>)删去：递归调用删除函数，传入<code>root-&gt;right</code>和<code>minData</code>。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>data &lt; root-&gt;data</code>：</p>\n<ul>\n<li>要删除的<code>data</code>在<code>root</code>的左子树上。<strong>递归调用删除函数</strong>，传入左子树指针<code>root-&gt;left</code>和<code>data</code>。</li>\n<li>递归删除完成后，更新<code>root</code>的高度，</li>\n<li>然后平衡<code>root</code>节点（因为<code>root</code>的左子树删除了一个节点，高度可能发生变化，可能会影响<code>root</code>所在子树的平衡性）</li>\n</ul>\n</li>\n<li>\n<p><code>root-&gt;data &lt; data</code>，要删除的<code>data</code>在<code>root</code>的右子树上。</p>\n<ul>\n<li><strong>递归调用删除函数</strong>，传入右子树指针<code>root-&gt;right</code>和<code>data</code>。</li>\n<li>递归删除完成后，更新<code>root</code>的高度，</li>\n<li>然后平衡<code>root</code>节点（因为<code>root</code>的右子树删除了一个节点，高度可能发生变化，可能会影响<code>root</code>所在子树的平衡性）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"代码实现-2\">代码实现</h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除(递归实现)</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">delete_recursion</span><span class=\"params\">(Node *root, <span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;data == data) &#123; <span class=\"comment\">// 找到要删除的节点</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;delete: %d\\n&quot;</span>, data);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;right == <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;left != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// root只有左孩子，没有右孩子</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (root-&gt;parent != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// 考虑root是否是整个树的根节点</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (root-&gt;data &gt; root-&gt;parent-&gt;data) &#123; <span class=\"comment\">// root是root-&gt;parent的右孩子</span></span><br><span class=\"line\">                        root-&gt;parent-&gt;right = root-&gt;left;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root是root-&gt;parent的左孩子</span></span><br><span class=\"line\">                        root-&gt;parent-&gt;left = root-&gt;left;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"built_in\">update_height</span>(root-&gt;parent); <span class=\"comment\">// 因为删除了root节点，所以要更新root-&gt;parent节点的高度</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                root-&gt;left-&gt;parent = root-&gt;parent; <span class=\"comment\">// 更新父节点指针</span></span><br><span class=\"line\">                <span class=\"comment\">// 执行平衡操作? 似乎多余? root-&gt;left本来就是平衡的，只是取代了root，对root-&gt;left的平衡性没有影响。</span></span><br><span class=\"line\">                <span class=\"comment\">// root-&gt;left = balance(root-&gt;left);</span></span><br><span class=\"line\">                Node *temp = root-&gt;left;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">                root = temp; <span class=\"comment\">// root节点从树中删除，root-&gt;left取代root</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;right != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// root只有右孩子，没有左孩子</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (root-&gt;parent != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (root-&gt;data &gt; root-&gt;parent-&gt;data) &#123;</span><br><span class=\"line\">                        root-&gt;parent-&gt;right = root-&gt;right;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        root-&gt;parent-&gt;left = root-&gt;right;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"built_in\">update_height</span>(root-&gt;parent);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                root-&gt;right-&gt;parent = root-&gt;parent;</span><br><span class=\"line\">                <span class=\"comment\">// root-&gt;right = balance(root-&gt;right);</span></span><br><span class=\"line\">                Node *temp = root-&gt;right;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">                root = temp;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left != <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;right != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// 左右孩子都有</span></span><br><span class=\"line\">                Node *temp = root-&gt;right;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (temp-&gt;left != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// 找到root的右子树中的最小节点</span></span><br><span class=\"line\">                    temp = temp-&gt;left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"type\">int</span> val = temp-&gt;data;</span><br><span class=\"line\">                root-&gt;right = <span class=\"built_in\">delete_recursion</span>(root-&gt;right, val);</span><br><span class=\"line\">                root-&gt;data = val;</span><br><span class=\"line\">                <span class=\"built_in\">update_height</span>(root); <span class=\"comment\">// root的右子树发生了变动，更新root的高度</span></span><br><span class=\"line\">                root = <span class=\"built_in\">balance</span>(root);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root是叶子节点</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (root-&gt;parent != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// root存在父节点</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (root-&gt;parent-&gt;data &lt; root-&gt;data) &#123; <span class=\"comment\">// root是其父亲节点的右孩子</span></span><br><span class=\"line\">                        root-&gt;parent-&gt;right = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 删去root节点</span></span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root是其父亲节点的左孩子</span></span><br><span class=\"line\">                        root-&gt;parent-&gt;left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"built_in\">update_height</span>(root-&gt;parent);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">                root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data &lt; root-&gt;data) &#123;</span><br><span class=\"line\">            root-&gt;left = <span class=\"built_in\">delete_recursion</span>(root-&gt;left, data);</span><br><span class=\"line\">            <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">            root = <span class=\"built_in\">balance</span>(root);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            root-&gt;right = <span class=\"built_in\">delete_recursion</span>(root-&gt;right, data);</span><br><span class=\"line\">            <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">            root = <span class=\"built_in\">balance</span>(root);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Key to be deleted could not be found.\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 平衡root节点</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">balance</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> balance_factor = <span class=\"built_in\">get_balance</span>(root);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(balance_factor) == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (balance_factor &lt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// root节点的右子树高度 &gt; 左子树高度</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">get_balance</span>(root-&gt;right) == <span class=\"number\">1</span>) &#123; <span class=\"comment\">// root-&gt;right的左子树高度 &gt; 右子树高度，root节点符合RL失衡，执行左右双旋</span></span><br><span class=\"line\">                root = <span class=\"built_in\">right_left_rotate</span>(root);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root-&gt;right的右子树高度 &gt; 左子树高度，root节点符合RR失衡，执行左单旋</span></span><br><span class=\"line\">                root = <span class=\"built_in\">left_rotate</span>(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root节点的右子树高度 &lt; 左子树高度</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">get_balance</span>(root-&gt;left) == <span class=\"number\">1</span>) &#123; <span class=\"comment\">// root-&gt;left的左子树高度 &gt; 右子树高度，root节点符合LL失衡，执行右单旋</span></span><br><span class=\"line\">                root = <span class=\"built_in\">right_rotate</span>(root);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root-&gt;right的右子树高度 &gt; 左子树高度，root节点符合LR失衡，执行右左双旋</span></span><br><span class=\"line\">                root = <span class=\"built_in\">left_right_rotate</span>(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"非递归删除\">非递归删除</h5>\n<blockquote>\n<p>待补充</p>\n</blockquote>\n<h4 id=\"查询\">查询</h4>\n<h5 id=\"递归查询\">递归查询</h5>\n<h6 id=\"逻辑-3\">逻辑</h6>\n<ul>\n<li>调用递归查询函数，传入树的根节点<code>root</code>和要查询的值<code>data</code>。</li>\n<li>如果<code>root==nullptr</code>，说明递归到了叶子节点下的空节点，或者整个树为空，即：没有找到目标值。返回<code>false</code>，递归结束。\n<ul>\n<li>如果<code>root-&gt;data==data</code>，找到目标值，返回<code>true</code>，递归结束。</li>\n<li>如果<code>root-&gt;data &gt; data</code>，递归左子树。返回左子树的递归结果。</li>\n<li>如果<code>root-&gt;data &lt; data</code>，递归右子树。返回右子树的递归结果。</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"代码实现：\">代码实现：</h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查询(递归实现)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"type\">const</span> Node *root, <span class=\"type\">const</span> <span class=\"type\">int</span> &amp;data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;data == data) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data &lt; root-&gt;data) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">search</span>(root-&gt;left, data);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">search</span>(root-&gt;right, data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"非递归查询\">非递归查询</h5>\n<p>待补充</p>\n<h4 id=\"核心算法：旋转操作\">核心算法：旋转操作</h4>\n<h5 id=\"左旋\">左旋</h5>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250721222714402.png\" alt=\"左旋\"></p>\n<p>C++实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief root节点失衡，对root和root-&gt;right进行左旋操作。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param root 失衡节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">left_rotate</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    Node *childR = root-&gt;right;</span><br><span class=\"line\">    Node *childRL = childR-&gt;left;</span><br><span class=\"line\"></span><br><span class=\"line\">    root-&gt;right = childRL;</span><br><span class=\"line\">    childR-&gt;left = root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childRL != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        childRL-&gt;parent = root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    childR-&gt;parent = root-&gt;parent;</span><br><span class=\"line\">    root-&gt;parent = childR;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childR-&gt;parent != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childR-&gt;data &lt; childR-&gt;parent-&gt;data) &#123;</span><br><span class=\"line\">            childR-&gt;parent-&gt;left = childR;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            childR-&gt;parent-&gt;right = childR;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    root = childR;</span><br><span class=\"line\">    <span class=\"built_in\">update_height</span>(root-&gt;left);</span><br><span class=\"line\">    <span class=\"built_in\">update_height</span>(root-&gt;right);</span><br><span class=\"line\">    <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">    <span class=\"built_in\">update_height</span>(root-&gt;parent);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"右旋\">右旋</h5>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250721222747055.png\" alt=\"右旋\"></p>\n<p>C++实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief root节点失衡，对root和root-&gt;left执行右旋操作。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param root 失衡节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">right_rotate</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    Node *childL = root-&gt;left;</span><br><span class=\"line\">    Node *childLR = childL-&gt;right;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果只使用了height属性，没有使用parent属性，则只需要 下面两行语句 和 root=Lchild 以及 四个update_height()即可完成旋转。</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果使用了parent则需要加入剩余的代码。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    root-&gt;left = childLR;</span><br><span class=\"line\">    childL-&gt;right = root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childLR != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 说明原root-&gt;left-&gt;right非空，需要更新它的父节点指针。</span></span><br><span class=\"line\">        childLR-&gt;parent = root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    childL-&gt;parent = root-&gt;parent;</span><br><span class=\"line\">    root-&gt;parent = childL;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childL-&gt;parent != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;data &lt; childL-&gt;parent-&gt;data) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 原root节点挂载在root-&gt;parent的左边，旋转后将新树也挂载在左边</span></span><br><span class=\"line\">            childL-&gt;parent-&gt;left = childL;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 否则挂载到右边</span></span><br><span class=\"line\">            childL-&gt;parent-&gt;right = childL;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    root = childL;</span><br><span class=\"line\">    <span class=\"built_in\">update_height</span>(root-&gt;left);</span><br><span class=\"line\">    <span class=\"built_in\">update_height</span>(root-&gt;right);</span><br><span class=\"line\">    <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">    <span class=\"built_in\">update_height</span>(root-&gt;parent); <span class=\"comment\">// 注意此处需要更新root-&gt;parent的高度，因为root-&gt;parent的其中一个子树(也就是root)高度改变，所以会影响root-&gt;parent的高度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"左右双旋\">左右双旋</h5>\n<p>先左旋，再右旋</p>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250721223004318.png\" alt=\"左右双旋\"></p>\n<p>C++实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 左右旋</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">left_right_rotate</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先对root-&gt;left和root-&gt;left-&gt;right进行左单旋</span></span><br><span class=\"line\">    root-&gt;left = <span class=\"built_in\">left_rotate</span>(root-&gt;left);</span><br><span class=\"line\">    <span class=\"comment\">// 在对root和root-&gt;left进行右单旋</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">right_rotate</span>(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"右左双旋\">右左双旋</h5>\n<p>先右旋，再左旋</p>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250721222927312.png\" alt=\"右左双旋\"></p>\n<p>C++实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 右左旋</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">right_left_rotate</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先对root-&gt;right和root-&gt;right-&gt;left进行右单旋</span></span><br><span class=\"line\">    root-&gt;right = <span class=\"built_in\">right_rotate</span>(root-&gt;right);</span><br><span class=\"line\">    <span class=\"comment\">// 再对root和root-&gt;right进行左单旋</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">left_rotate</span>(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"完整代码实现：\">完整代码实现：</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iomanip&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AVLTree</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">AVLNode</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> data;</span><br><span class=\"line\">        <span class=\"type\">int</span> height&#123;<span class=\"number\">1</span>&#125;; <span class=\"comment\">// 节点高度：表示从当前节点到距离他最远的叶子节点的距离+1（叶子节点高度为1，空节点高度为0）</span></span><br><span class=\"line\">        AVLNode *left;</span><br><span class=\"line\">        AVLNode *right;</span><br><span class=\"line\">        AVLNode *parent; <span class=\"comment\">// 当前节点的双亲节点</span></span><br><span class=\"line\">        <span class=\"built_in\">AVLNode</span>(<span class=\"type\">int</span> data) : <span class=\"built_in\">data</span>(data), <span class=\"built_in\">left</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">        <span class=\"built_in\">AVLNode</span>(<span class=\"type\">int</span> data, AVLNode *left, AVLNode *right, AVLNode *parent) : <span class=\"built_in\">AVLNode</span>(data) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;parent = parent;</span><br><span class=\"line\">            height = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125; Node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">AVLTree</span>() : <span class=\"built_in\">root</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">AVLTree</span>(<span class=\"type\">int</span> data) &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">AVLTree</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">delete_tree</span>(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert_node</span><span class=\"params\">(<span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        root = <span class=\"built_in\">insert_recursion</span>(root, <span class=\"literal\">nullptr</span>, data); <span class=\"comment\">// 直接调用递归函数进行插入</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 待补充: 非递归的插入方法</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_node</span><span class=\"params\">(<span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        root = <span class=\"built_in\">delete_recursion</span>(root, data); <span class=\"comment\">// 调用递归的删除方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 待补充: 非递归的删除方法</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">search</span>(root, data); <span class=\"comment\">// 调用递归的查询方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 待补充: 非递归的查询方法</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">get_root</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Node *root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 插入(递归实现)</span></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">insert_recursion</span><span class=\"params\">(Node *root, Node *parent, <span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 新插入一个节点。新插入的节点一定是叶子节点，所以该节点的高度为1（类内初始化）</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(data, <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>, parent);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;data &gt; data) &#123;</span><br><span class=\"line\">            root-&gt;left = <span class=\"built_in\">insert_recursion</span>(root-&gt;left, root, data);</span><br><span class=\"line\">            <span class=\"comment\">// 插入后判断root是否失衡。因为插入的是root-&gt;left，所以只需要考虑root左边过高的情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(<span class=\"built_in\">get_balance</span>(root)) == <span class=\"number\">2</span>) &#123; <span class=\"comment\">// root节点失衡</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (root-&gt;left != <span class=\"literal\">nullptr</span> &amp;&amp; data &lt; root-&gt;left-&gt;data) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 执行右单旋操作。</span></span><br><span class=\"line\">                    root = <span class=\"built_in\">right_rotate</span>(root);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 执行左右旋操作。</span></span><br><span class=\"line\">                    root = <span class=\"built_in\">left_right_rotate</span>(root);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;data &lt; data) &#123;</span><br><span class=\"line\">            root-&gt;right = <span class=\"built_in\">insert_recursion</span>(root-&gt;right, root, data);</span><br><span class=\"line\">            <span class=\"comment\">// 判断root是否失衡</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(<span class=\"built_in\">get_balance</span>(root)) == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (root-&gt;right != <span class=\"literal\">nullptr</span> &amp;&amp; data &gt; root-&gt;right-&gt;data) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 执行左单旋。</span></span><br><span class=\"line\">                    root = <span class=\"built_in\">left_rotate</span>(root);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 执行右左旋。</span></span><br><span class=\"line\">                    root = <span class=\"built_in\">right_left_rotate</span>(root);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ERROR! data already exist.\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 无论插入情况如何，都要在插入后更新root节点的节点高度</span></span><br><span class=\"line\">        <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除(递归实现)</span></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">delete_recursion</span><span class=\"params\">(Node *root, <span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;data == data) &#123; <span class=\"comment\">// 找到要删除的节点</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;delete: %d\\n&quot;</span>, data);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (root-&gt;right == <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;left != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// root只有左孩子，没有右孩子</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (root-&gt;parent != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// 考虑root是否是整个树的根节点</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (root-&gt;data &gt; root-&gt;parent-&gt;data) &#123; <span class=\"comment\">// root是root-&gt;parent的右孩子</span></span><br><span class=\"line\">                            root-&gt;parent-&gt;right = root-&gt;left;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root是root-&gt;parent的左孩子</span></span><br><span class=\"line\">                            root-&gt;parent-&gt;left = root-&gt;left;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"built_in\">update_height</span>(root-&gt;parent); <span class=\"comment\">// 因为删除了root节点，所以要更新root-&gt;parent节点的高度</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    root-&gt;left-&gt;parent = root-&gt;parent; <span class=\"comment\">// 更新父节点指针</span></span><br><span class=\"line\">                    <span class=\"comment\">// 执行平衡操作? 似乎多余? root-&gt;left本来就是平衡的，只是取代了root，对root-&gt;left的平衡性没有影响。</span></span><br><span class=\"line\">                    <span class=\"comment\">// root-&gt;left = balance(root-&gt;left);</span></span><br><span class=\"line\">                    Node *temp = root-&gt;left;</span><br><span class=\"line\">                    <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">                    root = temp; <span class=\"comment\">// root节点从树中删除，root-&gt;left取代root</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;right != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// root只有右孩子，没有左孩子</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (root-&gt;parent != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (root-&gt;data &gt; root-&gt;parent-&gt;data) &#123;</span><br><span class=\"line\">                            root-&gt;parent-&gt;right = root-&gt;right;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            root-&gt;parent-&gt;left = root-&gt;right;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"built_in\">update_height</span>(root-&gt;parent);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    root-&gt;right-&gt;parent = root-&gt;parent;</span><br><span class=\"line\">                    <span class=\"comment\">// root-&gt;right = balance(root-&gt;right);</span></span><br><span class=\"line\">                    Node *temp = root-&gt;right;</span><br><span class=\"line\">                    <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">                    root = temp;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left != <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;right != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// 左右孩子都有</span></span><br><span class=\"line\">                    Node *temp = root-&gt;right;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (temp-&gt;left != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// 找到root的右子树中的最小节点</span></span><br><span class=\"line\">                        temp = temp-&gt;left;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"type\">int</span> val = temp-&gt;data;</span><br><span class=\"line\">                    root-&gt;right = <span class=\"built_in\">delete_recursion</span>(root-&gt;right, val);</span><br><span class=\"line\">                    root-&gt;data = val;</span><br><span class=\"line\">                    <span class=\"built_in\">update_height</span>(root); <span class=\"comment\">// root的右子树发生了变动，更新root的高度</span></span><br><span class=\"line\">                    root = <span class=\"built_in\">balance</span>(root);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root是叶子节点</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (root-&gt;parent != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// root存在父节点</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (root-&gt;parent-&gt;data &lt; root-&gt;data) &#123; <span class=\"comment\">// root是其父亲节点的右孩子</span></span><br><span class=\"line\">                            root-&gt;parent-&gt;right = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 删去root节点</span></span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root是其父亲节点的左孩子</span></span><br><span class=\"line\">                            root-&gt;parent-&gt;left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"built_in\">update_height</span>(root-&gt;parent);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">                    root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data &lt; root-&gt;data) &#123;</span><br><span class=\"line\">                root-&gt;left = <span class=\"built_in\">delete_recursion</span>(root-&gt;left, data);</span><br><span class=\"line\">                <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">                root = <span class=\"built_in\">balance</span>(root);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                root-&gt;right = <span class=\"built_in\">delete_recursion</span>(root-&gt;right, data);</span><br><span class=\"line\">                <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">                root = <span class=\"built_in\">balance</span>(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Key to be deleted could not be found.\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 查询(递归实现)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"type\">const</span> Node *root, <span class=\"type\">const</span> <span class=\"type\">int</span> &amp;data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;data == data) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data &lt; root-&gt;data) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">search</span>(root-&gt;left, data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">search</span>(root-&gt;right, data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取节点高度</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">node_height</span><span class=\"params\">(Node *node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node-&gt;height;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新节点高度</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update_height</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// update height</span></span><br><span class=\"line\">            root-&gt;height = std::<span class=\"built_in\">max</span>(<span class=\"built_in\">node_height</span>(root-&gt;left), <span class=\"built_in\">node_height</span>(root-&gt;right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @brief 获取node节点的平衡因子。</span></span><br><span class=\"line\"><span class=\"comment\">     * @param node 要获取平衡因子的节点</span></span><br><span class=\"line\"><span class=\"comment\">     * @return  - 如果node是非叶子节点，平衡因子 = 左子树高度 - 右子树高度;</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     *          - 如果node是叶子节点，平衡因子 = 1</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     *          - 如果node是空节点，平衡因子 = 0</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_balance</span><span class=\"params\">(Node *node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">node_height</span>(node-&gt;left) - <span class=\"built_in\">node_height</span>(node-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @brief root节点失衡，对root和root-&gt;left执行右旋操作。</span></span><br><span class=\"line\"><span class=\"comment\">     * @param root 失衡节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">right_rotate</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">        Node *childL = root-&gt;left;</span><br><span class=\"line\">        Node *childLR = childL-&gt;right;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果只使用了height属性，没有使用parent属性，则只需要 下面两行语句 和 root=Lchild 以及 四个update_height()即可完成旋转。</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果使用了parent则需要加入剩余的代码。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        root-&gt;left = childLR;</span><br><span class=\"line\">        childL-&gt;right = root;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childLR != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 说明原root-&gt;left-&gt;right非空，需要更新它的父节点指针。</span></span><br><span class=\"line\">            childLR-&gt;parent = root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        childL-&gt;parent = root-&gt;parent;</span><br><span class=\"line\">        root-&gt;parent = childL;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childL-&gt;parent != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;data &lt; childL-&gt;parent-&gt;data) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 原root节点挂载在root-&gt;parent的左边，旋转后将新树也挂载在左边</span></span><br><span class=\"line\">                childL-&gt;parent-&gt;left = childL;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 否则挂载到右边</span></span><br><span class=\"line\">                childL-&gt;parent-&gt;right = childL;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        root = childL;</span><br><span class=\"line\">        <span class=\"built_in\">update_height</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">update_height</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">        <span class=\"built_in\">update_height</span>(root-&gt;parent); <span class=\"comment\">// 注意此处需要更新root-&gt;parent的高度，因为root-&gt;parent的其中一个子树(也就是root)高度改变，所以会影响root-&gt;parent的高度</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @brief root节点失衡，对root和root-&gt;right进行左旋操作。</span></span><br><span class=\"line\"><span class=\"comment\">     * @param root 失衡节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">left_rotate</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">        Node *childR = root-&gt;right;</span><br><span class=\"line\">        Node *childRL = childR-&gt;left;</span><br><span class=\"line\"></span><br><span class=\"line\">        root-&gt;right = childRL;</span><br><span class=\"line\">        childR-&gt;left = root;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childRL != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            childRL-&gt;parent = root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        childR-&gt;parent = root-&gt;parent;</span><br><span class=\"line\">        root-&gt;parent = childR;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childR-&gt;parent != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (childR-&gt;data &lt; childR-&gt;parent-&gt;data) &#123;</span><br><span class=\"line\">                childR-&gt;parent-&gt;left = childR;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                childR-&gt;parent-&gt;right = childR;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        root = childR;</span><br><span class=\"line\">        <span class=\"built_in\">update_height</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">update_height</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">        <span class=\"built_in\">update_height</span>(root-&gt;parent);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @brief 左右旋</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">left_right_rotate</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先对root-&gt;left和root-&gt;left-&gt;right进行左单旋</span></span><br><span class=\"line\">        root-&gt;left = <span class=\"built_in\">left_rotate</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"comment\">// 在对root和root-&gt;left进行右单旋</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">right_rotate</span>(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @brief 右左旋</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">right_left_rotate</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先对root-&gt;right和root-&gt;right-&gt;left进行右单旋</span></span><br><span class=\"line\">        root-&gt;right = <span class=\"built_in\">right_rotate</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"comment\">// 再对root和root-&gt;right进行左单旋</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">left_rotate</span>(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 平衡root节点</span></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">balance</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> balance_factor = <span class=\"built_in\">get_balance</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(balance_factor) == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (balance_factor &lt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// root节点的右子树高度 &gt; 左子树高度</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">get_balance</span>(root-&gt;right) == <span class=\"number\">1</span>) &#123; <span class=\"comment\">// root-&gt;right的左子树高度 &gt; 右子树高度，root节点符合RL失衡，执行左右双旋</span></span><br><span class=\"line\">                    root = <span class=\"built_in\">right_left_rotate</span>(root);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root-&gt;right的右子树高度 &gt; 左子树高度，root节点符合RR失衡，执行左单旋</span></span><br><span class=\"line\">                    root = <span class=\"built_in\">left_rotate</span>(root);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root节点的右子树高度 &lt; 左子树高度</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">get_balance</span>(root-&gt;left) == <span class=\"number\">1</span>) &#123; <span class=\"comment\">// root-&gt;left的左子树高度 &gt; 右子树高度，root节点符合LL失衡，执行右单旋</span></span><br><span class=\"line\">                    root = <span class=\"built_in\">right_rotate</span>(root);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root-&gt;right的右子树高度 &gt; 左子树高度，root节点符合LR失衡，执行右左双旋</span></span><br><span class=\"line\">                    root = <span class=\"built_in\">left_right_rotate</span>(root);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_tree</span><span class=\"params\">(AVLTree::Node *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">delete_tree</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">delete_tree</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;released node: %d\\n&quot;</span>, root-&gt;data);</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printInOrder</span><span class=\"params\">(AVLTree::Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printInOrder</span>(root-&gt;left);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class=\"line\">    <span class=\"built_in\">printInOrder</span>(root-&gt;right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    AVLTree avl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> *arr = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[<span class=\"number\">12</span>]&#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">45</span>, <span class=\"number\">30</span>, <span class=\"number\">12</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>, <span class=\"number\">25</span>, <span class=\"number\">14</span>, <span class=\"number\">52</span>, <span class=\"number\">75</span>, <span class=\"number\">19</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">12</span>; ++i) &#123;</span><br><span class=\"line\">        avl.<span class=\"built_in\">insert_node</span>(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">12</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (avl.<span class=\"built_in\">search</span>(arr[i])) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;find: %d\\n&quot;</span>, arr[i]);</span><br><span class=\"line\">            avl.<span class=\"built_in\">delete_node</span>(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] arr;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>如果插入二叉搜索树的元素在插入之前就已经有序，那么插入后的二叉搜索树会退化为链表。在这种情况下，所有操作的时间复杂度将从 $O(log_2n)$ 劣化为 $O(n)$ 。因此产生了平衡二叉树，能够实现在插入、删除时保持树的平衡，避免树退化为链表。平衡二叉树全称为：平衡二叉搜索树(<code>Balanced Binary Search Tree</code>).</p>\n<h3 id=\"特点：\">特点：</h3>\n<ol>\n<li>\n<p><strong>自平衡</strong>：在插入或删除节点时，<code>AVL</code>树会通过旋转操作（如左旋、右旋、左右旋、右左旋）来保持树的平衡。</p>\n</li>\n<li>\n<p>如果一个树是<code>AVL</code>树，那么它的左右子树都是<code>AVL</code>树。</p>\n</li>\n<li>\n<p>树中任意一个节点的平衡因子绝对值不超过1。</p>\n<p>平衡因子：默认每个节点的平衡因子=<code>左子树高度-右子树高度</code>。（或者<code>右子树高度-左子树高度</code>）</p>\n</li>\n</ol>\n<h3 id=\"实现\">实现</h3>\n<p>基本节点：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">AVLNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> data;</span><br><span class=\"line\">    <span class=\"type\">int</span> height&#123;<span class=\"number\">1</span>&#125;; <span class=\"comment\">// 节点高度：表示从当前节点到距离他最远的叶子节点的距离+1（叶子节点高度为1，空节点高度为0）</span></span><br><span class=\"line\">    AVLNode *left;</span><br><span class=\"line\">    AVLNode *right;</span><br><span class=\"line\">    AVLNode *parent; <span class=\"comment\">// 当前节点的双亲节点</span></span><br><span class=\"line\">    <span class=\"built_in\">AVLNode</span>(<span class=\"type\">int</span> data) : <span class=\"built_in\">data</span>(data), <span class=\"built_in\">left</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">AVLNode</span>(<span class=\"type\">int</span> data, AVLNode *left, AVLNode *right, AVLNode *parent) : <span class=\"built_in\">AVLNode</span>(data) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;parent = parent;</span><br><span class=\"line\">        height = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125; Node;</span><br></pre></td></tr></table></figure>\n<h4 id=\"插入\">插入</h4>\n<h5 id=\"递归插入\">递归插入</h5>\n<h6 id=\"逻辑\">逻辑</h6>\n<ul>\n<li>\n<p>调用递归函数，传入<strong>要插入的树的根节点<code>root</code><strong>和</strong>要插入的值<code>data</code></strong>。因为此处<code>AVLNode</code>还用到了<code>parent</code>指针，所以还需要传入<code>parent</code>指针，方便新建节点时指定其<code>parent</code>指针的值。</p>\n</li>\n<li>\n<p>如果<code>root==nullptr</code>说明是叶子节点。在该位置新建节点。存储要插入的值<code>data</code>,指定<code>height</code>为<code>1</code>(叶子节点高度为1)，同时指定<code>parent</code>指针为传入的<code>parent</code>参数。<mark>递归结束</mark>。</p>\n<blockquote>\n<p>因为此处新增了叶子节点，叶子节点高度指定为1，所以可以直接结束递归，不需要更新<code>root</code>(叶子节点)的高度。至于<code>root-&gt;parent</code>的高度，会在上层递归中更新。</p>\n</blockquote>\n</li>\n<li>\n<p>判断要插入的值<code>data</code>和当前树的根节点<code>root-&gt;data</code>的大小关系。</p>\n<ul>\n<li><code>data &lt; root-&gt;data</code>：递归插入到左子树<code>root-&gt;left</code>。插入到<code>root-&gt;left</code>后，需要判断<code>root</code>是否失衡。此处因为知晓插入到了<code>root-&gt;left</code>子树，所以只存在两种失衡情况：\n<ul>\n<li>新增节点插入到了<code>root-&gt;left-&gt;left</code>子树上，符合<code>LL</code>情况，执行<strong>右旋</strong>。</li>\n<li>新增节点插入到了<code>root-&gt;left-&gt;right</code>子树上，符合<code>LR</code>情况，执行<strong>左右双旋</strong>。</li>\n</ul>\n</li>\n<li><code>data &gt; root-&gt;data</code>：递归插入到右子树<code>root-&gt;right</code>。插入到<code>root-&gt;right</code>后，需要判断<code>root</code>是否失衡。此处因为知晓插入到了<code>root-&gt;right</code>子树，所以只存在两种失衡情况：\n<ul>\n<li>新增节点插入到了<code>root-&gt;right-&gt;right</code>子树上，符合<code>RR</code>情况，执行<strong>左旋</strong>。</li>\n<li>新增节点插入到了<code>root-&gt;right-&gt;left</code>子树上，符合<code>RL</code>情况，执行<strong>右左双旋</strong>。</li>\n</ul>\n</li>\n<li><code>data == root-&gt;data</code>：提示要插入的值已经存在。<strong>插入失败</strong>。</li>\n</ul>\n</li>\n<li>\n<p>插入并且旋转完成后，更新<code>root</code>节点的高度。（因为新增节点肯定插入了<code>root-&gt;left</code>或者<code>root-&gt;right</code>子树，可能导致<code>root</code>的高度发生变化）。<mark>递归结束</mark>。</p>\n</li>\n</ul>\n<h6 id=\"代码实现\">代码实现</h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 插入(递归实现)</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">insert_recursion</span><span class=\"params\">(Node *root, Node *parent, <span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 新插入一个节点。新插入的节点一定是叶子节点，所以该节点的高度为1（类内初始化）</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(data, <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>, parent);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;data &gt; data) &#123;</span><br><span class=\"line\">        root-&gt;left = <span class=\"built_in\">insert_recursion</span>(root-&gt;left, root, data);</span><br><span class=\"line\">        <span class=\"comment\">// 插入后判断root是否失衡。因为插入的是root-&gt;left，所以只需要考虑root左边过高的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(<span class=\"built_in\">get_balance</span>(root)) == <span class=\"number\">2</span>) &#123; <span class=\"comment\">// root节点失衡</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;left != <span class=\"literal\">nullptr</span> &amp;&amp; data &lt; root-&gt;left-&gt;data) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 执行右单旋操作。</span></span><br><span class=\"line\">                root = <span class=\"built_in\">right_rotate</span>(root);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 执行左右旋操作。</span></span><br><span class=\"line\">                root = <span class=\"built_in\">left_right_rotate</span>(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;data &lt; data) &#123;</span><br><span class=\"line\">        root-&gt;right = <span class=\"built_in\">insert_recursion</span>(root-&gt;right, root, data);</span><br><span class=\"line\">        <span class=\"comment\">// 判断root是否失衡</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(<span class=\"built_in\">get_balance</span>(root)) == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;right != <span class=\"literal\">nullptr</span> &amp;&amp; data &gt; root-&gt;right-&gt;data) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 执行左单旋。</span></span><br><span class=\"line\">                root = <span class=\"built_in\">left_rotate</span>(root);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 执行右左旋。</span></span><br><span class=\"line\">                root = <span class=\"built_in\">right_left_rotate</span>(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ERROR! data already exist.\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 无论插入情况如何，都要在插入后更新root节点的节点高度</span></span><br><span class=\"line\">    <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"非递归插入\">非递归插入</h5>\n<blockquote>\n<p>待补充</p>\n</blockquote>\n<h4 id=\"删除\">删除</h4>\n<h5 id=\"递归删除\">递归删除</h5>\n<h6 id=\"逻辑-2\">逻辑</h6>\n<ul>\n<li>\n<p>调用<strong>删除函数</strong>。传入根节点指针<code>root</code>和要删除的值<code>data</code>。</p>\n</li>\n<li>\n<p>如果<code>root==nullptr</code>，说明没有找到<code>data</code>，删除失败。<mark>递归结束</mark>。</p>\n</li>\n<li>\n<p>如果<code>root!=nullptr</code>，比较<code>root-&gt;data</code>和<code>data</code>的大小关系。</p>\n<ul>\n<li>\n<p><code>root-&gt;data == data</code>，找到了要删除的节点。判断节点情况：</p>\n<ul>\n<li>\n<p><code>root</code>是叶子节点：将root节点从树中删除。然后<code>delete root</code>.</p>\n</li>\n<li>\n<p><code>root</code>只有左子树，没有右子树：</p>\n<ul>\n<li>\n<p>判断<code>root</code>是否是整个<code>AVL</code>树的根节点(<code>root-&gt;parent==nullptr</code>)：如果不是，则在执行下面一段。否则跳过下面一段。</p>\n<ul>\n<li>判断<code>root</code>是<code>root-&gt;parent</code>的左子树还是右子树：</li>\n<li>左子树：执行<code>root-&gt;parent-&gt;left = root-&gt;left</code>从树中删除<code>root</code>节点，然后<mark>更新<code>root-&gt;parent</code>节点的高度</mark>。</li>\n<li>右子树：执行<code>root-&gt;parent-&gt;right = root-&gt;left</code>从树中删除<code>root</code>节点，然后<mark>更新<code>root-&gt;parent</code>节点的高度</mark>。</li>\n</ul>\n</li>\n<li>\n<p>更新<code>root-&gt;left</code>的父节点指针<code>parent</code>。然后<code>delete root</code>.</p>\n<blockquote>\n<p>此处删除了<code>root</code>，但对<code>root-&gt;left</code>的平衡性没有影响。只是将<code>root-&gt;left</code>整体向上提高一层，取代<code>root</code>的位置。（因为<code>root-&gt;right==nullptr</code>）.</p>\n<p>反倒是<code>root-&gt;parent</code>的平衡性可能受到影响，但是**<code>root-&gt;parent</code>的平衡性会在递归返回时被调整**。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><code>root</code>只有右子树，没有左子树：</p>\n<p>与上方逻辑类似</p>\n</li>\n<li>\n<p><code>root</code>的左右子树都存在：</p>\n<p>找到右子树中最小的值，覆盖<code>root-&gt;data</code>，然后再将右子树中最小的值(<code>minData</code>)删去：递归调用删除函数，传入<code>root-&gt;right</code>和<code>minData</code>。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>data &lt; root-&gt;data</code>：</p>\n<ul>\n<li>要删除的<code>data</code>在<code>root</code>的左子树上。<strong>递归调用删除函数</strong>，传入左子树指针<code>root-&gt;left</code>和<code>data</code>。</li>\n<li>递归删除完成后，更新<code>root</code>的高度，</li>\n<li>然后平衡<code>root</code>节点（因为<code>root</code>的左子树删除了一个节点，高度可能发生变化，可能会影响<code>root</code>所在子树的平衡性）</li>\n</ul>\n</li>\n<li>\n<p><code>root-&gt;data &lt; data</code>，要删除的<code>data</code>在<code>root</code>的右子树上。</p>\n<ul>\n<li><strong>递归调用删除函数</strong>，传入右子树指针<code>root-&gt;right</code>和<code>data</code>。</li>\n<li>递归删除完成后，更新<code>root</code>的高度，</li>\n<li>然后平衡<code>root</code>节点（因为<code>root</code>的右子树删除了一个节点，高度可能发生变化，可能会影响<code>root</code>所在子树的平衡性）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"代码实现-2\">代码实现</h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除(递归实现)</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">delete_recursion</span><span class=\"params\">(Node *root, <span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;data == data) &#123; <span class=\"comment\">// 找到要删除的节点</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;delete: %d\\n&quot;</span>, data);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;right == <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;left != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// root只有左孩子，没有右孩子</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (root-&gt;parent != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// 考虑root是否是整个树的根节点</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (root-&gt;data &gt; root-&gt;parent-&gt;data) &#123; <span class=\"comment\">// root是root-&gt;parent的右孩子</span></span><br><span class=\"line\">                        root-&gt;parent-&gt;right = root-&gt;left;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root是root-&gt;parent的左孩子</span></span><br><span class=\"line\">                        root-&gt;parent-&gt;left = root-&gt;left;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"built_in\">update_height</span>(root-&gt;parent); <span class=\"comment\">// 因为删除了root节点，所以要更新root-&gt;parent节点的高度</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                root-&gt;left-&gt;parent = root-&gt;parent; <span class=\"comment\">// 更新父节点指针</span></span><br><span class=\"line\">                <span class=\"comment\">// 执行平衡操作? 似乎多余? root-&gt;left本来就是平衡的，只是取代了root，对root-&gt;left的平衡性没有影响。</span></span><br><span class=\"line\">                <span class=\"comment\">// root-&gt;left = balance(root-&gt;left);</span></span><br><span class=\"line\">                Node *temp = root-&gt;left;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">                root = temp; <span class=\"comment\">// root节点从树中删除，root-&gt;left取代root</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;right != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// root只有右孩子，没有左孩子</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (root-&gt;parent != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (root-&gt;data &gt; root-&gt;parent-&gt;data) &#123;</span><br><span class=\"line\">                        root-&gt;parent-&gt;right = root-&gt;right;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        root-&gt;parent-&gt;left = root-&gt;right;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"built_in\">update_height</span>(root-&gt;parent);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                root-&gt;right-&gt;parent = root-&gt;parent;</span><br><span class=\"line\">                <span class=\"comment\">// root-&gt;right = balance(root-&gt;right);</span></span><br><span class=\"line\">                Node *temp = root-&gt;right;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">                root = temp;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left != <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;right != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// 左右孩子都有</span></span><br><span class=\"line\">                Node *temp = root-&gt;right;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (temp-&gt;left != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// 找到root的右子树中的最小节点</span></span><br><span class=\"line\">                    temp = temp-&gt;left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"type\">int</span> val = temp-&gt;data;</span><br><span class=\"line\">                root-&gt;right = <span class=\"built_in\">delete_recursion</span>(root-&gt;right, val);</span><br><span class=\"line\">                root-&gt;data = val;</span><br><span class=\"line\">                <span class=\"built_in\">update_height</span>(root); <span class=\"comment\">// root的右子树发生了变动，更新root的高度</span></span><br><span class=\"line\">                root = <span class=\"built_in\">balance</span>(root);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root是叶子节点</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (root-&gt;parent != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// root存在父节点</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (root-&gt;parent-&gt;data &lt; root-&gt;data) &#123; <span class=\"comment\">// root是其父亲节点的右孩子</span></span><br><span class=\"line\">                        root-&gt;parent-&gt;right = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 删去root节点</span></span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root是其父亲节点的左孩子</span></span><br><span class=\"line\">                        root-&gt;parent-&gt;left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"built_in\">update_height</span>(root-&gt;parent);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">                root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data &lt; root-&gt;data) &#123;</span><br><span class=\"line\">            root-&gt;left = <span class=\"built_in\">delete_recursion</span>(root-&gt;left, data);</span><br><span class=\"line\">            <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">            root = <span class=\"built_in\">balance</span>(root);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            root-&gt;right = <span class=\"built_in\">delete_recursion</span>(root-&gt;right, data);</span><br><span class=\"line\">            <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">            root = <span class=\"built_in\">balance</span>(root);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Key to be deleted could not be found.\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 平衡root节点</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">balance</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> balance_factor = <span class=\"built_in\">get_balance</span>(root);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(balance_factor) == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (balance_factor &lt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// root节点的右子树高度 &gt; 左子树高度</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">get_balance</span>(root-&gt;right) == <span class=\"number\">1</span>) &#123; <span class=\"comment\">// root-&gt;right的左子树高度 &gt; 右子树高度，root节点符合RL失衡，执行左右双旋</span></span><br><span class=\"line\">                root = <span class=\"built_in\">right_left_rotate</span>(root);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root-&gt;right的右子树高度 &gt; 左子树高度，root节点符合RR失衡，执行左单旋</span></span><br><span class=\"line\">                root = <span class=\"built_in\">left_rotate</span>(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root节点的右子树高度 &lt; 左子树高度</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">get_balance</span>(root-&gt;left) == <span class=\"number\">1</span>) &#123; <span class=\"comment\">// root-&gt;left的左子树高度 &gt; 右子树高度，root节点符合LL失衡，执行右单旋</span></span><br><span class=\"line\">                root = <span class=\"built_in\">right_rotate</span>(root);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root-&gt;right的右子树高度 &gt; 左子树高度，root节点符合LR失衡，执行右左双旋</span></span><br><span class=\"line\">                root = <span class=\"built_in\">left_right_rotate</span>(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"非递归删除\">非递归删除</h5>\n<blockquote>\n<p>待补充</p>\n</blockquote>\n<h4 id=\"查询\">查询</h4>\n<h5 id=\"递归查询\">递归查询</h5>\n<h6 id=\"逻辑-3\">逻辑</h6>\n<ul>\n<li>调用递归查询函数，传入树的根节点<code>root</code>和要查询的值<code>data</code>。</li>\n<li>如果<code>root==nullptr</code>，说明递归到了叶子节点下的空节点，或者整个树为空，即：没有找到目标值。返回<code>false</code>，递归结束。\n<ul>\n<li>如果<code>root-&gt;data==data</code>，找到目标值，返回<code>true</code>，递归结束。</li>\n<li>如果<code>root-&gt;data &gt; data</code>，递归左子树。返回左子树的递归结果。</li>\n<li>如果<code>root-&gt;data &lt; data</code>，递归右子树。返回右子树的递归结果。</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"代码实现：\">代码实现：</h6>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查询(递归实现)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"type\">const</span> Node *root, <span class=\"type\">const</span> <span class=\"type\">int</span> &amp;data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;data == data) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data &lt; root-&gt;data) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">search</span>(root-&gt;left, data);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">search</span>(root-&gt;right, data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"非递归查询\">非递归查询</h5>\n<p>待补充</p>\n<h4 id=\"核心算法：旋转操作\">核心算法：旋转操作</h4>\n<h5 id=\"左旋\">左旋</h5>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250721222714402.png\" alt=\"左旋\"></p>\n<p>C++实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief root节点失衡，对root和root-&gt;right进行左旋操作。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param root 失衡节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">left_rotate</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    Node *childR = root-&gt;right;</span><br><span class=\"line\">    Node *childRL = childR-&gt;left;</span><br><span class=\"line\"></span><br><span class=\"line\">    root-&gt;right = childRL;</span><br><span class=\"line\">    childR-&gt;left = root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childRL != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        childRL-&gt;parent = root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    childR-&gt;parent = root-&gt;parent;</span><br><span class=\"line\">    root-&gt;parent = childR;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childR-&gt;parent != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childR-&gt;data &lt; childR-&gt;parent-&gt;data) &#123;</span><br><span class=\"line\">            childR-&gt;parent-&gt;left = childR;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            childR-&gt;parent-&gt;right = childR;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    root = childR;</span><br><span class=\"line\">    <span class=\"built_in\">update_height</span>(root-&gt;left);</span><br><span class=\"line\">    <span class=\"built_in\">update_height</span>(root-&gt;right);</span><br><span class=\"line\">    <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">    <span class=\"built_in\">update_height</span>(root-&gt;parent);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"右旋\">右旋</h5>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250721222747055.png\" alt=\"右旋\"></p>\n<p>C++实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief root节点失衡，对root和root-&gt;left执行右旋操作。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param root 失衡节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">right_rotate</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    Node *childL = root-&gt;left;</span><br><span class=\"line\">    Node *childLR = childL-&gt;right;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果只使用了height属性，没有使用parent属性，则只需要 下面两行语句 和 root=Lchild 以及 四个update_height()即可完成旋转。</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果使用了parent则需要加入剩余的代码。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    root-&gt;left = childLR;</span><br><span class=\"line\">    childL-&gt;right = root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childLR != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 说明原root-&gt;left-&gt;right非空，需要更新它的父节点指针。</span></span><br><span class=\"line\">        childLR-&gt;parent = root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    childL-&gt;parent = root-&gt;parent;</span><br><span class=\"line\">    root-&gt;parent = childL;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childL-&gt;parent != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;data &lt; childL-&gt;parent-&gt;data) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 原root节点挂载在root-&gt;parent的左边，旋转后将新树也挂载在左边</span></span><br><span class=\"line\">            childL-&gt;parent-&gt;left = childL;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 否则挂载到右边</span></span><br><span class=\"line\">            childL-&gt;parent-&gt;right = childL;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    root = childL;</span><br><span class=\"line\">    <span class=\"built_in\">update_height</span>(root-&gt;left);</span><br><span class=\"line\">    <span class=\"built_in\">update_height</span>(root-&gt;right);</span><br><span class=\"line\">    <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">    <span class=\"built_in\">update_height</span>(root-&gt;parent); <span class=\"comment\">// 注意此处需要更新root-&gt;parent的高度，因为root-&gt;parent的其中一个子树(也就是root)高度改变，所以会影响root-&gt;parent的高度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"左右双旋\">左右双旋</h5>\n<p>先左旋，再右旋</p>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250721223004318.png\" alt=\"左右双旋\"></p>\n<p>C++实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 左右旋</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">left_right_rotate</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先对root-&gt;left和root-&gt;left-&gt;right进行左单旋</span></span><br><span class=\"line\">    root-&gt;left = <span class=\"built_in\">left_rotate</span>(root-&gt;left);</span><br><span class=\"line\">    <span class=\"comment\">// 在对root和root-&gt;left进行右单旋</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">right_rotate</span>(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"右左双旋\">右左双旋</h5>\n<p>先右旋，再左旋</p>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250721222927312.png\" alt=\"右左双旋\"></p>\n<p>C++实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 右左旋</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">right_left_rotate</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先对root-&gt;right和root-&gt;right-&gt;left进行右单旋</span></span><br><span class=\"line\">    root-&gt;right = <span class=\"built_in\">right_rotate</span>(root-&gt;right);</span><br><span class=\"line\">    <span class=\"comment\">// 再对root和root-&gt;right进行左单旋</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">left_rotate</span>(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"完整代码实现：\">完整代码实现：</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iomanip&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AVLTree</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">AVLNode</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> data;</span><br><span class=\"line\">        <span class=\"type\">int</span> height&#123;<span class=\"number\">1</span>&#125;; <span class=\"comment\">// 节点高度：表示从当前节点到距离他最远的叶子节点的距离+1（叶子节点高度为1，空节点高度为0）</span></span><br><span class=\"line\">        AVLNode *left;</span><br><span class=\"line\">        AVLNode *right;</span><br><span class=\"line\">        AVLNode *parent; <span class=\"comment\">// 当前节点的双亲节点</span></span><br><span class=\"line\">        <span class=\"built_in\">AVLNode</span>(<span class=\"type\">int</span> data) : <span class=\"built_in\">data</span>(data), <span class=\"built_in\">left</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">        <span class=\"built_in\">AVLNode</span>(<span class=\"type\">int</span> data, AVLNode *left, AVLNode *right, AVLNode *parent) : <span class=\"built_in\">AVLNode</span>(data) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;parent = parent;</span><br><span class=\"line\">            height = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125; Node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">AVLTree</span>() : <span class=\"built_in\">root</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">AVLTree</span>(<span class=\"type\">int</span> data) &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">AVLTree</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">delete_tree</span>(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert_node</span><span class=\"params\">(<span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        root = <span class=\"built_in\">insert_recursion</span>(root, <span class=\"literal\">nullptr</span>, data); <span class=\"comment\">// 直接调用递归函数进行插入</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 待补充: 非递归的插入方法</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_node</span><span class=\"params\">(<span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        root = <span class=\"built_in\">delete_recursion</span>(root, data); <span class=\"comment\">// 调用递归的删除方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 待补充: 非递归的删除方法</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">search</span>(root, data); <span class=\"comment\">// 调用递归的查询方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 待补充: 非递归的查询方法</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">get_root</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Node *root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 插入(递归实现)</span></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">insert_recursion</span><span class=\"params\">(Node *root, Node *parent, <span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 新插入一个节点。新插入的节点一定是叶子节点，所以该节点的高度为1（类内初始化）</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(data, <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>, parent);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;data &gt; data) &#123;</span><br><span class=\"line\">            root-&gt;left = <span class=\"built_in\">insert_recursion</span>(root-&gt;left, root, data);</span><br><span class=\"line\">            <span class=\"comment\">// 插入后判断root是否失衡。因为插入的是root-&gt;left，所以只需要考虑root左边过高的情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(<span class=\"built_in\">get_balance</span>(root)) == <span class=\"number\">2</span>) &#123; <span class=\"comment\">// root节点失衡</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (root-&gt;left != <span class=\"literal\">nullptr</span> &amp;&amp; data &lt; root-&gt;left-&gt;data) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 执行右单旋操作。</span></span><br><span class=\"line\">                    root = <span class=\"built_in\">right_rotate</span>(root);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 执行左右旋操作。</span></span><br><span class=\"line\">                    root = <span class=\"built_in\">left_right_rotate</span>(root);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;data &lt; data) &#123;</span><br><span class=\"line\">            root-&gt;right = <span class=\"built_in\">insert_recursion</span>(root-&gt;right, root, data);</span><br><span class=\"line\">            <span class=\"comment\">// 判断root是否失衡</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(<span class=\"built_in\">get_balance</span>(root)) == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (root-&gt;right != <span class=\"literal\">nullptr</span> &amp;&amp; data &gt; root-&gt;right-&gt;data) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 执行左单旋。</span></span><br><span class=\"line\">                    root = <span class=\"built_in\">left_rotate</span>(root);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 执行右左旋。</span></span><br><span class=\"line\">                    root = <span class=\"built_in\">right_left_rotate</span>(root);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ERROR! data already exist.\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 无论插入情况如何，都要在插入后更新root节点的节点高度</span></span><br><span class=\"line\">        <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除(递归实现)</span></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">delete_recursion</span><span class=\"params\">(Node *root, <span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;data == data) &#123; <span class=\"comment\">// 找到要删除的节点</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;delete: %d\\n&quot;</span>, data);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (root-&gt;right == <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;left != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// root只有左孩子，没有右孩子</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (root-&gt;parent != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// 考虑root是否是整个树的根节点</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (root-&gt;data &gt; root-&gt;parent-&gt;data) &#123; <span class=\"comment\">// root是root-&gt;parent的右孩子</span></span><br><span class=\"line\">                            root-&gt;parent-&gt;right = root-&gt;left;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root是root-&gt;parent的左孩子</span></span><br><span class=\"line\">                            root-&gt;parent-&gt;left = root-&gt;left;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"built_in\">update_height</span>(root-&gt;parent); <span class=\"comment\">// 因为删除了root节点，所以要更新root-&gt;parent节点的高度</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    root-&gt;left-&gt;parent = root-&gt;parent; <span class=\"comment\">// 更新父节点指针</span></span><br><span class=\"line\">                    <span class=\"comment\">// 执行平衡操作? 似乎多余? root-&gt;left本来就是平衡的，只是取代了root，对root-&gt;left的平衡性没有影响。</span></span><br><span class=\"line\">                    <span class=\"comment\">// root-&gt;left = balance(root-&gt;left);</span></span><br><span class=\"line\">                    Node *temp = root-&gt;left;</span><br><span class=\"line\">                    <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">                    root = temp; <span class=\"comment\">// root节点从树中删除，root-&gt;left取代root</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;right != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// root只有右孩子，没有左孩子</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (root-&gt;parent != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (root-&gt;data &gt; root-&gt;parent-&gt;data) &#123;</span><br><span class=\"line\">                            root-&gt;parent-&gt;right = root-&gt;right;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            root-&gt;parent-&gt;left = root-&gt;right;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"built_in\">update_height</span>(root-&gt;parent);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    root-&gt;right-&gt;parent = root-&gt;parent;</span><br><span class=\"line\">                    <span class=\"comment\">// root-&gt;right = balance(root-&gt;right);</span></span><br><span class=\"line\">                    Node *temp = root-&gt;right;</span><br><span class=\"line\">                    <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">                    root = temp;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left != <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;right != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// 左右孩子都有</span></span><br><span class=\"line\">                    Node *temp = root-&gt;right;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (temp-&gt;left != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// 找到root的右子树中的最小节点</span></span><br><span class=\"line\">                        temp = temp-&gt;left;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"type\">int</span> val = temp-&gt;data;</span><br><span class=\"line\">                    root-&gt;right = <span class=\"built_in\">delete_recursion</span>(root-&gt;right, val);</span><br><span class=\"line\">                    root-&gt;data = val;</span><br><span class=\"line\">                    <span class=\"built_in\">update_height</span>(root); <span class=\"comment\">// root的右子树发生了变动，更新root的高度</span></span><br><span class=\"line\">                    root = <span class=\"built_in\">balance</span>(root);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root是叶子节点</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (root-&gt;parent != <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// root存在父节点</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (root-&gt;parent-&gt;data &lt; root-&gt;data) &#123; <span class=\"comment\">// root是其父亲节点的右孩子</span></span><br><span class=\"line\">                            root-&gt;parent-&gt;right = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 删去root节点</span></span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root是其父亲节点的左孩子</span></span><br><span class=\"line\">                            root-&gt;parent-&gt;left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"built_in\">update_height</span>(root-&gt;parent);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">                    root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data &lt; root-&gt;data) &#123;</span><br><span class=\"line\">                root-&gt;left = <span class=\"built_in\">delete_recursion</span>(root-&gt;left, data);</span><br><span class=\"line\">                <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">                root = <span class=\"built_in\">balance</span>(root);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                root-&gt;right = <span class=\"built_in\">delete_recursion</span>(root-&gt;right, data);</span><br><span class=\"line\">                <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">                root = <span class=\"built_in\">balance</span>(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Key to be deleted could not be found.\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 查询(递归实现)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"type\">const</span> Node *root, <span class=\"type\">const</span> <span class=\"type\">int</span> &amp;data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;data == data) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data &lt; root-&gt;data) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">search</span>(root-&gt;left, data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">search</span>(root-&gt;right, data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取节点高度</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">node_height</span><span class=\"params\">(Node *node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node-&gt;height;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新节点高度</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update_height</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// update height</span></span><br><span class=\"line\">            root-&gt;height = std::<span class=\"built_in\">max</span>(<span class=\"built_in\">node_height</span>(root-&gt;left), <span class=\"built_in\">node_height</span>(root-&gt;right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @brief 获取node节点的平衡因子。</span></span><br><span class=\"line\"><span class=\"comment\">     * @param node 要获取平衡因子的节点</span></span><br><span class=\"line\"><span class=\"comment\">     * @return  - 如果node是非叶子节点，平衡因子 = 左子树高度 - 右子树高度;</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     *          - 如果node是叶子节点，平衡因子 = 1</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     *          - 如果node是空节点，平衡因子 = 0</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_balance</span><span class=\"params\">(Node *node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">node_height</span>(node-&gt;left) - <span class=\"built_in\">node_height</span>(node-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @brief root节点失衡，对root和root-&gt;left执行右旋操作。</span></span><br><span class=\"line\"><span class=\"comment\">     * @param root 失衡节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">right_rotate</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">        Node *childL = root-&gt;left;</span><br><span class=\"line\">        Node *childLR = childL-&gt;right;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果只使用了height属性，没有使用parent属性，则只需要 下面两行语句 和 root=Lchild 以及 四个update_height()即可完成旋转。</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果使用了parent则需要加入剩余的代码。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        root-&gt;left = childLR;</span><br><span class=\"line\">        childL-&gt;right = root;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childLR != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 说明原root-&gt;left-&gt;right非空，需要更新它的父节点指针。</span></span><br><span class=\"line\">            childLR-&gt;parent = root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        childL-&gt;parent = root-&gt;parent;</span><br><span class=\"line\">        root-&gt;parent = childL;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childL-&gt;parent != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;data &lt; childL-&gt;parent-&gt;data) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 原root节点挂载在root-&gt;parent的左边，旋转后将新树也挂载在左边</span></span><br><span class=\"line\">                childL-&gt;parent-&gt;left = childL;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 否则挂载到右边</span></span><br><span class=\"line\">                childL-&gt;parent-&gt;right = childL;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        root = childL;</span><br><span class=\"line\">        <span class=\"built_in\">update_height</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">update_height</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">        <span class=\"built_in\">update_height</span>(root-&gt;parent); <span class=\"comment\">// 注意此处需要更新root-&gt;parent的高度，因为root-&gt;parent的其中一个子树(也就是root)高度改变，所以会影响root-&gt;parent的高度</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @brief root节点失衡，对root和root-&gt;right进行左旋操作。</span></span><br><span class=\"line\"><span class=\"comment\">     * @param root 失衡节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">left_rotate</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">        Node *childR = root-&gt;right;</span><br><span class=\"line\">        Node *childRL = childR-&gt;left;</span><br><span class=\"line\"></span><br><span class=\"line\">        root-&gt;right = childRL;</span><br><span class=\"line\">        childR-&gt;left = root;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childRL != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            childRL-&gt;parent = root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        childR-&gt;parent = root-&gt;parent;</span><br><span class=\"line\">        root-&gt;parent = childR;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childR-&gt;parent != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (childR-&gt;data &lt; childR-&gt;parent-&gt;data) &#123;</span><br><span class=\"line\">                childR-&gt;parent-&gt;left = childR;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                childR-&gt;parent-&gt;right = childR;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        root = childR;</span><br><span class=\"line\">        <span class=\"built_in\">update_height</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">update_height</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"built_in\">update_height</span>(root);</span><br><span class=\"line\">        <span class=\"built_in\">update_height</span>(root-&gt;parent);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @brief 左右旋</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">left_right_rotate</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先对root-&gt;left和root-&gt;left-&gt;right进行左单旋</span></span><br><span class=\"line\">        root-&gt;left = <span class=\"built_in\">left_rotate</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"comment\">// 在对root和root-&gt;left进行右单旋</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">right_rotate</span>(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @brief 右左旋</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">right_left_rotate</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先对root-&gt;right和root-&gt;right-&gt;left进行右单旋</span></span><br><span class=\"line\">        root-&gt;right = <span class=\"built_in\">right_rotate</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"comment\">// 再对root和root-&gt;right进行左单旋</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">left_rotate</span>(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 平衡root节点</span></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">balance</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> balance_factor = <span class=\"built_in\">get_balance</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(balance_factor) == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (balance_factor &lt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// root节点的右子树高度 &gt; 左子树高度</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">get_balance</span>(root-&gt;right) == <span class=\"number\">1</span>) &#123; <span class=\"comment\">// root-&gt;right的左子树高度 &gt; 右子树高度，root节点符合RL失衡，执行左右双旋</span></span><br><span class=\"line\">                    root = <span class=\"built_in\">right_left_rotate</span>(root);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root-&gt;right的右子树高度 &gt; 左子树高度，root节点符合RR失衡，执行左单旋</span></span><br><span class=\"line\">                    root = <span class=\"built_in\">left_rotate</span>(root);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root节点的右子树高度 &lt; 左子树高度</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">get_balance</span>(root-&gt;left) == <span class=\"number\">1</span>) &#123; <span class=\"comment\">// root-&gt;left的左子树高度 &gt; 右子树高度，root节点符合LL失衡，执行右单旋</span></span><br><span class=\"line\">                    root = <span class=\"built_in\">right_rotate</span>(root);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// root-&gt;right的右子树高度 &gt; 左子树高度，root节点符合LR失衡，执行右左双旋</span></span><br><span class=\"line\">                    root = <span class=\"built_in\">left_right_rotate</span>(root);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_tree</span><span class=\"params\">(AVLTree::Node *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">delete_tree</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">delete_tree</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;released node: %d\\n&quot;</span>, root-&gt;data);</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printInOrder</span><span class=\"params\">(AVLTree::Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printInOrder</span>(root-&gt;left);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class=\"line\">    <span class=\"built_in\">printInOrder</span>(root-&gt;right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    AVLTree avl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> *arr = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[<span class=\"number\">12</span>]&#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">45</span>, <span class=\"number\">30</span>, <span class=\"number\">12</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>, <span class=\"number\">25</span>, <span class=\"number\">14</span>, <span class=\"number\">52</span>, <span class=\"number\">75</span>, <span class=\"number\">19</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">12</span>; ++i) &#123;</span><br><span class=\"line\">        avl.<span class=\"built_in\">insert_node</span>(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">12</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (avl.<span class=\"built_in\">search</span>(arr[i])) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;find: %d\\n&quot;</span>, arr[i]);</span><br><span class=\"line\">            avl.<span class=\"built_in\">delete_node</span>(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] arr;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"二叉搜索树","date":"2025-07-09T16:00:00.000Z","updated":"2025-07-10T16:00:00.000Z","_content":"\n### 特点\n\n1. 非空左子树的所有结点的值小于其根结点的值。\n2. 非空右子树的所有结点的值大于其根结点的值。\n3. 左、右子树都是二叉搜索树。\n\n### 实现\n\n#### 主要操作\n\n##### 查询：\n\n实现思路：\n\n- 递归：调用递归方法，传入要查询的树的根节点和要查询的值，判断根节点值大小，然后递归查询。\n- 非递归：通过while循环，判断当前指针指向的节点值是否满足条件或者当前指针是否为空。然后根据情况令指针指向当前节点的左子节点或者右子节点。如果当前节点变为空，说明没有找到目标值。\n\n##### 插入：\n\n- 递归：调用递归方法，传入要插入的值和树的根节点。如果当前根节点值小于插入的值，递归调用插入方法，传入右子树的根节点。如果当前根节点值大于插入的值，递归调用插入方法，传入左子树的根节点。<mark>如果相等，报错（二叉搜索树不允许存在重复的值）</mark>。\n- 非递归：通过while循环，通过判断插入值的大小，不断改变遍历的指针指向的节点，同时用另一个指针记录上一个遍历过的节点（方便查找到叶子节点时向前看一个节点，便于操作）。\n\n##### 删除：\n\n首先找到要删除的节点，然后判断情况。主要分为三种情况：\n\n- 左子树为空，只有右子树：直接将右子树向上提升一级（用右子树替换要删除的节点，然乎释放要删除的节点的空间(`new`出来的当然要`delete`)）。\n- 右子树为空，只有左子树：直接将左子树向上提升一级（思路同上）。\n- **左右子树都不为空**：将右子树中值最小的节点和要删除的节点交换，然后删除目标节点（此时目标节点已经在原右子树最小元素的位置上，但该位置可能是一个分叉节点，所以应该递归调用删除方法进行删除）。\n\nC++实现：\n\n```cpp\n#include <iostream>\n#include <queue>\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) {\n        this->data = data;\n        left = nullptr;\n        right = nullptr;\n    }\n    Node(int data, Node *left, Node *right) {\n        this->data = data;\n        this->left = left;\n        this->right = right;\n    }\n};\n\n// 二叉搜索树\nclass BST {\nprivate:\n    Node *root;\n\npublic:\n    BST() {\n        root = nullptr;\n    }\n    BST(int root_data) {\n        root = new Node(root_data);\n    }\n\n    Node *get_root() {\n        return root;\n    }\n\n    // 递归方式插入\n    void insert_recursion(int data) {\n        if (root == nullptr) {\n            root = new Node(data);\n            return;\n        }\n        recursion_insert(root, data); // 调用递归函数\n    }\n\n    // 非递归方式插入\n    void insert_unrecursion(int data) {\n        if (root == nullptr) {\n            root = new Node(data);\n            return;\n        }\n        Node *current = root;\n        Node *parent; // 记录上一个遍历过的节点\n        while (current != nullptr) {\n            parent = current;\n            if (current->data > data) {\n                current = current->left;\n            } else if (current->data < data) {\n                current = current->right;\n            } else {\n                std::cout << \"insert error: data is already exist\" << std::endl;\n                return;\n            }\n        }\n        if (parent->data > data) {\n            parent->left = new Node(data);\n        } else { // while循环中已经判断过元素相等的情况，这里不用再判断\n            parent->right = new Node(data);\n        }\n    }\n\n    Node *search(int data) {\n        if (root == nullptr) {\n            return nullptr;\n        }\n        Node *parent = nullptr;\n        Node *current = root;\n        while (current != nullptr) {\n            parent = current;\n            if (current->data == data) {\n                return current;\n            } else if (current->data > data) {\n                current = current->left;\n            } else {\n                current = current->right;\n            }\n        }\n        return nullptr;\n    }\n\n    void delete_node(int data) {\n        if (root == nullptr) {\n            printf(\"delete failed: tree has zero node\");\n            return;\n        }\n        delNode(root, data);\n    }\n\n    ~BST() {\n        destroyTree(root);\n    }\n\nprivate:\n    void recursion_insert(Node *&node, int data) {\n        if (node == nullptr) {\n            node = new Node(data);\n            return;\n        }\n        if (data > node->data) {\n            recursion_insert(node->right, data);\n        } else if (data < node->data) {\n            recursion_insert(node->left, data);\n        } else {\n            std::cout << \"insert error: data is already exist\" << std::endl;\n        }\n    }\n\n    void delNode(Node *&root, int data) {\n        if (root == nullptr) {\n            return;\n        } else if (root->data < data) {\n            delNode(root->right, data);\n        } else if (root->data > data) {\n            delNode(root->left, data);\n        } else {\n            // root节点就是要删除的节点\n            if (root->left == nullptr) {\n                Node *temp = root;\n                root = root->right;\n                printf(\"deleted node: %d\\n\", temp->data);\n                delete temp;\n                return;\n            }\n            if (root->right == nullptr) {\n                Node *temp = root;\n                root = root->left;\n                printf(\"deleted node: %d\\n\", temp->data);\n                delete temp;\n                return;\n            }\n            /**\n             * 左右子树都不为空：\n             *      将右子树中的最小节点与要删除的节点交换，然后删除交换后的节点。\n             *      删除时，考虑原右子树的最小节点可能是分支节点，所以应该递归调用删除方法进行删除。\n             */\n            Node *current = root->right;\n            while (current != nullptr && current->left != nullptr) {\n                // 找到符合条件的右子树最小节点\n                current = current->left;\n            }\n            /**\n             * 此处不必实现两数交换，如果只是实现删除，可以直接拿current->data覆盖root->data\n             * 但是考虑到某些时候需要deleteNode方法返回被删除的元素的值，此处进行了交换处理，便于更改。\n             */\n            int temp = current->data;\n            current->data = root->data;\n            root->data = temp;\n            delNode(root->right, current->data); // 删除右子树中被交换后的节点\n        }\n    }\n\n    void destroyTree(Node *root) {\n        if (root == nullptr) {\n            return;\n        }\n        if (root->left != nullptr) {\n            destroyTree(root->left);\n        }\n        if (root->right != nullptr) {\n            destroyTree(root->right);\n        }\n        std::cout << \"destroyed node: \" << root->data << std::endl;\n        delete root;\n    }\n};\n\nvoid inorderPrintTree(Node *root) {\n    if (root == nullptr) {\n        return;\n    }\n    inorderPrintTree(root->left);\n    std::cout << root->data << \" \";\n    inorderPrintTree(root->right);\n}\n\nint main() {\n    int arr[] = {5, 3, 2, 4, 7, 6, 8};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    BST bst = BST();\n\n    for (int i = 0; i < size; ++i) {\n        bst.insert_unrecursion(arr[i]);\n    }\n    inorderPrintTree(bst.get_root());\n    printf(\"\\n\");\n    for (int i = 0; i < size; ++i) {\n        if (bst.search(arr[i])) {\n            printf(\"find %d\\n\", arr[i]);\n        } else {\n            printf(\"not found %d\\n\", arr[i]);\n        }\n    }\n\n    for (int i = 0; i < size; ++i) {\n        bst.delete_node(arr[i]);\n    }\n\n    return 0;\n}\n```\n\n正确输出：\n\n```cpp\n2 3 4 5 6 7 8 \nfind 5\nfind 3\nfind 2\nfind 4\nfind 7\nfind 6\nfind 8\ndeleted node: 5\ndeleted node: 3\ndeleted node: 2\ndeleted node: 4\ndeleted node: 7\ndeleted node: 6\ndeleted node: 8\n```\n\n","source":"_posts/数据结构/树/BinarySearchTree.md","raw":"---\ntitle: 二叉搜索树\ndate: 2025-07-10\nupdated: 2025-07-11\ntags: [数据结构, 二叉树, C++, 树]\ncategories: 数据结构\n---\n\n### 特点\n\n1. 非空左子树的所有结点的值小于其根结点的值。\n2. 非空右子树的所有结点的值大于其根结点的值。\n3. 左、右子树都是二叉搜索树。\n\n### 实现\n\n#### 主要操作\n\n##### 查询：\n\n实现思路：\n\n- 递归：调用递归方法，传入要查询的树的根节点和要查询的值，判断根节点值大小，然后递归查询。\n- 非递归：通过while循环，判断当前指针指向的节点值是否满足条件或者当前指针是否为空。然后根据情况令指针指向当前节点的左子节点或者右子节点。如果当前节点变为空，说明没有找到目标值。\n\n##### 插入：\n\n- 递归：调用递归方法，传入要插入的值和树的根节点。如果当前根节点值小于插入的值，递归调用插入方法，传入右子树的根节点。如果当前根节点值大于插入的值，递归调用插入方法，传入左子树的根节点。<mark>如果相等，报错（二叉搜索树不允许存在重复的值）</mark>。\n- 非递归：通过while循环，通过判断插入值的大小，不断改变遍历的指针指向的节点，同时用另一个指针记录上一个遍历过的节点（方便查找到叶子节点时向前看一个节点，便于操作）。\n\n##### 删除：\n\n首先找到要删除的节点，然后判断情况。主要分为三种情况：\n\n- 左子树为空，只有右子树：直接将右子树向上提升一级（用右子树替换要删除的节点，然乎释放要删除的节点的空间(`new`出来的当然要`delete`)）。\n- 右子树为空，只有左子树：直接将左子树向上提升一级（思路同上）。\n- **左右子树都不为空**：将右子树中值最小的节点和要删除的节点交换，然后删除目标节点（此时目标节点已经在原右子树最小元素的位置上，但该位置可能是一个分叉节点，所以应该递归调用删除方法进行删除）。\n\nC++实现：\n\n```cpp\n#include <iostream>\n#include <queue>\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node(int data) {\n        this->data = data;\n        left = nullptr;\n        right = nullptr;\n    }\n    Node(int data, Node *left, Node *right) {\n        this->data = data;\n        this->left = left;\n        this->right = right;\n    }\n};\n\n// 二叉搜索树\nclass BST {\nprivate:\n    Node *root;\n\npublic:\n    BST() {\n        root = nullptr;\n    }\n    BST(int root_data) {\n        root = new Node(root_data);\n    }\n\n    Node *get_root() {\n        return root;\n    }\n\n    // 递归方式插入\n    void insert_recursion(int data) {\n        if (root == nullptr) {\n            root = new Node(data);\n            return;\n        }\n        recursion_insert(root, data); // 调用递归函数\n    }\n\n    // 非递归方式插入\n    void insert_unrecursion(int data) {\n        if (root == nullptr) {\n            root = new Node(data);\n            return;\n        }\n        Node *current = root;\n        Node *parent; // 记录上一个遍历过的节点\n        while (current != nullptr) {\n            parent = current;\n            if (current->data > data) {\n                current = current->left;\n            } else if (current->data < data) {\n                current = current->right;\n            } else {\n                std::cout << \"insert error: data is already exist\" << std::endl;\n                return;\n            }\n        }\n        if (parent->data > data) {\n            parent->left = new Node(data);\n        } else { // while循环中已经判断过元素相等的情况，这里不用再判断\n            parent->right = new Node(data);\n        }\n    }\n\n    Node *search(int data) {\n        if (root == nullptr) {\n            return nullptr;\n        }\n        Node *parent = nullptr;\n        Node *current = root;\n        while (current != nullptr) {\n            parent = current;\n            if (current->data == data) {\n                return current;\n            } else if (current->data > data) {\n                current = current->left;\n            } else {\n                current = current->right;\n            }\n        }\n        return nullptr;\n    }\n\n    void delete_node(int data) {\n        if (root == nullptr) {\n            printf(\"delete failed: tree has zero node\");\n            return;\n        }\n        delNode(root, data);\n    }\n\n    ~BST() {\n        destroyTree(root);\n    }\n\nprivate:\n    void recursion_insert(Node *&node, int data) {\n        if (node == nullptr) {\n            node = new Node(data);\n            return;\n        }\n        if (data > node->data) {\n            recursion_insert(node->right, data);\n        } else if (data < node->data) {\n            recursion_insert(node->left, data);\n        } else {\n            std::cout << \"insert error: data is already exist\" << std::endl;\n        }\n    }\n\n    void delNode(Node *&root, int data) {\n        if (root == nullptr) {\n            return;\n        } else if (root->data < data) {\n            delNode(root->right, data);\n        } else if (root->data > data) {\n            delNode(root->left, data);\n        } else {\n            // root节点就是要删除的节点\n            if (root->left == nullptr) {\n                Node *temp = root;\n                root = root->right;\n                printf(\"deleted node: %d\\n\", temp->data);\n                delete temp;\n                return;\n            }\n            if (root->right == nullptr) {\n                Node *temp = root;\n                root = root->left;\n                printf(\"deleted node: %d\\n\", temp->data);\n                delete temp;\n                return;\n            }\n            /**\n             * 左右子树都不为空：\n             *      将右子树中的最小节点与要删除的节点交换，然后删除交换后的节点。\n             *      删除时，考虑原右子树的最小节点可能是分支节点，所以应该递归调用删除方法进行删除。\n             */\n            Node *current = root->right;\n            while (current != nullptr && current->left != nullptr) {\n                // 找到符合条件的右子树最小节点\n                current = current->left;\n            }\n            /**\n             * 此处不必实现两数交换，如果只是实现删除，可以直接拿current->data覆盖root->data\n             * 但是考虑到某些时候需要deleteNode方法返回被删除的元素的值，此处进行了交换处理，便于更改。\n             */\n            int temp = current->data;\n            current->data = root->data;\n            root->data = temp;\n            delNode(root->right, current->data); // 删除右子树中被交换后的节点\n        }\n    }\n\n    void destroyTree(Node *root) {\n        if (root == nullptr) {\n            return;\n        }\n        if (root->left != nullptr) {\n            destroyTree(root->left);\n        }\n        if (root->right != nullptr) {\n            destroyTree(root->right);\n        }\n        std::cout << \"destroyed node: \" << root->data << std::endl;\n        delete root;\n    }\n};\n\nvoid inorderPrintTree(Node *root) {\n    if (root == nullptr) {\n        return;\n    }\n    inorderPrintTree(root->left);\n    std::cout << root->data << \" \";\n    inorderPrintTree(root->right);\n}\n\nint main() {\n    int arr[] = {5, 3, 2, 4, 7, 6, 8};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    BST bst = BST();\n\n    for (int i = 0; i < size; ++i) {\n        bst.insert_unrecursion(arr[i]);\n    }\n    inorderPrintTree(bst.get_root());\n    printf(\"\\n\");\n    for (int i = 0; i < size; ++i) {\n        if (bst.search(arr[i])) {\n            printf(\"find %d\\n\", arr[i]);\n        } else {\n            printf(\"not found %d\\n\", arr[i]);\n        }\n    }\n\n    for (int i = 0; i < size; ++i) {\n        bst.delete_node(arr[i]);\n    }\n\n    return 0;\n}\n```\n\n正确输出：\n\n```cpp\n2 3 4 5 6 7 8 \nfind 5\nfind 3\nfind 2\nfind 4\nfind 7\nfind 6\nfind 8\ndeleted node: 5\ndeleted node: 3\ndeleted node: 2\ndeleted node: 4\ndeleted node: 7\ndeleted node: 6\ndeleted node: 8\n```\n\n","slug":"数据结构/树/BinarySearchTree","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfja9lq200254e4p86hb02kj","content":"<h3 id=\"特点\">特点</h3>\n<ol>\n<li>非空左子树的所有结点的值小于其根结点的值。</li>\n<li>非空右子树的所有结点的值大于其根结点的值。</li>\n<li>左、右子树都是二叉搜索树。</li>\n</ol>\n<h3 id=\"实现\">实现</h3>\n<h4 id=\"主要操作\">主要操作</h4>\n<h5 id=\"查询：\">查询：</h5>\n<p>实现思路：</p>\n<ul>\n<li>递归：调用递归方法，传入要查询的树的根节点和要查询的值，判断根节点值大小，然后递归查询。</li>\n<li>非递归：通过while循环，判断当前指针指向的节点值是否满足条件或者当前指针是否为空。然后根据情况令指针指向当前节点的左子节点或者右子节点。如果当前节点变为空，说明没有找到目标值。</li>\n</ul>\n<h5 id=\"插入：\">插入：</h5>\n<ul>\n<li>递归：调用递归方法，传入要插入的值和树的根节点。如果当前根节点值小于插入的值，递归调用插入方法，传入右子树的根节点。如果当前根节点值大于插入的值，递归调用插入方法，传入左子树的根节点。<mark>如果相等，报错（二叉搜索树不允许存在重复的值）</mark>。</li>\n<li>非递归：通过while循环，通过判断插入值的大小，不断改变遍历的指针指向的节点，同时用另一个指针记录上一个遍历过的节点（方便查找到叶子节点时向前看一个节点，便于操作）。</li>\n</ul>\n<h5 id=\"删除：\">删除：</h5>\n<p>首先找到要删除的节点，然后判断情况。主要分为三种情况：</p>\n<ul>\n<li>左子树为空，只有右子树：直接将右子树向上提升一级（用右子树替换要删除的节点，然乎释放要删除的节点的空间(<code>new</code>出来的当然要<code>delete</code>)）。</li>\n<li>右子树为空，只有左子树：直接将左子树向上提升一级（思路同上）。</li>\n<li><strong>左右子树都不为空</strong>：将右子树中值最小的节点和要删除的节点交换，然后删除目标节点（此时目标节点已经在原右子树最小元素的位置上，但该位置可能是一个分叉节点，所以应该递归调用删除方法进行删除）。</li>\n</ul>\n<p>C++实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> data;</span><br><span class=\"line\">    Node *left;</span><br><span class=\"line\">    Node *right;</span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(<span class=\"type\">int</span> data) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;data = data;</span><br><span class=\"line\">        left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(<span class=\"type\">int</span> data, Node *left, Node *right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;data = data;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;left = left;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;right = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二叉搜索树</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BST</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Node *root;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">BST</span>() &#123;</span><br><span class=\"line\">        root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">BST</span>(<span class=\"type\">int</span> root_data) &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(root_data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">get_root</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 递归方式插入</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert_recursion</span><span class=\"params\">(<span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(data);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">recursion_insert</span>(root, data); <span class=\"comment\">// 调用递归函数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非递归方式插入</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert_unrecursion</span><span class=\"params\">(<span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(data);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node *current = root;</span><br><span class=\"line\">        Node *parent; <span class=\"comment\">// 记录上一个遍历过的节点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (current != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            parent = current;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (current-&gt;data &gt; data) &#123;</span><br><span class=\"line\">                current = current-&gt;left;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current-&gt;data &lt; data) &#123;</span><br><span class=\"line\">                current = current-&gt;right;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                std::cout &lt;&lt; <span class=\"string\">&quot;insert error: data is already exist&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent-&gt;data &gt; data) &#123;</span><br><span class=\"line\">            parent-&gt;left = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// while循环中已经判断过元素相等的情况，这里不用再判断</span></span><br><span class=\"line\">            parent-&gt;right = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">search</span><span class=\"params\">(<span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node *parent = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        Node *current = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (current != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            parent = current;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (current-&gt;data == data) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current-&gt;data &gt; data) &#123;</span><br><span class=\"line\">                current = current-&gt;left;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                current = current-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_node</span><span class=\"params\">(<span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;delete failed: tree has zero node&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">delNode</span>(root, data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">BST</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">destroyTree</span>(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">recursion_insert</span><span class=\"params\">(Node *&amp;node, <span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            node = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(data);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data &gt; node-&gt;data) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">recursion_insert</span>(node-&gt;right, data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data &lt; node-&gt;data) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">recursion_insert</span>(node-&gt;left, data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">&quot;insert error: data is already exist&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delNode</span><span class=\"params\">(Node *&amp;root, <span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;data &lt; data) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">delNode</span>(root-&gt;right, data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;data &gt; data) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">delNode</span>(root-&gt;left, data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// root节点就是要删除的节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;left == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                Node *temp = root;</span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;deleted node: %d\\n&quot;</span>, temp-&gt;data);</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> temp;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;right == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                Node *temp = root;</span><br><span class=\"line\">                root = root-&gt;left;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;deleted node: %d\\n&quot;</span>, temp-&gt;data);</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> temp;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 左右子树都不为空：</span></span><br><span class=\"line\"><span class=\"comment\">             *      将右子树中的最小节点与要删除的节点交换，然后删除交换后的节点。</span></span><br><span class=\"line\"><span class=\"comment\">             *      删除时，考虑原右子树的最小节点可能是分支节点，所以应该递归调用删除方法进行删除。</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            Node *current = root-&gt;right;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (current != <span class=\"literal\">nullptr</span> &amp;&amp; current-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 找到符合条件的右子树最小节点</span></span><br><span class=\"line\">                current = current-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 此处不必实现两数交换，如果只是实现删除，可以直接拿current-&gt;data覆盖root-&gt;data</span></span><br><span class=\"line\"><span class=\"comment\">             * 但是考虑到某些时候需要deleteNode方法返回被删除的元素的值，此处进行了交换处理，便于更改。</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"type\">int</span> temp = current-&gt;data;</span><br><span class=\"line\">            current-&gt;data = root-&gt;data;</span><br><span class=\"line\">            root-&gt;data = temp;</span><br><span class=\"line\">            <span class=\"built_in\">delNode</span>(root-&gt;right, current-&gt;data); <span class=\"comment\">// 删除右子树中被交换后的节点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">destroyTree</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">destroyTree</span>(root-&gt;left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">destroyTree</span>(root-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;destroyed node: &quot;</span> &lt;&lt; root-&gt;data &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">inorderPrintTree</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">inorderPrintTree</span>(root-&gt;left);</span><br><span class=\"line\">    std::cout &lt;&lt; root-&gt;data &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">inorderPrintTree</span>(root-&gt;right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> size = <span class=\"built_in\">sizeof</span>(arr) / <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    BST bst = <span class=\"built_in\">BST</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">        bst.<span class=\"built_in\">insert_unrecursion</span>(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">inorderPrintTree</span>(bst.<span class=\"built_in\">get_root</span>());</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bst.<span class=\"built_in\">search</span>(arr[i])) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;find %d\\n&quot;</span>, arr[i]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;not found %d\\n&quot;</span>, arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">        bst.<span class=\"built_in\">delete_node</span>(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正确输出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> </span><br><span class=\"line\">find <span class=\"number\">5</span></span><br><span class=\"line\">find <span class=\"number\">3</span></span><br><span class=\"line\">find <span class=\"number\">2</span></span><br><span class=\"line\">find <span class=\"number\">4</span></span><br><span class=\"line\">find <span class=\"number\">7</span></span><br><span class=\"line\">find <span class=\"number\">6</span></span><br><span class=\"line\">find <span class=\"number\">8</span></span><br><span class=\"line\">deleted node: <span class=\"number\">5</span></span><br><span class=\"line\">deleted node: <span class=\"number\">3</span></span><br><span class=\"line\">deleted node: <span class=\"number\">2</span></span><br><span class=\"line\">deleted node: <span class=\"number\">4</span></span><br><span class=\"line\">deleted node: <span class=\"number\">7</span></span><br><span class=\"line\">deleted node: <span class=\"number\">6</span></span><br><span class=\"line\">deleted node: <span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"特点\">特点</h3>\n<ol>\n<li>非空左子树的所有结点的值小于其根结点的值。</li>\n<li>非空右子树的所有结点的值大于其根结点的值。</li>\n<li>左、右子树都是二叉搜索树。</li>\n</ol>\n<h3 id=\"实现\">实现</h3>\n<h4 id=\"主要操作\">主要操作</h4>\n<h5 id=\"查询：\">查询：</h5>\n<p>实现思路：</p>\n<ul>\n<li>递归：调用递归方法，传入要查询的树的根节点和要查询的值，判断根节点值大小，然后递归查询。</li>\n<li>非递归：通过while循环，判断当前指针指向的节点值是否满足条件或者当前指针是否为空。然后根据情况令指针指向当前节点的左子节点或者右子节点。如果当前节点变为空，说明没有找到目标值。</li>\n</ul>\n<h5 id=\"插入：\">插入：</h5>\n<ul>\n<li>递归：调用递归方法，传入要插入的值和树的根节点。如果当前根节点值小于插入的值，递归调用插入方法，传入右子树的根节点。如果当前根节点值大于插入的值，递归调用插入方法，传入左子树的根节点。<mark>如果相等，报错（二叉搜索树不允许存在重复的值）</mark>。</li>\n<li>非递归：通过while循环，通过判断插入值的大小，不断改变遍历的指针指向的节点，同时用另一个指针记录上一个遍历过的节点（方便查找到叶子节点时向前看一个节点，便于操作）。</li>\n</ul>\n<h5 id=\"删除：\">删除：</h5>\n<p>首先找到要删除的节点，然后判断情况。主要分为三种情况：</p>\n<ul>\n<li>左子树为空，只有右子树：直接将右子树向上提升一级（用右子树替换要删除的节点，然乎释放要删除的节点的空间(<code>new</code>出来的当然要<code>delete</code>)）。</li>\n<li>右子树为空，只有左子树：直接将左子树向上提升一级（思路同上）。</li>\n<li><strong>左右子树都不为空</strong>：将右子树中值最小的节点和要删除的节点交换，然后删除目标节点（此时目标节点已经在原右子树最小元素的位置上，但该位置可能是一个分叉节点，所以应该递归调用删除方法进行删除）。</li>\n</ul>\n<p>C++实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> data;</span><br><span class=\"line\">    Node *left;</span><br><span class=\"line\">    Node *right;</span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(<span class=\"type\">int</span> data) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;data = data;</span><br><span class=\"line\">        left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(<span class=\"type\">int</span> data, Node *left, Node *right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;data = data;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;left = left;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;right = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二叉搜索树</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BST</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Node *root;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">BST</span>() &#123;</span><br><span class=\"line\">        root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">BST</span>(<span class=\"type\">int</span> root_data) &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(root_data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">get_root</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 递归方式插入</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert_recursion</span><span class=\"params\">(<span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(data);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">recursion_insert</span>(root, data); <span class=\"comment\">// 调用递归函数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非递归方式插入</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert_unrecursion</span><span class=\"params\">(<span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(data);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node *current = root;</span><br><span class=\"line\">        Node *parent; <span class=\"comment\">// 记录上一个遍历过的节点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (current != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            parent = current;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (current-&gt;data &gt; data) &#123;</span><br><span class=\"line\">                current = current-&gt;left;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current-&gt;data &lt; data) &#123;</span><br><span class=\"line\">                current = current-&gt;right;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                std::cout &lt;&lt; <span class=\"string\">&quot;insert error: data is already exist&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent-&gt;data &gt; data) &#123;</span><br><span class=\"line\">            parent-&gt;left = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// while循环中已经判断过元素相等的情况，这里不用再判断</span></span><br><span class=\"line\">            parent-&gt;right = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">search</span><span class=\"params\">(<span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node *parent = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        Node *current = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (current != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            parent = current;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (current-&gt;data == data) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current-&gt;data &gt; data) &#123;</span><br><span class=\"line\">                current = current-&gt;left;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                current = current-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_node</span><span class=\"params\">(<span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;delete failed: tree has zero node&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">delNode</span>(root, data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">BST</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">destroyTree</span>(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">recursion_insert</span><span class=\"params\">(Node *&amp;node, <span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            node = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(data);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data &gt; node-&gt;data) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">recursion_insert</span>(node-&gt;right, data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data &lt; node-&gt;data) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">recursion_insert</span>(node-&gt;left, data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">&quot;insert error: data is already exist&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delNode</span><span class=\"params\">(Node *&amp;root, <span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;data &lt; data) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">delNode</span>(root-&gt;right, data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;data &gt; data) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">delNode</span>(root-&gt;left, data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// root节点就是要删除的节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;left == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                Node *temp = root;</span><br><span class=\"line\">                root = root-&gt;right;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;deleted node: %d\\n&quot;</span>, temp-&gt;data);</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> temp;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;right == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                Node *temp = root;</span><br><span class=\"line\">                root = root-&gt;left;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;deleted node: %d\\n&quot;</span>, temp-&gt;data);</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> temp;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 左右子树都不为空：</span></span><br><span class=\"line\"><span class=\"comment\">             *      将右子树中的最小节点与要删除的节点交换，然后删除交换后的节点。</span></span><br><span class=\"line\"><span class=\"comment\">             *      删除时，考虑原右子树的最小节点可能是分支节点，所以应该递归调用删除方法进行删除。</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            Node *current = root-&gt;right;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (current != <span class=\"literal\">nullptr</span> &amp;&amp; current-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 找到符合条件的右子树最小节点</span></span><br><span class=\"line\">                current = current-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 此处不必实现两数交换，如果只是实现删除，可以直接拿current-&gt;data覆盖root-&gt;data</span></span><br><span class=\"line\"><span class=\"comment\">             * 但是考虑到某些时候需要deleteNode方法返回被删除的元素的值，此处进行了交换处理，便于更改。</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"type\">int</span> temp = current-&gt;data;</span><br><span class=\"line\">            current-&gt;data = root-&gt;data;</span><br><span class=\"line\">            root-&gt;data = temp;</span><br><span class=\"line\">            <span class=\"built_in\">delNode</span>(root-&gt;right, current-&gt;data); <span class=\"comment\">// 删除右子树中被交换后的节点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">destroyTree</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">destroyTree</span>(root-&gt;left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">destroyTree</span>(root-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;destroyed node: &quot;</span> &lt;&lt; root-&gt;data &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">inorderPrintTree</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">inorderPrintTree</span>(root-&gt;left);</span><br><span class=\"line\">    std::cout &lt;&lt; root-&gt;data &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">inorderPrintTree</span>(root-&gt;right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> size = <span class=\"built_in\">sizeof</span>(arr) / <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    BST bst = <span class=\"built_in\">BST</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">        bst.<span class=\"built_in\">insert_unrecursion</span>(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">inorderPrintTree</span>(bst.<span class=\"built_in\">get_root</span>());</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bst.<span class=\"built_in\">search</span>(arr[i])) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;find %d\\n&quot;</span>, arr[i]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;not found %d\\n&quot;</span>, arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">        bst.<span class=\"built_in\">delete_node</span>(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正确输出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> </span><br><span class=\"line\">find <span class=\"number\">5</span></span><br><span class=\"line\">find <span class=\"number\">3</span></span><br><span class=\"line\">find <span class=\"number\">2</span></span><br><span class=\"line\">find <span class=\"number\">4</span></span><br><span class=\"line\">find <span class=\"number\">7</span></span><br><span class=\"line\">find <span class=\"number\">6</span></span><br><span class=\"line\">find <span class=\"number\">8</span></span><br><span class=\"line\">deleted node: <span class=\"number\">5</span></span><br><span class=\"line\">deleted node: <span class=\"number\">3</span></span><br><span class=\"line\">deleted node: <span class=\"number\">2</span></span><br><span class=\"line\">deleted node: <span class=\"number\">4</span></span><br><span class=\"line\">deleted node: <span class=\"number\">7</span></span><br><span class=\"line\">deleted node: <span class=\"number\">6</span></span><br><span class=\"line\">deleted node: <span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n"},{"title":"二叉树","date":"2025-07-07T16:00:00.000Z","updated":"2025-07-08T16:00:00.000Z","_content":"\n### 特性：\n\n- 对于一个<mark>非空</mark>二叉树，其**$叶子节点数=度为2的节点数+1$**。\n- 非空二叉树的第k层最多有$2^k-1$个节点。（根节点处于第1层）\n- 高度为H的二叉树最多有$2^H-1$个节点。（高度=层数，根节点在第1层，叶子节点在第H层）（满二叉树）\n- 对**完全二叉树**从上到下，从左到右依次编号$1,2,3,...,n$，则有以下关系：\n  - 最后一个**分支节点**的编号为：$\\left\\lfloor n/2 \\right\\rfloor$。如果$i<\\left\\lfloor n/2\\right\\rfloor$，则节点`i`为**非叶子节点**，否则为**叶子节点**。\n  - 叶子节点只能出现在最后两层。\n  - 若存在度为`1`的节点，则最多只可能有一个。且该节点只有左孩子，没有右孩子。\n  - <mark>若总节点数`n`为奇数，则每个非叶子节点都有左右孩子。如果总节点数`n`为偶数，则编号最大的非叶子节点只有左孩子，没有右孩子。其余非叶子节点都有左右孩子</mark>。\n  - 当`i>1`时，节点`i`的双亲节点编号为：$\\left\\lfloor i/2\\right\\rfloor$。（如果`i==0`，那么节点`i`就是整个树的根节点。）\n","source":"_posts/数据结构/树/BinaryTree.md","raw":"---\ntitle: 二叉树\ndate: 2025-07-08\nupdated: 2025-07-09\ntags: [数据结构, 二叉树, C++, 树]\ncategories: 数据结构\n---\n\n### 特性：\n\n- 对于一个<mark>非空</mark>二叉树，其**$叶子节点数=度为2的节点数+1$**。\n- 非空二叉树的第k层最多有$2^k-1$个节点。（根节点处于第1层）\n- 高度为H的二叉树最多有$2^H-1$个节点。（高度=层数，根节点在第1层，叶子节点在第H层）（满二叉树）\n- 对**完全二叉树**从上到下，从左到右依次编号$1,2,3,...,n$，则有以下关系：\n  - 最后一个**分支节点**的编号为：$\\left\\lfloor n/2 \\right\\rfloor$。如果$i<\\left\\lfloor n/2\\right\\rfloor$，则节点`i`为**非叶子节点**，否则为**叶子节点**。\n  - 叶子节点只能出现在最后两层。\n  - 若存在度为`1`的节点，则最多只可能有一个。且该节点只有左孩子，没有右孩子。\n  - <mark>若总节点数`n`为奇数，则每个非叶子节点都有左右孩子。如果总节点数`n`为偶数，则编号最大的非叶子节点只有左孩子，没有右孩子。其余非叶子节点都有左右孩子</mark>。\n  - 当`i>1`时，节点`i`的双亲节点编号为：$\\left\\lfloor i/2\\right\\rfloor$。（如果`i==0`，那么节点`i`就是整个树的根节点。）\n","slug":"数据结构/树/BinaryTree","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfja9lq300284e4pen49aihh","content":"<h3 id=\"特性：\">特性：</h3>\n<ul>\n<li>对于一个<mark>非空</mark>二叉树，其**$叶子节点数=度为2的节点数+1$**。</li>\n<li>非空二叉树的第k层最多有$2^k-1$个节点。（根节点处于第1层）</li>\n<li>高度为H的二叉树最多有$2^H-1$个节点。（高度=层数，根节点在第1层，叶子节点在第H层）（满二叉树）</li>\n<li>对<strong>完全二叉树</strong>从上到下，从左到右依次编号$1,2,3,…,n$，则有以下关系：\n<ul>\n<li>最后一个<strong>分支节点</strong>的编号为：$\\left\\lfloor n/2 \\right\\rfloor$。如果$i&lt;\\left\\lfloor n/2\\right\\rfloor$，则节点<code>i</code>为<strong>非叶子节点</strong>，否则为<strong>叶子节点</strong>。</li>\n<li>叶子节点只能出现在最后两层。</li>\n<li>若存在度为<code>1</code>的节点，则最多只可能有一个。且该节点只有左孩子，没有右孩子。</li>\n<li><mark>若总节点数<code>n</code>为奇数，则每个非叶子节点都有左右孩子。如果总节点数<code>n</code>为偶数，则编号最大的非叶子节点只有左孩子，没有右孩子。其余非叶子节点都有左右孩子</mark>。</li>\n<li>当<code>i&gt;1</code>时，节点<code>i</code>的双亲节点编号为：$\\left\\lfloor i/2\\right\\rfloor$。（如果<code>i==0</code>，那么节点<code>i</code>就是整个树的根节点。）</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"特性：\">特性：</h3>\n<ul>\n<li>对于一个<mark>非空</mark>二叉树，其**$叶子节点数=度为2的节点数+1$**。</li>\n<li>非空二叉树的第k层最多有$2^k-1$个节点。（根节点处于第1层）</li>\n<li>高度为H的二叉树最多有$2^H-1$个节点。（高度=层数，根节点在第1层，叶子节点在第H层）（满二叉树）</li>\n<li>对<strong>完全二叉树</strong>从上到下，从左到右依次编号$1,2,3,…,n$，则有以下关系：\n<ul>\n<li>最后一个<strong>分支节点</strong>的编号为：$\\left\\lfloor n/2 \\right\\rfloor$。如果$i&lt;\\left\\lfloor n/2\\right\\rfloor$，则节点<code>i</code>为<strong>非叶子节点</strong>，否则为<strong>叶子节点</strong>。</li>\n<li>叶子节点只能出现在最后两层。</li>\n<li>若存在度为<code>1</code>的节点，则最多只可能有一个。且该节点只有左孩子，没有右孩子。</li>\n<li><mark>若总节点数<code>n</code>为奇数，则每个非叶子节点都有左右孩子。如果总节点数<code>n</code>为偶数，则编号最大的非叶子节点只有左孩子，没有右孩子。其余非叶子节点都有左右孩子</mark>。</li>\n<li>当<code>i&gt;1</code>时，节点<code>i</code>的双亲节点编号为：$\\left\\lfloor i/2\\right\\rfloor$。（如果<code>i==0</code>，那么节点<code>i</code>就是整个树的根节点。）</li>\n</ul>\n</li>\n</ul>\n"},{"title":"完全二叉树","date":"2025-07-08T16:00:00.000Z","updated":"2025-07-12T16:00:00.000Z","_content":"\n## 完全二叉树\n\n### 基本概念\n\n完全二叉树：基于二叉树，要求除了最下层外，其余各层都是满节点。<mark>并且，最后一层的节点必须尽可能向左放</mark>。\n\n例：下面所有二叉树都<mark>不是</mark>完全二叉树：\n\n<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/image2a5cac1b30c8c3c2a29f6b9903c5dfcf.png\" alt=\"例1\" style=\"zoom:67%;\" />\n\n<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/image20250709221221457.png\" alt=\"例2\" style=\"zoom:67%;\" />\n\n<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageb7853ade89f82f3208931148ebeca351.png\" alt=\"例3\" style=\"zoom:67%;\" />\n\n### 特征\n\n- 叶子节点之可能在最下面的**两层**出现\n- 对任意结点，若其`右分支下的子孙最大层次为L`，则其`左分支下的子孙的最大层次必为L或L+1`。\n- 所有节点中，<mark>最多只有一个节点度为1</mark>（只有一个孩子）。\n\n### 实现\n\n方便起见，<mark>完全二叉树一般用数组实现</mark>而不用链表。\n\n<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250709232438563.png\" alt=\"例图\" style=\"zoom:67%;\" />\n\n对于用数组存储的完全二叉树，有以下特点：（**下标从0开始**）（根节点层数为1）\n\n1. 如果一个节点在数组中下标为`i`，则它在树中的层数为<mark> $\\left\\lfloor log_2{(i+1)} \\right\\rfloor$ </mark>（向下取整），它的左子节点在数组中对应的下标为：$2i+1$（如果存在），右子节点在数组中对应的下标为$2i+2$（如果存在）。\n2. 如果完全二叉树总共有`n (n>0)`个节点，那么树高：<mark> $h=\\left \\lfloor log_2{n} \\right \\rfloor+1$ </mark>（或者<mark>$\\left\\lceil log_2{(n+1)} \\right\\rceil$</mark>）。\n3. 如果完全二叉树树高`h`，那么这个完全二叉树最多拥有$2^h-1$个节点。\n\n如果**根节点下标从1开始**，那么第一条中，左子节点对应下标改为：<mark>$2i$</mark>，右子节点对应下标改为：<mark>$2i+1$</mark>。（相比于下标从0开始，直接-1）\n\n#### 用数组构建完全二叉树\n\n>  给定一个数组，用层序便利构建二叉树。然后输出它的中序遍历。\n>\n> 例如：<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250710180412848.png\" alt=\"image-20250710180412848\" style=\"zoom: 67%;\" />\n\nC++实现：\n\n```c++\n#include <iostream>\n#include <queue>\n/*\n * 两种方法：\n * 1. 递归\n * 2. 队列\n */\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node() {\n    }\n    Node(int data, Node *left, Node *right) {\n        this->data = data;\n        this->left = left;\n        this->right = right;\n    }\n\n    virtual void test() {\n        std::cout << \"test\" << std::endl;\n    }\n};\n\nvoid inorderPrintTree(Node *root) {\n    if (root == nullptr) {\n        return;\n    }\n    inorderPrintTree(root->left);\n    std::cout << root->data << \" \";\n    inorderPrintTree(root->right);\n}\n\nvoid destroyTree(Node *root) {\n    if (root == nullptr) {\n        return;\n    }\n    if (root->left != nullptr) {\n        destroyTree(root->left);\n    }\n    if (root->right != nullptr) {\n        destroyTree(root->right);\n    }\n    std::cout << \"destroyed node: \" << root->data << std::endl;\n    delete root;\n}\n\n/**\n * 非递归构建：使用栈\n */\nvoid unRecursion() {\n    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    Node *root = new Node(arr[0], nullptr, nullptr);\n    Node *point = root;\n\n    std::queue<Node *> que;\n    que.push(point);\n    int index = 1;\n\n    // 构建完全二叉树\n    while (index < size) {\n        point = que.front();\n        que.pop();\n\n        if (index < size) {\n            point->left = new Node(arr[index++], nullptr, nullptr);\n            que.push(point->left);\n        }\n        if (index < size) {\n            point->right = new Node(arr[index++], nullptr, nullptr);\n            que.push(point->right);\n        }\n    }\n\n    // 中序遍历\n    inorderPrintTree(root);\n\n    destroyTree(root);\n}\n\n/**\n * 递归构建\n */\nvoid recursion(int arr[], int i, int n, Node *&root) {\n    if (i < n) {\n        root = new Node(arr[i], nullptr, nullptr);\n        recursion(arr, i * 2 + 1, n, root->left);\n        recursion(arr, i * 2 + 2, n, root->right);\n        return;\n    }\n    root = nullptr;\n}\n\nint main() {\n    // unRecursion();\t\t\t\t// 非递归\n\n    /*\n     * 递归\n     */\n    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    Node *root = nullptr;\n\n    recursion(arr, 0, size, root);\n\n    inorderPrintTree(root);\n\n    destroyTree(root);\n\n    return 0;\n}\n```\n\n##### 非递归方法构建完全二叉树的思路：\n\n**使用队列保存已经构建好的部分的层序遍历顺序。**\n\n- 首先，构建根节点，然后根节点进入队列。\n- 循环：\n  - 如果队列不为空，从队列中取出节点元素。\n  - 构建该节点的左右子节点（如果存在的话）。并且将构建好的左子节点和右子节点分别入队。也就是将下一层的元素放入队列。\n  - 如果队列为空，跳出循环。\n\n##### 递归方法构建思路：\n\n- 传入节点数组。并且传入当前要构建的节点在数组中的下标。\n- 根据数组中的元素值构建当前节点。\n- 判断左右子节点：(假设完全二叉树根节点对应数组下标为1)\n  - 左子节点(`2i+1`)存在：递归调用函数进行构建\n  - 右子节点(`2i+2`)存在：递归调用函数进行构建\n- 返回当前构建好的节点的指针，便于将不同节点连接在一起。\n\n## 完全N叉树\n\n与完全二叉树类似：\n\n- 除了最后一层，其余各层已经满节点。\n- 最后一层的所有节点尽可能向左边放。\n\n### 由后续遍历构建完全N叉树\n\n给定一个大小为**M**的数组`arr[]` ，其中包含**完整 N 叉树**的后序遍历，任务是生成 N 叉树并打印其**前序遍历**。\n\n例图：\n\n![完全3叉树](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250713220657917.png)\n\nC++实现：\n\n```cpp\n#include <iostream>\n#include <cmath>\n\n/*\n    根据后续遍历生成完全n叉树，然后输出它的前序遍历\n*/\n\ntemplate <class T>\nclass Node {\npublic:\n    Node(T data);\n\n    // 获取左边第一个子节点\n    Node *get_first_child() {\n        return first_child;\n    }\n\n    // 获取右边下一个兄弟节点\n    Node *get_next_sibling() {\n        return next_sibling;\n    }\n\n    void append_add_sibling(Node *sibling) {\n        if (next_sibling == nullptr) {\n            this->next_sibling = sibling;\n        } else {\n            next_sibling->append_add_sibling(sibling);\n        }\n    }\n\n    void add_child(Node *child) {\n        if (first_child == nullptr) {\n            first_child = child;\n        } else {\n            first_child->append_add_sibling(child);\n        }\n    }\n\n    T get_data() {\n        return this->data;\n    }\n\nprivate:\n    T data;\n    Node *first_child;\n    Node *next_sibling;\n};\n\ntemplate <class T>\nNode<T>::Node(T data) {\n    this->data = data;\n    first_child = nullptr;\n    next_sibling = nullptr;\n}\n\n/**\n * @brief 由后续遍历构造完全N叉树\n * @param post_order_arr 后续遍历数组\n * @param size 数组长度\n * @param k 等同于N叉树的N\n * @return 构造的k叉树的根节点指针\n */\ntemplate <typename T>\nNode<T> *construct_n_binary_tree(T *post_order_arr, int size, int k) {\n    // 构造当前树的根节点\n    Node<T> *root = new Node<T>(post_order_arr[size - 1]);\n    if (size == 1) {\n        // 说明该节点(rot)是叶子节点\n        return root;\n    }\n    // 求树高。根据完全N叉树的特性推导而来\n    int height_of_tree = ceil(log2(size * (k - 1) + 1) / log2(k)) - 1; // 向上取整\n    // 最后一层节点数\n    int nodes_in_last_level = size - (pow(k, height_of_tree) - 1) / (k - 1);\n\n    int tracker = 0;\n    while (tracker != (size - 1)) {\n        /**\n         * pow(k, height_of_tree - 1)： 树高 height_of_tree - 1 的情况下，理论最后一层满节点数量（根节点在第0层）\n         * nodes_in_last_level： 实际最后一层节点数量\n         */\n        int last_level_nodes = (pow(k, height_of_tree - 1) > nodes_in_last_level) ? nodes_in_last_level : pow(k, height_of_tree - 1);\n        /**\n         * （从左到右）以root的孩子为根节点的子树的节点数量\n         * (pow(k, height_of_tree - 1) - 1) / (k - 1): 树高 height_of_tree - 2 情况下，满k叉树的节点数量（注意：树高度+1==总层数）\n         * last_level_nodes：\n         */\n        int nodes_in_next_subtree = ((pow(k, height_of_tree - 1) - 1) / (k - 1)) + last_level_nodes;\n\n        root->add_child(construct_n_binary_tree(post_order_arr + tracker, nodes_in_next_subtree, k));\n        tracker += nodes_in_next_subtree;        // 已经构建的子树的节点数之和\n        nodes_in_last_level -= last_level_nodes; // 去掉已经构建的子树的最后一层的节点\n    }\n    return root;\n}\n\n// 前序遍历n叉树\ntemplate <typename T>\nvoid printPreOrder(Node<T> *root) {\n    if (root == nullptr) {\n        return;\n    }\n    std::cout << root->get_data() << \" \";\n    printPreOrder(root->get_first_child()); // 递归遍历root的左边第一个孩子时，也会将它的兄弟(root的第二, 第三,...第k个孩子)一块遍历\n    printPreOrder(root->get_next_sibling());\n}\n\n// 释放空间\ntemplate <typename T>\nvoid destroy_n_binary_tree(Node<T> *root) {\n    if (root == nullptr) {\n        return;\n    }\n    if (root->get_next_sibling() != nullptr) {\n        destroy_n_binary_tree(root->get_next_sibling());\n    }\n    if (root->get_first_child() != nullptr) {\n        destroy_n_binary_tree(root->get_first_child());\n    }\n    std::cout << \"deleted: \" << root->get_data() << std::endl;\n    delete root;\n}\n\nint main() {\n    int arr[] = {5, 6, 7, 2, 8, 9, 3, 4, 1};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    Node<int> *root = construct_n_binary_tree(arr, size, 3);\n\n    printPreOrder(root);\n\n    destroy_n_binary_tree(root);\n\n    return 0;\n}\n```\n\n正确输出：\n\n```cpp\n1 2 5 6 7 3 8 9 4\n```\n\n##### 由后续遍历构建完全N叉树的思路\n\n核心思路：递归。**难点：如何求得根节点的各个子节点所在子树的节点总数**。\n\n1. 传入要构建的树的后续遍历，以及总节点数。还有树的分叉数：N。\n2. 识别根节点。同时求得树高（推导数学公式）\n3. 循环：\n   1. 计算根节点的第`i`个孩子所在的子树所拥有的节点数（数学方法+逻辑推理）（$1\\leq i\\leq k$）（<mark>此处为了便于理解引入变量`i`，实际实现时循环中并不存在变量`i`</mark>）\n   2. 构建根节点的第`i`个孩子所在的子树（<mark>递归</mark>。传入后续遍历（通过原数组偏移量和节点数））。构建完成后挂载到根节点上。\n   3. 记录已经构建完成的子树的节点数之和（循环累加）\n   4. 如果：已经构建完成的节点树之和<mark>等于</mark>总节点数-1，（如果构建成功只能是等于，不能是大于），那么该树构建完成。\n4. 返回构建的根节点。\n","source":"_posts/数据结构/树/CompleteBinaryTree.md","raw":"---\ntitle: 完全二叉树\ndate: 2025-07-09\nupdated: 2025-07-13\ntags: [数据结构, 二叉树, C++, 树, 完全N叉树]\ncategories: 数据结构\n---\n\n## 完全二叉树\n\n### 基本概念\n\n完全二叉树：基于二叉树，要求除了最下层外，其余各层都是满节点。<mark>并且，最后一层的节点必须尽可能向左放</mark>。\n\n例：下面所有二叉树都<mark>不是</mark>完全二叉树：\n\n<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/image2a5cac1b30c8c3c2a29f6b9903c5dfcf.png\" alt=\"例1\" style=\"zoom:67%;\" />\n\n<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/image20250709221221457.png\" alt=\"例2\" style=\"zoom:67%;\" />\n\n<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageb7853ade89f82f3208931148ebeca351.png\" alt=\"例3\" style=\"zoom:67%;\" />\n\n### 特征\n\n- 叶子节点之可能在最下面的**两层**出现\n- 对任意结点，若其`右分支下的子孙最大层次为L`，则其`左分支下的子孙的最大层次必为L或L+1`。\n- 所有节点中，<mark>最多只有一个节点度为1</mark>（只有一个孩子）。\n\n### 实现\n\n方便起见，<mark>完全二叉树一般用数组实现</mark>而不用链表。\n\n<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250709232438563.png\" alt=\"例图\" style=\"zoom:67%;\" />\n\n对于用数组存储的完全二叉树，有以下特点：（**下标从0开始**）（根节点层数为1）\n\n1. 如果一个节点在数组中下标为`i`，则它在树中的层数为<mark> $\\left\\lfloor log_2{(i+1)} \\right\\rfloor$ </mark>（向下取整），它的左子节点在数组中对应的下标为：$2i+1$（如果存在），右子节点在数组中对应的下标为$2i+2$（如果存在）。\n2. 如果完全二叉树总共有`n (n>0)`个节点，那么树高：<mark> $h=\\left \\lfloor log_2{n} \\right \\rfloor+1$ </mark>（或者<mark>$\\left\\lceil log_2{(n+1)} \\right\\rceil$</mark>）。\n3. 如果完全二叉树树高`h`，那么这个完全二叉树最多拥有$2^h-1$个节点。\n\n如果**根节点下标从1开始**，那么第一条中，左子节点对应下标改为：<mark>$2i$</mark>，右子节点对应下标改为：<mark>$2i+1$</mark>。（相比于下标从0开始，直接-1）\n\n#### 用数组构建完全二叉树\n\n>  给定一个数组，用层序便利构建二叉树。然后输出它的中序遍历。\n>\n> 例如：<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250710180412848.png\" alt=\"image-20250710180412848\" style=\"zoom: 67%;\" />\n\nC++实现：\n\n```c++\n#include <iostream>\n#include <queue>\n/*\n * 两种方法：\n * 1. 递归\n * 2. 队列\n */\n\nstruct Node {\n    int data;\n    Node *left;\n    Node *right;\n    Node() {\n    }\n    Node(int data, Node *left, Node *right) {\n        this->data = data;\n        this->left = left;\n        this->right = right;\n    }\n\n    virtual void test() {\n        std::cout << \"test\" << std::endl;\n    }\n};\n\nvoid inorderPrintTree(Node *root) {\n    if (root == nullptr) {\n        return;\n    }\n    inorderPrintTree(root->left);\n    std::cout << root->data << \" \";\n    inorderPrintTree(root->right);\n}\n\nvoid destroyTree(Node *root) {\n    if (root == nullptr) {\n        return;\n    }\n    if (root->left != nullptr) {\n        destroyTree(root->left);\n    }\n    if (root->right != nullptr) {\n        destroyTree(root->right);\n    }\n    std::cout << \"destroyed node: \" << root->data << std::endl;\n    delete root;\n}\n\n/**\n * 非递归构建：使用栈\n */\nvoid unRecursion() {\n    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    Node *root = new Node(arr[0], nullptr, nullptr);\n    Node *point = root;\n\n    std::queue<Node *> que;\n    que.push(point);\n    int index = 1;\n\n    // 构建完全二叉树\n    while (index < size) {\n        point = que.front();\n        que.pop();\n\n        if (index < size) {\n            point->left = new Node(arr[index++], nullptr, nullptr);\n            que.push(point->left);\n        }\n        if (index < size) {\n            point->right = new Node(arr[index++], nullptr, nullptr);\n            que.push(point->right);\n        }\n    }\n\n    // 中序遍历\n    inorderPrintTree(root);\n\n    destroyTree(root);\n}\n\n/**\n * 递归构建\n */\nvoid recursion(int arr[], int i, int n, Node *&root) {\n    if (i < n) {\n        root = new Node(arr[i], nullptr, nullptr);\n        recursion(arr, i * 2 + 1, n, root->left);\n        recursion(arr, i * 2 + 2, n, root->right);\n        return;\n    }\n    root = nullptr;\n}\n\nint main() {\n    // unRecursion();\t\t\t\t// 非递归\n\n    /*\n     * 递归\n     */\n    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    Node *root = nullptr;\n\n    recursion(arr, 0, size, root);\n\n    inorderPrintTree(root);\n\n    destroyTree(root);\n\n    return 0;\n}\n```\n\n##### 非递归方法构建完全二叉树的思路：\n\n**使用队列保存已经构建好的部分的层序遍历顺序。**\n\n- 首先，构建根节点，然后根节点进入队列。\n- 循环：\n  - 如果队列不为空，从队列中取出节点元素。\n  - 构建该节点的左右子节点（如果存在的话）。并且将构建好的左子节点和右子节点分别入队。也就是将下一层的元素放入队列。\n  - 如果队列为空，跳出循环。\n\n##### 递归方法构建思路：\n\n- 传入节点数组。并且传入当前要构建的节点在数组中的下标。\n- 根据数组中的元素值构建当前节点。\n- 判断左右子节点：(假设完全二叉树根节点对应数组下标为1)\n  - 左子节点(`2i+1`)存在：递归调用函数进行构建\n  - 右子节点(`2i+2`)存在：递归调用函数进行构建\n- 返回当前构建好的节点的指针，便于将不同节点连接在一起。\n\n## 完全N叉树\n\n与完全二叉树类似：\n\n- 除了最后一层，其余各层已经满节点。\n- 最后一层的所有节点尽可能向左边放。\n\n### 由后续遍历构建完全N叉树\n\n给定一个大小为**M**的数组`arr[]` ，其中包含**完整 N 叉树**的后序遍历，任务是生成 N 叉树并打印其**前序遍历**。\n\n例图：\n\n![完全3叉树](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250713220657917.png)\n\nC++实现：\n\n```cpp\n#include <iostream>\n#include <cmath>\n\n/*\n    根据后续遍历生成完全n叉树，然后输出它的前序遍历\n*/\n\ntemplate <class T>\nclass Node {\npublic:\n    Node(T data);\n\n    // 获取左边第一个子节点\n    Node *get_first_child() {\n        return first_child;\n    }\n\n    // 获取右边下一个兄弟节点\n    Node *get_next_sibling() {\n        return next_sibling;\n    }\n\n    void append_add_sibling(Node *sibling) {\n        if (next_sibling == nullptr) {\n            this->next_sibling = sibling;\n        } else {\n            next_sibling->append_add_sibling(sibling);\n        }\n    }\n\n    void add_child(Node *child) {\n        if (first_child == nullptr) {\n            first_child = child;\n        } else {\n            first_child->append_add_sibling(child);\n        }\n    }\n\n    T get_data() {\n        return this->data;\n    }\n\nprivate:\n    T data;\n    Node *first_child;\n    Node *next_sibling;\n};\n\ntemplate <class T>\nNode<T>::Node(T data) {\n    this->data = data;\n    first_child = nullptr;\n    next_sibling = nullptr;\n}\n\n/**\n * @brief 由后续遍历构造完全N叉树\n * @param post_order_arr 后续遍历数组\n * @param size 数组长度\n * @param k 等同于N叉树的N\n * @return 构造的k叉树的根节点指针\n */\ntemplate <typename T>\nNode<T> *construct_n_binary_tree(T *post_order_arr, int size, int k) {\n    // 构造当前树的根节点\n    Node<T> *root = new Node<T>(post_order_arr[size - 1]);\n    if (size == 1) {\n        // 说明该节点(rot)是叶子节点\n        return root;\n    }\n    // 求树高。根据完全N叉树的特性推导而来\n    int height_of_tree = ceil(log2(size * (k - 1) + 1) / log2(k)) - 1; // 向上取整\n    // 最后一层节点数\n    int nodes_in_last_level = size - (pow(k, height_of_tree) - 1) / (k - 1);\n\n    int tracker = 0;\n    while (tracker != (size - 1)) {\n        /**\n         * pow(k, height_of_tree - 1)： 树高 height_of_tree - 1 的情况下，理论最后一层满节点数量（根节点在第0层）\n         * nodes_in_last_level： 实际最后一层节点数量\n         */\n        int last_level_nodes = (pow(k, height_of_tree - 1) > nodes_in_last_level) ? nodes_in_last_level : pow(k, height_of_tree - 1);\n        /**\n         * （从左到右）以root的孩子为根节点的子树的节点数量\n         * (pow(k, height_of_tree - 1) - 1) / (k - 1): 树高 height_of_tree - 2 情况下，满k叉树的节点数量（注意：树高度+1==总层数）\n         * last_level_nodes：\n         */\n        int nodes_in_next_subtree = ((pow(k, height_of_tree - 1) - 1) / (k - 1)) + last_level_nodes;\n\n        root->add_child(construct_n_binary_tree(post_order_arr + tracker, nodes_in_next_subtree, k));\n        tracker += nodes_in_next_subtree;        // 已经构建的子树的节点数之和\n        nodes_in_last_level -= last_level_nodes; // 去掉已经构建的子树的最后一层的节点\n    }\n    return root;\n}\n\n// 前序遍历n叉树\ntemplate <typename T>\nvoid printPreOrder(Node<T> *root) {\n    if (root == nullptr) {\n        return;\n    }\n    std::cout << root->get_data() << \" \";\n    printPreOrder(root->get_first_child()); // 递归遍历root的左边第一个孩子时，也会将它的兄弟(root的第二, 第三,...第k个孩子)一块遍历\n    printPreOrder(root->get_next_sibling());\n}\n\n// 释放空间\ntemplate <typename T>\nvoid destroy_n_binary_tree(Node<T> *root) {\n    if (root == nullptr) {\n        return;\n    }\n    if (root->get_next_sibling() != nullptr) {\n        destroy_n_binary_tree(root->get_next_sibling());\n    }\n    if (root->get_first_child() != nullptr) {\n        destroy_n_binary_tree(root->get_first_child());\n    }\n    std::cout << \"deleted: \" << root->get_data() << std::endl;\n    delete root;\n}\n\nint main() {\n    int arr[] = {5, 6, 7, 2, 8, 9, 3, 4, 1};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    Node<int> *root = construct_n_binary_tree(arr, size, 3);\n\n    printPreOrder(root);\n\n    destroy_n_binary_tree(root);\n\n    return 0;\n}\n```\n\n正确输出：\n\n```cpp\n1 2 5 6 7 3 8 9 4\n```\n\n##### 由后续遍历构建完全N叉树的思路\n\n核心思路：递归。**难点：如何求得根节点的各个子节点所在子树的节点总数**。\n\n1. 传入要构建的树的后续遍历，以及总节点数。还有树的分叉数：N。\n2. 识别根节点。同时求得树高（推导数学公式）\n3. 循环：\n   1. 计算根节点的第`i`个孩子所在的子树所拥有的节点数（数学方法+逻辑推理）（$1\\leq i\\leq k$）（<mark>此处为了便于理解引入变量`i`，实际实现时循环中并不存在变量`i`</mark>）\n   2. 构建根节点的第`i`个孩子所在的子树（<mark>递归</mark>。传入后续遍历（通过原数组偏移量和节点数））。构建完成后挂载到根节点上。\n   3. 记录已经构建完成的子树的节点数之和（循环累加）\n   4. 如果：已经构建完成的节点树之和<mark>等于</mark>总节点数-1，（如果构建成功只能是等于，不能是大于），那么该树构建完成。\n4. 返回构建的根节点。\n","slug":"数据结构/树/CompleteBinaryTree","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfja9lq3002a4e4pfas86woq","content":"<h2 id=\"完全二叉树\">完全二叉树</h2>\n<h3 id=\"基本概念\">基本概念</h3>\n<p>完全二叉树：基于二叉树，要求除了最下层外，其余各层都是满节点。<mark>并且，最后一层的节点必须尽可能向左放</mark>。</p>\n<p>例：下面所有二叉树都<mark>不是</mark>完全二叉树：</p>\n<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/image2a5cac1b30c8c3c2a29f6b9903c5dfcf.png\" alt=\"例1\" style=\"zoom:67%;\" />\n<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/image20250709221221457.png\" alt=\"例2\" style=\"zoom:67%;\" />\n<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageb7853ade89f82f3208931148ebeca351.png\" alt=\"例3\" style=\"zoom:67%;\" />\n<h3 id=\"特征\">特征</h3>\n<ul>\n<li>叶子节点之可能在最下面的<strong>两层</strong>出现</li>\n<li>对任意结点，若其<code>右分支下的子孙最大层次为L</code>，则其<code>左分支下的子孙的最大层次必为L或L+1</code>。</li>\n<li>所有节点中，<mark>最多只有一个节点度为1</mark>（只有一个孩子）。</li>\n</ul>\n<h3 id=\"实现\">实现</h3>\n<p>方便起见，<mark>完全二叉树一般用数组实现</mark>而不用链表。</p>\n<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250709232438563.png\" alt=\"例图\" style=\"zoom:67%;\" />\n<p>对于用数组存储的完全二叉树，有以下特点：（<strong>下标从0开始</strong>）（根节点层数为1）</p>\n<ol>\n<li>如果一个节点在数组中下标为<code>i</code>，则它在树中的层数为<mark> $\\left\\lfloor log_2{(i+1)} \\right\\rfloor$ </mark>（向下取整），它的左子节点在数组中对应的下标为：$2i+1$（如果存在），右子节点在数组中对应的下标为$2i+2$（如果存在）。</li>\n<li>如果完全二叉树总共有<code>n (n&gt;0)</code>个节点，那么树高：<mark> $h=\\left \\lfloor log_2{n} \\right \\rfloor+1$ </mark>（或者<mark>$\\left\\lceil log_2{(n+1)} \\right\\rceil$</mark>）。</li>\n<li>如果完全二叉树树高<code>h</code>，那么这个完全二叉树最多拥有$2^h-1$个节点。</li>\n</ol>\n<p>如果<strong>根节点下标从1开始</strong>，那么第一条中，左子节点对应下标改为：<mark>$2i$</mark>，右子节点对应下标改为：<mark>$2i+1$</mark>。（相比于下标从0开始，直接-1）</p>\n<h4 id=\"用数组构建完全二叉树\">用数组构建完全二叉树</h4>\n<blockquote>\n<p>给定一个数组，用层序便利构建二叉树。然后输出它的中序遍历。</p>\n<p>例如：<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250710180412848.png\" alt=\"image-20250710180412848\" style=\"zoom: 67%;\" /></p>\n</blockquote>\n<p>C++实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 两种方法：</span></span><br><span class=\"line\"><span class=\"comment\"> * 1. 递归</span></span><br><span class=\"line\"><span class=\"comment\"> * 2. 队列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> data;</span><br><span class=\"line\">    Node *left;</span><br><span class=\"line\">    Node *right;</span><br><span class=\"line\">    <span class=\"built_in\">Node</span>() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(<span class=\"type\">int</span> data, Node *left, Node *right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;data = data;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;left = left;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;right = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;test&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">inorderPrintTree</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">inorderPrintTree</span>(root-&gt;left);</span><br><span class=\"line\">    std::cout &lt;&lt; root-&gt;data &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">inorderPrintTree</span>(root-&gt;right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">destroyTree</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">destroyTree</span>(root-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">destroyTree</span>(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;destroyed node: &quot;</span> &lt;&lt; root-&gt;data &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 非递归构建：使用栈</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unRecursion</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> size = <span class=\"built_in\">sizeof</span>(arr) / <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    Node *root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(arr[<span class=\"number\">0</span>], <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    Node *point = root;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::queue&lt;Node *&gt; que;</span><br><span class=\"line\">    que.<span class=\"built_in\">push</span>(point);</span><br><span class=\"line\">    <span class=\"type\">int</span> index = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构建完全二叉树</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (index &lt; size) &#123;</span><br><span class=\"line\">        point = que.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        que.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; size) &#123;</span><br><span class=\"line\">            point-&gt;left = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(arr[index++], <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">            que.<span class=\"built_in\">push</span>(point-&gt;left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; size) &#123;</span><br><span class=\"line\">            point-&gt;right = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(arr[index++], <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">            que.<span class=\"built_in\">push</span>(point-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 中序遍历</span></span><br><span class=\"line\">    <span class=\"built_in\">inorderPrintTree</span>(root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">destroyTree</span>(root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 递归构建</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">recursion</span><span class=\"params\">(<span class=\"type\">int</span> arr[], <span class=\"type\">int</span> i, <span class=\"type\">int</span> n, Node *&amp;root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; n) &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(arr[i], <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        <span class=\"built_in\">recursion</span>(arr, i * <span class=\"number\">2</span> + <span class=\"number\">1</span>, n, root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">recursion</span>(arr, i * <span class=\"number\">2</span> + <span class=\"number\">2</span>, n, root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// unRecursion();\t\t\t\t// 非递归</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 递归</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> size = <span class=\"built_in\">sizeof</span>(arr) / <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    Node *root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">recursion</span>(arr, <span class=\"number\">0</span>, size, root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">inorderPrintTree</span>(root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">destroyTree</span>(root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"非递归方法构建完全二叉树的思路：\">非递归方法构建完全二叉树的思路：</h5>\n<p><strong>使用队列保存已经构建好的部分的层序遍历顺序。</strong></p>\n<ul>\n<li>首先，构建根节点，然后根节点进入队列。</li>\n<li>循环：\n<ul>\n<li>如果队列不为空，从队列中取出节点元素。</li>\n<li>构建该节点的左右子节点（如果存在的话）。并且将构建好的左子节点和右子节点分别入队。也就是将下一层的元素放入队列。</li>\n<li>如果队列为空，跳出循环。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"递归方法构建思路：\">递归方法构建思路：</h5>\n<ul>\n<li>传入节点数组。并且传入当前要构建的节点在数组中的下标。</li>\n<li>根据数组中的元素值构建当前节点。</li>\n<li>判断左右子节点：(假设完全二叉树根节点对应数组下标为1)\n<ul>\n<li>左子节点(<code>2i+1</code>)存在：递归调用函数进行构建</li>\n<li>右子节点(<code>2i+2</code>)存在：递归调用函数进行构建</li>\n</ul>\n</li>\n<li>返回当前构建好的节点的指针，便于将不同节点连接在一起。</li>\n</ul>\n<h2 id=\"完全N叉树\">完全N叉树</h2>\n<p>与完全二叉树类似：</p>\n<ul>\n<li>除了最后一层，其余各层已经满节点。</li>\n<li>最后一层的所有节点尽可能向左边放。</li>\n</ul>\n<h3 id=\"由后续遍历构建完全N叉树\">由后续遍历构建完全N叉树</h3>\n<p>给定一个大小为<strong>M</strong>的数组<code>arr[]</code> ，其中包含<strong>完整 N 叉树</strong>的后序遍历，任务是生成 N 叉树并打印其<strong>前序遍历</strong>。</p>\n<p>例图：</p>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250713220657917.png\" alt=\"完全3叉树\"></p>\n<p>C++实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    根据后续遍历生成完全n叉树，然后输出它的前序遍历</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(T data);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取左边第一个子节点</span></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">get_first_child</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first_child;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取右边下一个兄弟节点</span></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">get_next_sibling</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> next_sibling;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">append_add_sibling</span><span class=\"params\">(Node *sibling)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next_sibling == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;next_sibling = sibling;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            next_sibling-&gt;<span class=\"built_in\">append_add_sibling</span>(sibling);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add_child</span><span class=\"params\">(Node *child)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first_child == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            first_child = child;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            first_child-&gt;<span class=\"built_in\">append_add_sibling</span>(child);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">get_data</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    Node *first_child;</span><br><span class=\"line\">    Node *next_sibling;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\">Node&lt;T&gt;::<span class=\"built_in\">Node</span>(T data) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;data = data;</span><br><span class=\"line\">    first_child = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    next_sibling = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 由后续遍历构造完全N叉树</span></span><br><span class=\"line\"><span class=\"comment\"> * @param post_order_arr 后续遍历数组</span></span><br><span class=\"line\"><span class=\"comment\"> * @param size 数组长度</span></span><br><span class=\"line\"><span class=\"comment\"> * @param k 等同于N叉树的N</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 构造的k叉树的根节点指针</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">Node&lt;T&gt; *<span class=\"title\">construct_n_binary_tree</span><span class=\"params\">(T *post_order_arr, <span class=\"type\">int</span> size, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造当前树的根节点</span></span><br><span class=\"line\">    Node&lt;T&gt; *root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>&lt;T&gt;(post_order_arr[size - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 说明该节点(rot)是叶子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 求树高。根据完全N叉树的特性推导而来</span></span><br><span class=\"line\">    <span class=\"type\">int</span> height_of_tree = <span class=\"built_in\">ceil</span>(<span class=\"built_in\">log2</span>(size * (k - <span class=\"number\">1</span>) + <span class=\"number\">1</span>) / <span class=\"built_in\">log2</span>(k)) - <span class=\"number\">1</span>; <span class=\"comment\">// 向上取整</span></span><br><span class=\"line\">    <span class=\"comment\">// 最后一层节点数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> nodes_in_last_level = size - (<span class=\"built_in\">pow</span>(k, height_of_tree) - <span class=\"number\">1</span>) / (k - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> tracker = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tracker != (size - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * pow(k, height_of_tree - 1)： 树高 height_of_tree - 1 的情况下，理论最后一层满节点数量（根节点在第0层）</span></span><br><span class=\"line\"><span class=\"comment\">         * nodes_in_last_level： 实际最后一层节点数量</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"type\">int</span> last_level_nodes = (<span class=\"built_in\">pow</span>(k, height_of_tree - <span class=\"number\">1</span>) &gt; nodes_in_last_level) ? nodes_in_last_level : <span class=\"built_in\">pow</span>(k, height_of_tree - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * （从左到右）以root的孩子为根节点的子树的节点数量</span></span><br><span class=\"line\"><span class=\"comment\">         * (pow(k, height_of_tree - 1) - 1) / (k - 1): 树高 height_of_tree - 2 情况下，满k叉树的节点数量（注意：树高度+1==总层数）</span></span><br><span class=\"line\"><span class=\"comment\">         * last_level_nodes：</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"type\">int</span> nodes_in_next_subtree = ((<span class=\"built_in\">pow</span>(k, height_of_tree - <span class=\"number\">1</span>) - <span class=\"number\">1</span>) / (k - <span class=\"number\">1</span>)) + last_level_nodes;</span><br><span class=\"line\"></span><br><span class=\"line\">        root-&gt;<span class=\"built_in\">add_child</span>(<span class=\"built_in\">construct_n_binary_tree</span>(post_order_arr + tracker, nodes_in_next_subtree, k));</span><br><span class=\"line\">        tracker += nodes_in_next_subtree;        <span class=\"comment\">// 已经构建的子树的节点数之和</span></span><br><span class=\"line\">        nodes_in_last_level -= last_level_nodes; <span class=\"comment\">// 去掉已经构建的子树的最后一层的节点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 前序遍历n叉树</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printPreOrder</span><span class=\"params\">(Node&lt;T&gt; *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::cout &lt;&lt; root-&gt;<span class=\"built_in\">get_data</span>() &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printPreOrder</span>(root-&gt;<span class=\"built_in\">get_first_child</span>()); <span class=\"comment\">// 递归遍历root的左边第一个孩子时，也会将它的兄弟(root的第二, 第三,...第k个孩子)一块遍历</span></span><br><span class=\"line\">    <span class=\"built_in\">printPreOrder</span>(root-&gt;<span class=\"built_in\">get_next_sibling</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放空间</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">destroy_n_binary_tree</span><span class=\"params\">(Node&lt;T&gt; *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;<span class=\"built_in\">get_next_sibling</span>() != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">destroy_n_binary_tree</span>(root-&gt;<span class=\"built_in\">get_next_sibling</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;<span class=\"built_in\">get_first_child</span>() != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">destroy_n_binary_tree</span>(root-&gt;<span class=\"built_in\">get_first_child</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;deleted: &quot;</span> &lt;&lt; root-&gt;<span class=\"built_in\">get_data</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> size = <span class=\"built_in\">sizeof</span>(arr) / <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    Node&lt;<span class=\"type\">int</span>&gt; *root = <span class=\"built_in\">construct_n_binary_tree</span>(arr, size, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printPreOrder</span>(root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">destroy_n_binary_tree</span>(root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正确输出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">3</span> <span class=\"number\">8</span> <span class=\"number\">9</span> <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"由后续遍历构建完全N叉树的思路\">由后续遍历构建完全N叉树的思路</h5>\n<p>核心思路：递归。<strong>难点：如何求得根节点的各个子节点所在子树的节点总数</strong>。</p>\n<ol>\n<li>传入要构建的树的后续遍历，以及总节点数。还有树的分叉数：N。</li>\n<li>识别根节点。同时求得树高（推导数学公式）</li>\n<li>循环：\n<ol>\n<li>计算根节点的第<code>i</code>个孩子所在的子树所拥有的节点数（数学方法+逻辑推理）（$1\\leq i\\leq k$）（<mark>此处为了便于理解引入变量<code>i</code>，实际实现时循环中并不存在变量<code>i</code></mark>）</li>\n<li>构建根节点的第<code>i</code>个孩子所在的子树（<mark>递归</mark>。传入后续遍历（通过原数组偏移量和节点数））。构建完成后挂载到根节点上。</li>\n<li>记录已经构建完成的子树的节点数之和（循环累加）</li>\n<li>如果：已经构建完成的节点树之和<mark>等于</mark>总节点数-1，（如果构建成功只能是等于，不能是大于），那么该树构建完成。</li>\n</ol>\n</li>\n<li>返回构建的根节点。</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"完全二叉树\">完全二叉树</h2>\n<h3 id=\"基本概念\">基本概念</h3>\n<p>完全二叉树：基于二叉树，要求除了最下层外，其余各层都是满节点。<mark>并且，最后一层的节点必须尽可能向左放</mark>。</p>\n<p>例：下面所有二叉树都<mark>不是</mark>完全二叉树：</p>\n<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/image2a5cac1b30c8c3c2a29f6b9903c5dfcf.png\" alt=\"例1\" style=\"zoom:67%;\" />\n<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/image20250709221221457.png\" alt=\"例2\" style=\"zoom:67%;\" />\n<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageb7853ade89f82f3208931148ebeca351.png\" alt=\"例3\" style=\"zoom:67%;\" />\n<h3 id=\"特征\">特征</h3>\n<ul>\n<li>叶子节点之可能在最下面的<strong>两层</strong>出现</li>\n<li>对任意结点，若其<code>右分支下的子孙最大层次为L</code>，则其<code>左分支下的子孙的最大层次必为L或L+1</code>。</li>\n<li>所有节点中，<mark>最多只有一个节点度为1</mark>（只有一个孩子）。</li>\n</ul>\n<h3 id=\"实现\">实现</h3>\n<p>方便起见，<mark>完全二叉树一般用数组实现</mark>而不用链表。</p>\n<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250709232438563.png\" alt=\"例图\" style=\"zoom:67%;\" />\n<p>对于用数组存储的完全二叉树，有以下特点：（<strong>下标从0开始</strong>）（根节点层数为1）</p>\n<ol>\n<li>如果一个节点在数组中下标为<code>i</code>，则它在树中的层数为<mark> $\\left\\lfloor log_2{(i+1)} \\right\\rfloor$ </mark>（向下取整），它的左子节点在数组中对应的下标为：$2i+1$（如果存在），右子节点在数组中对应的下标为$2i+2$（如果存在）。</li>\n<li>如果完全二叉树总共有<code>n (n&gt;0)</code>个节点，那么树高：<mark> $h=\\left \\lfloor log_2{n} \\right \\rfloor+1$ </mark>（或者<mark>$\\left\\lceil log_2{(n+1)} \\right\\rceil$</mark>）。</li>\n<li>如果完全二叉树树高<code>h</code>，那么这个完全二叉树最多拥有$2^h-1$个节点。</li>\n</ol>\n<p>如果<strong>根节点下标从1开始</strong>，那么第一条中，左子节点对应下标改为：<mark>$2i$</mark>，右子节点对应下标改为：<mark>$2i+1$</mark>。（相比于下标从0开始，直接-1）</p>\n<h4 id=\"用数组构建完全二叉树\">用数组构建完全二叉树</h4>\n<blockquote>\n<p>给定一个数组，用层序便利构建二叉树。然后输出它的中序遍历。</p>\n<p>例如：<img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250710180412848.png\" alt=\"image-20250710180412848\" style=\"zoom: 67%;\" /></p>\n</blockquote>\n<p>C++实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 两种方法：</span></span><br><span class=\"line\"><span class=\"comment\"> * 1. 递归</span></span><br><span class=\"line\"><span class=\"comment\"> * 2. 队列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> data;</span><br><span class=\"line\">    Node *left;</span><br><span class=\"line\">    Node *right;</span><br><span class=\"line\">    <span class=\"built_in\">Node</span>() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(<span class=\"type\">int</span> data, Node *left, Node *right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;data = data;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;left = left;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;right = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;test&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">inorderPrintTree</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">inorderPrintTree</span>(root-&gt;left);</span><br><span class=\"line\">    std::cout &lt;&lt; root-&gt;data &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">inorderPrintTree</span>(root-&gt;right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">destroyTree</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">destroyTree</span>(root-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">destroyTree</span>(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;destroyed node: &quot;</span> &lt;&lt; root-&gt;data &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 非递归构建：使用栈</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unRecursion</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> size = <span class=\"built_in\">sizeof</span>(arr) / <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    Node *root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(arr[<span class=\"number\">0</span>], <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    Node *point = root;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::queue&lt;Node *&gt; que;</span><br><span class=\"line\">    que.<span class=\"built_in\">push</span>(point);</span><br><span class=\"line\">    <span class=\"type\">int</span> index = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构建完全二叉树</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (index &lt; size) &#123;</span><br><span class=\"line\">        point = que.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        que.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; size) &#123;</span><br><span class=\"line\">            point-&gt;left = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(arr[index++], <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">            que.<span class=\"built_in\">push</span>(point-&gt;left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; size) &#123;</span><br><span class=\"line\">            point-&gt;right = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(arr[index++], <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">            que.<span class=\"built_in\">push</span>(point-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 中序遍历</span></span><br><span class=\"line\">    <span class=\"built_in\">inorderPrintTree</span>(root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">destroyTree</span>(root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 递归构建</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">recursion</span><span class=\"params\">(<span class=\"type\">int</span> arr[], <span class=\"type\">int</span> i, <span class=\"type\">int</span> n, Node *&amp;root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; n) &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(arr[i], <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        <span class=\"built_in\">recursion</span>(arr, i * <span class=\"number\">2</span> + <span class=\"number\">1</span>, n, root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">recursion</span>(arr, i * <span class=\"number\">2</span> + <span class=\"number\">2</span>, n, root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// unRecursion();\t\t\t\t// 非递归</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 递归</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> size = <span class=\"built_in\">sizeof</span>(arr) / <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    Node *root = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">recursion</span>(arr, <span class=\"number\">0</span>, size, root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">inorderPrintTree</span>(root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">destroyTree</span>(root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"非递归方法构建完全二叉树的思路：\">非递归方法构建完全二叉树的思路：</h5>\n<p><strong>使用队列保存已经构建好的部分的层序遍历顺序。</strong></p>\n<ul>\n<li>首先，构建根节点，然后根节点进入队列。</li>\n<li>循环：\n<ul>\n<li>如果队列不为空，从队列中取出节点元素。</li>\n<li>构建该节点的左右子节点（如果存在的话）。并且将构建好的左子节点和右子节点分别入队。也就是将下一层的元素放入队列。</li>\n<li>如果队列为空，跳出循环。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"递归方法构建思路：\">递归方法构建思路：</h5>\n<ul>\n<li>传入节点数组。并且传入当前要构建的节点在数组中的下标。</li>\n<li>根据数组中的元素值构建当前节点。</li>\n<li>判断左右子节点：(假设完全二叉树根节点对应数组下标为1)\n<ul>\n<li>左子节点(<code>2i+1</code>)存在：递归调用函数进行构建</li>\n<li>右子节点(<code>2i+2</code>)存在：递归调用函数进行构建</li>\n</ul>\n</li>\n<li>返回当前构建好的节点的指针，便于将不同节点连接在一起。</li>\n</ul>\n<h2 id=\"完全N叉树\">完全N叉树</h2>\n<p>与完全二叉树类似：</p>\n<ul>\n<li>除了最后一层，其余各层已经满节点。</li>\n<li>最后一层的所有节点尽可能向左边放。</li>\n</ul>\n<h3 id=\"由后续遍历构建完全N叉树\">由后续遍历构建完全N叉树</h3>\n<p>给定一个大小为<strong>M</strong>的数组<code>arr[]</code> ，其中包含<strong>完整 N 叉树</strong>的后序遍历，任务是生成 N 叉树并打印其<strong>前序遍历</strong>。</p>\n<p>例图：</p>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250713220657917.png\" alt=\"完全3叉树\"></p>\n<p>C++实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    根据后续遍历生成完全n叉树，然后输出它的前序遍历</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(T data);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取左边第一个子节点</span></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">get_first_child</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first_child;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取右边下一个兄弟节点</span></span><br><span class=\"line\">    <span class=\"function\">Node *<span class=\"title\">get_next_sibling</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> next_sibling;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">append_add_sibling</span><span class=\"params\">(Node *sibling)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next_sibling == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;next_sibling = sibling;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            next_sibling-&gt;<span class=\"built_in\">append_add_sibling</span>(sibling);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add_child</span><span class=\"params\">(Node *child)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first_child == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            first_child = child;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            first_child-&gt;<span class=\"built_in\">append_add_sibling</span>(child);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">get_data</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    Node *first_child;</span><br><span class=\"line\">    Node *next_sibling;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\">Node&lt;T&gt;::<span class=\"built_in\">Node</span>(T data) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;data = data;</span><br><span class=\"line\">    first_child = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    next_sibling = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 由后续遍历构造完全N叉树</span></span><br><span class=\"line\"><span class=\"comment\"> * @param post_order_arr 后续遍历数组</span></span><br><span class=\"line\"><span class=\"comment\"> * @param size 数组长度</span></span><br><span class=\"line\"><span class=\"comment\"> * @param k 等同于N叉树的N</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 构造的k叉树的根节点指针</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">Node&lt;T&gt; *<span class=\"title\">construct_n_binary_tree</span><span class=\"params\">(T *post_order_arr, <span class=\"type\">int</span> size, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造当前树的根节点</span></span><br><span class=\"line\">    Node&lt;T&gt; *root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>&lt;T&gt;(post_order_arr[size - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 说明该节点(rot)是叶子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 求树高。根据完全N叉树的特性推导而来</span></span><br><span class=\"line\">    <span class=\"type\">int</span> height_of_tree = <span class=\"built_in\">ceil</span>(<span class=\"built_in\">log2</span>(size * (k - <span class=\"number\">1</span>) + <span class=\"number\">1</span>) / <span class=\"built_in\">log2</span>(k)) - <span class=\"number\">1</span>; <span class=\"comment\">// 向上取整</span></span><br><span class=\"line\">    <span class=\"comment\">// 最后一层节点数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> nodes_in_last_level = size - (<span class=\"built_in\">pow</span>(k, height_of_tree) - <span class=\"number\">1</span>) / (k - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> tracker = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tracker != (size - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * pow(k, height_of_tree - 1)： 树高 height_of_tree - 1 的情况下，理论最后一层满节点数量（根节点在第0层）</span></span><br><span class=\"line\"><span class=\"comment\">         * nodes_in_last_level： 实际最后一层节点数量</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"type\">int</span> last_level_nodes = (<span class=\"built_in\">pow</span>(k, height_of_tree - <span class=\"number\">1</span>) &gt; nodes_in_last_level) ? nodes_in_last_level : <span class=\"built_in\">pow</span>(k, height_of_tree - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * （从左到右）以root的孩子为根节点的子树的节点数量</span></span><br><span class=\"line\"><span class=\"comment\">         * (pow(k, height_of_tree - 1) - 1) / (k - 1): 树高 height_of_tree - 2 情况下，满k叉树的节点数量（注意：树高度+1==总层数）</span></span><br><span class=\"line\"><span class=\"comment\">         * last_level_nodes：</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"type\">int</span> nodes_in_next_subtree = ((<span class=\"built_in\">pow</span>(k, height_of_tree - <span class=\"number\">1</span>) - <span class=\"number\">1</span>) / (k - <span class=\"number\">1</span>)) + last_level_nodes;</span><br><span class=\"line\"></span><br><span class=\"line\">        root-&gt;<span class=\"built_in\">add_child</span>(<span class=\"built_in\">construct_n_binary_tree</span>(post_order_arr + tracker, nodes_in_next_subtree, k));</span><br><span class=\"line\">        tracker += nodes_in_next_subtree;        <span class=\"comment\">// 已经构建的子树的节点数之和</span></span><br><span class=\"line\">        nodes_in_last_level -= last_level_nodes; <span class=\"comment\">// 去掉已经构建的子树的最后一层的节点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 前序遍历n叉树</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printPreOrder</span><span class=\"params\">(Node&lt;T&gt; *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::cout &lt;&lt; root-&gt;<span class=\"built_in\">get_data</span>() &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printPreOrder</span>(root-&gt;<span class=\"built_in\">get_first_child</span>()); <span class=\"comment\">// 递归遍历root的左边第一个孩子时，也会将它的兄弟(root的第二, 第三,...第k个孩子)一块遍历</span></span><br><span class=\"line\">    <span class=\"built_in\">printPreOrder</span>(root-&gt;<span class=\"built_in\">get_next_sibling</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放空间</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">destroy_n_binary_tree</span><span class=\"params\">(Node&lt;T&gt; *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;<span class=\"built_in\">get_next_sibling</span>() != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">destroy_n_binary_tree</span>(root-&gt;<span class=\"built_in\">get_next_sibling</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;<span class=\"built_in\">get_first_child</span>() != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">destroy_n_binary_tree</span>(root-&gt;<span class=\"built_in\">get_first_child</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;deleted: &quot;</span> &lt;&lt; root-&gt;<span class=\"built_in\">get_data</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> size = <span class=\"built_in\">sizeof</span>(arr) / <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    Node&lt;<span class=\"type\">int</span>&gt; *root = <span class=\"built_in\">construct_n_binary_tree</span>(arr, size, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printPreOrder</span>(root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">destroy_n_binary_tree</span>(root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正确输出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">3</span> <span class=\"number\">8</span> <span class=\"number\">9</span> <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"由后续遍历构建完全N叉树的思路\">由后续遍历构建完全N叉树的思路</h5>\n<p>核心思路：递归。<strong>难点：如何求得根节点的各个子节点所在子树的节点总数</strong>。</p>\n<ol>\n<li>传入要构建的树的后续遍历，以及总节点数。还有树的分叉数：N。</li>\n<li>识别根节点。同时求得树高（推导数学公式）</li>\n<li>循环：\n<ol>\n<li>计算根节点的第<code>i</code>个孩子所在的子树所拥有的节点数（数学方法+逻辑推理）（$1\\leq i\\leq k$）（<mark>此处为了便于理解引入变量<code>i</code>，实际实现时循环中并不存在变量<code>i</code></mark>）</li>\n<li>构建根节点的第<code>i</code>个孩子所在的子树（<mark>递归</mark>。传入后续遍历（通过原数组偏移量和节点数））。构建完成后挂载到根节点上。</li>\n<li>记录已经构建完成的子树的节点数之和（循环累加）</li>\n<li>如果：已经构建完成的节点树之和<mark>等于</mark>总节点数-1，（如果构建成功只能是等于，不能是大于），那么该树构建完成。</li>\n</ol>\n</li>\n<li>返回构建的根节点。</li>\n</ol>\n"},{"title":"满二叉树","date":"2025-07-12T16:00:00.000Z","updated":"2025-07-13T16:00:00.000Z","_content":"\n### 基本概念：\n\n满二叉树：**层数(高度)**为`H`，总节点数为$2^H-1$的二叉树。（根节点在第`1`层，所有叶子节点都在第`H`层）。\n\n> 此处认为`满二叉树 == 完美二叉树`。\n>\n> 有些地方存在另一种分类方法：完美(`prefect`)二叉树、完满(`full`)二叉树、完全(`complete`)二叉树。具体概念与上述满二叉树概念也有所区别，此处不做讨论。\n>\n> > 本文所讨论的满二叉树对应上面的完美(`prefect`)二叉树，而不对应完满(`full`)二叉树。\n> >\n> > 而上述完满(`full`)二叉树实际对应王道考研书中的**正则二叉树**。\n\n### 特点：\n\n- 第`i`层一定有$2^{i-1}$个节点。（根节点在第`1`层）\n- 前`i`层（`1 ~ i`层）节点数之和为$2^i-1$。\n\n### 由前序遍历构建满二叉树\n\n给定一个满二叉树的**前序遍历**数组，要求由该数组构建目标满二叉树，返回构建完成的满二叉树的根。然后输出该满二叉树的**中序遍历**。\n\n##### C++实现：\n\n**一般来说，构造二叉树不能只用前序遍历**，但这里给出了一个额外的条件，即该二叉树是满二叉树。我们可以利用这个额外的条件。\n\n对满二叉树来说：前序遍历中根之后的元素数量（假设为`n`）应该是偶数（2 * 一个子树中的节点数，因为它是满二叉树）。根据前序遍历的特点：对同一个根节点，它的左子树的前序遍历一定在它的右子树的前序遍历之前。那么我们就可以找到左子树的前序遍历和右子树的前序遍历。\n\n```cpp\n#include <iostream>\n\nstruct Node {\n    int data;\n    Node *left, *right;\n    Node(int val) {\n        data = val;\n        left = nullptr;\n        right = nullptr;\n    }\n};\n\n/**\n * @brief 由前序遍历构建满二叉树\n * @param preOrder 要构建的满二叉树的前序遍历\n * @param length 前序遍历的长度\n * @return 构建好的满二叉树的根节点\n */\nNode *creat_full_binary_tree(int *preOrder, int length) {\n    if (length == 0) {\n        return nullptr;\n    }\n    Node *root = new Node(preOrder[0]);\n    root->left = creat_full_binary_tree(preOrder + 1, (length - 1) / 2);\n    root->right = creat_full_binary_tree(preOrder + 1 + (length - 1) / 2, (length - 1) / 2);\n    return root;\n}\n\nvoid printInOrder(Node *root) {\n    if (root == nullptr) {\n        return;\n    }\n    printInOrder(root->left);\n    std::cout << root->data << \" \";\n    printInOrder(root->right);\n}\n\nvoid destroy_binary_tree(Node *root) {\n    if (root == nullptr) {\n        return;\n    }\n    destroy_binary_tree(root->left);\n    destroy_binary_tree(root->right);\n    std::cout << \"deleted: \" << root->data << std::endl;\n    delete root;\n}\n\nint main() {\n    int arr[] = {1, 2, 4, 5, 3, 6, 7};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    Node *root = creat_full_binary_tree(arr, size);\n    printInOrder(root);\n    destroy_binary_tree(root);\n\n    return 0;\n}\n```\n\n正确输出：\n\n```cpp\n4 2 5 1 6 3 7\n```\n\n","source":"_posts/数据结构/树/FullBinaryTree.md","raw":"---\ntitle: 满二叉树\ndate: 2025-07-13\nupdated: 2025-07-14\ntags: [数据结构, 二叉树, C++, 树]\ncategories: 数据结构\n---\n\n### 基本概念：\n\n满二叉树：**层数(高度)**为`H`，总节点数为$2^H-1$的二叉树。（根节点在第`1`层，所有叶子节点都在第`H`层）。\n\n> 此处认为`满二叉树 == 完美二叉树`。\n>\n> 有些地方存在另一种分类方法：完美(`prefect`)二叉树、完满(`full`)二叉树、完全(`complete`)二叉树。具体概念与上述满二叉树概念也有所区别，此处不做讨论。\n>\n> > 本文所讨论的满二叉树对应上面的完美(`prefect`)二叉树，而不对应完满(`full`)二叉树。\n> >\n> > 而上述完满(`full`)二叉树实际对应王道考研书中的**正则二叉树**。\n\n### 特点：\n\n- 第`i`层一定有$2^{i-1}$个节点。（根节点在第`1`层）\n- 前`i`层（`1 ~ i`层）节点数之和为$2^i-1$。\n\n### 由前序遍历构建满二叉树\n\n给定一个满二叉树的**前序遍历**数组，要求由该数组构建目标满二叉树，返回构建完成的满二叉树的根。然后输出该满二叉树的**中序遍历**。\n\n##### C++实现：\n\n**一般来说，构造二叉树不能只用前序遍历**，但这里给出了一个额外的条件，即该二叉树是满二叉树。我们可以利用这个额外的条件。\n\n对满二叉树来说：前序遍历中根之后的元素数量（假设为`n`）应该是偶数（2 * 一个子树中的节点数，因为它是满二叉树）。根据前序遍历的特点：对同一个根节点，它的左子树的前序遍历一定在它的右子树的前序遍历之前。那么我们就可以找到左子树的前序遍历和右子树的前序遍历。\n\n```cpp\n#include <iostream>\n\nstruct Node {\n    int data;\n    Node *left, *right;\n    Node(int val) {\n        data = val;\n        left = nullptr;\n        right = nullptr;\n    }\n};\n\n/**\n * @brief 由前序遍历构建满二叉树\n * @param preOrder 要构建的满二叉树的前序遍历\n * @param length 前序遍历的长度\n * @return 构建好的满二叉树的根节点\n */\nNode *creat_full_binary_tree(int *preOrder, int length) {\n    if (length == 0) {\n        return nullptr;\n    }\n    Node *root = new Node(preOrder[0]);\n    root->left = creat_full_binary_tree(preOrder + 1, (length - 1) / 2);\n    root->right = creat_full_binary_tree(preOrder + 1 + (length - 1) / 2, (length - 1) / 2);\n    return root;\n}\n\nvoid printInOrder(Node *root) {\n    if (root == nullptr) {\n        return;\n    }\n    printInOrder(root->left);\n    std::cout << root->data << \" \";\n    printInOrder(root->right);\n}\n\nvoid destroy_binary_tree(Node *root) {\n    if (root == nullptr) {\n        return;\n    }\n    destroy_binary_tree(root->left);\n    destroy_binary_tree(root->right);\n    std::cout << \"deleted: \" << root->data << std::endl;\n    delete root;\n}\n\nint main() {\n    int arr[] = {1, 2, 4, 5, 3, 6, 7};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    Node *root = creat_full_binary_tree(arr, size);\n    printInOrder(root);\n    destroy_binary_tree(root);\n\n    return 0;\n}\n```\n\n正确输出：\n\n```cpp\n4 2 5 1 6 3 7\n```\n\n","slug":"数据结构/树/FullBinaryTree","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfja9lqd004g4e4p7mir0p5q","content":"<h3 id=\"基本概念：\">基本概念：</h3>\n<p>满二叉树：**层数(高度)**为<code>H</code>，总节点数为$2^H-1$的二叉树。（根节点在第<code>1</code>层，所有叶子节点都在第<code>H</code>层）。</p>\n<blockquote>\n<p>此处认为<code>满二叉树 == 完美二叉树</code>。</p>\n<p>有些地方存在另一种分类方法：完美(<code>prefect</code>)二叉树、完满(<code>full</code>)二叉树、完全(<code>complete</code>)二叉树。具体概念与上述满二叉树概念也有所区别，此处不做讨论。</p>\n<blockquote>\n<p>本文所讨论的满二叉树对应上面的完美(<code>prefect</code>)二叉树，而不对应完满(<code>full</code>)二叉树。</p>\n<p>而上述完满(<code>full</code>)二叉树实际对应王道考研书中的<strong>正则二叉树</strong>。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"特点：\">特点：</h3>\n<ul>\n<li>第<code>i</code>层一定有$2^{i-1}$个节点。（根节点在第<code>1</code>层）</li>\n<li>前<code>i</code>层（<code>1 ~ i</code>层）节点数之和为$2^i-1$。</li>\n</ul>\n<h3 id=\"由前序遍历构建满二叉树\">由前序遍历构建满二叉树</h3>\n<p>给定一个满二叉树的<strong>前序遍历</strong>数组，要求由该数组构建目标满二叉树，返回构建完成的满二叉树的根。然后输出该满二叉树的<strong>中序遍历</strong>。</p>\n<h5 id=\"C-实现：\">C++实现：</h5>\n<p><strong>一般来说，构造二叉树不能只用前序遍历</strong>，但这里给出了一个额外的条件，即该二叉树是满二叉树。我们可以利用这个额外的条件。</p>\n<p>对满二叉树来说：前序遍历中根之后的元素数量（假设为<code>n</code>）应该是偶数（2 * 一个子树中的节点数，因为它是满二叉树）。根据前序遍历的特点：对同一个根节点，它的左子树的前序遍历一定在它的右子树的前序遍历之前。那么我们就可以找到左子树的前序遍历和右子树的前序遍历。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> data;</span><br><span class=\"line\">    Node *left, *right;</span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(<span class=\"type\">int</span> val) &#123;</span><br><span class=\"line\">        data = val;</span><br><span class=\"line\">        left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 由前序遍历构建满二叉树</span></span><br><span class=\"line\"><span class=\"comment\"> * @param preOrder 要构建的满二叉树的前序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * @param length 前序遍历的长度</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 构建好的满二叉树的根节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">creat_full_binary_tree</span><span class=\"params\">(<span class=\"type\">int</span> *preOrder, <span class=\"type\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node *root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(preOrder[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    root-&gt;left = <span class=\"built_in\">creat_full_binary_tree</span>(preOrder + <span class=\"number\">1</span>, (length - <span class=\"number\">1</span>) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    root-&gt;right = <span class=\"built_in\">creat_full_binary_tree</span>(preOrder + <span class=\"number\">1</span> + (length - <span class=\"number\">1</span>) / <span class=\"number\">2</span>, (length - <span class=\"number\">1</span>) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printInOrder</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printInOrder</span>(root-&gt;left);</span><br><span class=\"line\">    std::cout &lt;&lt; root-&gt;data &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printInOrder</span>(root-&gt;right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">destroy_binary_tree</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">destroy_binary_tree</span>(root-&gt;left);</span><br><span class=\"line\">    <span class=\"built_in\">destroy_binary_tree</span>(root-&gt;right);</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;deleted: &quot;</span> &lt;&lt; root-&gt;data &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> size = <span class=\"built_in\">sizeof</span>(arr) / <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    Node *root = <span class=\"built_in\">creat_full_binary_tree</span>(arr, size);</span><br><span class=\"line\">    <span class=\"built_in\">printInOrder</span>(root);</span><br><span class=\"line\">    <span class=\"built_in\">destroy_binary_tree</span>(root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正确输出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">2</span> <span class=\"number\">5</span> <span class=\"number\">1</span> <span class=\"number\">6</span> <span class=\"number\">3</span> <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"基本概念：\">基本概念：</h3>\n<p>满二叉树：**层数(高度)**为<code>H</code>，总节点数为$2^H-1$的二叉树。（根节点在第<code>1</code>层，所有叶子节点都在第<code>H</code>层）。</p>\n<blockquote>\n<p>此处认为<code>满二叉树 == 完美二叉树</code>。</p>\n<p>有些地方存在另一种分类方法：完美(<code>prefect</code>)二叉树、完满(<code>full</code>)二叉树、完全(<code>complete</code>)二叉树。具体概念与上述满二叉树概念也有所区别，此处不做讨论。</p>\n<blockquote>\n<p>本文所讨论的满二叉树对应上面的完美(<code>prefect</code>)二叉树，而不对应完满(<code>full</code>)二叉树。</p>\n<p>而上述完满(<code>full</code>)二叉树实际对应王道考研书中的<strong>正则二叉树</strong>。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"特点：\">特点：</h3>\n<ul>\n<li>第<code>i</code>层一定有$2^{i-1}$个节点。（根节点在第<code>1</code>层）</li>\n<li>前<code>i</code>层（<code>1 ~ i</code>层）节点数之和为$2^i-1$。</li>\n</ul>\n<h3 id=\"由前序遍历构建满二叉树\">由前序遍历构建满二叉树</h3>\n<p>给定一个满二叉树的<strong>前序遍历</strong>数组，要求由该数组构建目标满二叉树，返回构建完成的满二叉树的根。然后输出该满二叉树的<strong>中序遍历</strong>。</p>\n<h5 id=\"C-实现：\">C++实现：</h5>\n<p><strong>一般来说，构造二叉树不能只用前序遍历</strong>，但这里给出了一个额外的条件，即该二叉树是满二叉树。我们可以利用这个额外的条件。</p>\n<p>对满二叉树来说：前序遍历中根之后的元素数量（假设为<code>n</code>）应该是偶数（2 * 一个子树中的节点数，因为它是满二叉树）。根据前序遍历的特点：对同一个根节点，它的左子树的前序遍历一定在它的右子树的前序遍历之前。那么我们就可以找到左子树的前序遍历和右子树的前序遍历。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> data;</span><br><span class=\"line\">    Node *left, *right;</span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(<span class=\"type\">int</span> val) &#123;</span><br><span class=\"line\">        data = val;</span><br><span class=\"line\">        left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 由前序遍历构建满二叉树</span></span><br><span class=\"line\"><span class=\"comment\"> * @param preOrder 要构建的满二叉树的前序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> * @param length 前序遍历的长度</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 构建好的满二叉树的根节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">creat_full_binary_tree</span><span class=\"params\">(<span class=\"type\">int</span> *preOrder, <span class=\"type\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node *root = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(preOrder[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    root-&gt;left = <span class=\"built_in\">creat_full_binary_tree</span>(preOrder + <span class=\"number\">1</span>, (length - <span class=\"number\">1</span>) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    root-&gt;right = <span class=\"built_in\">creat_full_binary_tree</span>(preOrder + <span class=\"number\">1</span> + (length - <span class=\"number\">1</span>) / <span class=\"number\">2</span>, (length - <span class=\"number\">1</span>) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printInOrder</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printInOrder</span>(root-&gt;left);</span><br><span class=\"line\">    std::cout &lt;&lt; root-&gt;data &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printInOrder</span>(root-&gt;right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">destroy_binary_tree</span><span class=\"params\">(Node *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">destroy_binary_tree</span>(root-&gt;left);</span><br><span class=\"line\">    <span class=\"built_in\">destroy_binary_tree</span>(root-&gt;right);</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;deleted: &quot;</span> &lt;&lt; root-&gt;data &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> size = <span class=\"built_in\">sizeof</span>(arr) / <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    Node *root = <span class=\"built_in\">creat_full_binary_tree</span>(arr, size);</span><br><span class=\"line\">    <span class=\"built_in\">printInOrder</span>(root);</span><br><span class=\"line\">    <span class=\"built_in\">destroy_binary_tree</span>(root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正确输出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">2</span> <span class=\"number\">5</span> <span class=\"number\">1</span> <span class=\"number\">6</span> <span class=\"number\">3</span> <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n"},{"title":"红黑树","date":"2025-07-13T16:00:00.000Z","updated":"2025-07-14T16:00:00.000Z","_content":"\n### 概念\n\n> 一种自平衡的二叉搜索树。每个节点额外存储了一个 color 字段 (\"RED\" or \"BLACK\")，用于确保树在插入和删除时保持平衡。\n>\n> 红黑树是 4 阶 B 树（[2-3-4 树](https://oi-wiki.org/ds/2-3-4-tree/)）的变体。\n\n### 特点\n\n红黑树本身也是二叉搜索树，具有所有二叉搜索树的特点。\n\n**一棵合法的红黑树必须遵循以下性质**：\n\n1. <a name=\"性质1\">（节点颜色）所有节点为红色或黑色</a>。\n2. <a name=\"性质2\">（根节点）**根节点必须是黑色**</a>。\n3. <a name=\"性质3\">（叶子节点）`NIL` 节点（空叶子节点）都是黑色</a>。\n4. <a name=\"性质4\">（红色节点）红色节点的左右子节点都为黑色（从每个`NIL`节点到**根节点**的路径上不能有连续的两个红色节点）</a>。\n5. <a name=\"性质5\">（黑色节点）从<mark>任意节点</mark>到其所在子树的 `NIL` 节点的每条路径上的黑色节点数量相同（简称黑高）</a>。\n\n下图为一个合法的红黑树：\n\n![红黑树](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250623201450979.png)\n\n### 扩展特点\n\n- 最长路径**不超过**最短路径的两倍。\n- 由上一特点可得：任一节点的左右子树的高度差不会超过**2倍**。\n\n> 对比平衡二叉树：平衡二叉树要求左右子树高度相差不超过1，而红黑树要求左右子树高度差不超过2倍。由此看来平衡二叉树对平衡的要求更严格，插入时进行的旋转操作更多。\n\n### 实现\n\n#### 插入\n\n插入的新节点默认是<mark>红色</mark>节点。因为如果对一个红黑树插入一个黑色节点，无论黑色节点插在哪里，都会违反红黑树基本特点中的[第`5`条](#性质5)（因为插入之前的红黑树肯定满足以上所有特点，但插入后一定会破坏第`5`条）。\n\n那么在插入红色节点的情况下，可能会违反基本特点中的[第`4`条特点](#性质4)（不能有两个连续的红色节点）。如果没有违反特点，则不需要调整。如果违反了特点，就需要进行旋转，分为三种情况：\n\n- 新插入的节点是根节点：直接将根节点变黑（只有在**插入之前树为空**的情况下才会发生）。\n\n- 新插入节点的**叔叔节点**（父节点的兄弟节点）是**红色**：\n  - 调整新插入的节点的**父亲、叔叔、爷爷**三个节点的颜色：红色变为黑色，黑色变为红色。\n  - 令爷爷节点当作新插入节点，重新判断（循环或者递归）。\n  \n- 新插入节点的**叔叔节点**是**黑色**：\n\n  - 判断`LL, LR, RR, RL`四种失衡类型，然后旋转。因为只有连续两个红色节点才需要旋转，所以可以确定新插入节点的父节点一定是红色的。据此判断失衡类型。\n\n    - `LL`：\n\n      ![LL情况-右旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/image%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250727161732_25.jpg)\n\n    - `LR`：\n\n      ![LR情况-左右双旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/image%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250727161726_23.jpg)\n\n    - `RR`：\n    \n      ![RR情况-左旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/image%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250727161735_26.jpg)\n    \n    - `RL`：\n    \n      ![RL情况-右左双旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/image%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250727161716_22.jpg)\n\n\n#### 删除\n\n删除操作是红黑树逻辑最复杂的操作，主要是删除黑色节点时，会导致被删除节点所在路径上的黑色节点数量减`1`，导致违反上述基本性质中的[第`5`条性质](#性质5)。而删除红色节点则相对简单。\n\n##### 删除的情况分类\n\n对被删除节点的情况进行分类。\n\n- ###### 被删除节点只有左孩子/只有右孩子\n\n  **此时被删除节点一定为黑色节点**，因为如果是红色节点，那么一定是左右子树都存在或者左右子树都不存在，否则就会违背上述[第`5`条性质](#性质5)。\n\n  确定了被删除节点一定为**黑色**后，可以推得：被删除节点的**仅有的孩子节点**一定是红色。因为被删除节点的其中一个子树是空的，那么剩下的那个非空的子树中一定不会存在黑色节点，否则就会违反基本性质中的[第5条性质](#性质5)。\n\n  具体情况和对应操作见下图：\n\n  ![image-20250728155640665](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250728155640665.png)\n\n  可见，只需要将唯一的那个子节点向上提升，替代要删除的节点即可。\n\n- ###### 被删除节点左右孩子都有\n\n  可以转换为其他两种情况：用要删除的节点的右子树上的最小节点替换要删除的节点，然后删除右子树上的最小节点。如此递归，可转化为另外两种情况。\n\n- ###### 被删除节点没有孩子\n\n  - **被删除节点为黑色**：\n  \n    因为删除了黑色节点后，从该节点到根节点的路径上少了一个黑色节点，破坏了[第`5`条性质](#性质5)，所以需要观察兄弟节点和父亲节点颜色，分情况处理这缺失的一个黑色节点：\n  \n    - 兄弟节点为黑色：\n  \n      - 并且兄弟节点有一个与它<mark>方向一致</mark>的红色节点。父亲节点颜色随意:\n  \n        <mark>方向一致</mark>：指的是`brother`是`father`的左子节点并且`son`是`brother`的左子节点，或者`brother`是`father`的右子节点并且`son`是`brother`的右子节点。即：`father`、`brother`、`son`<三点共线>。\n  \n        > 此时执行**左旋**(`RR`情况下)或者**右旋**(`LL`情况下)。并且在旋转之前，先按步骤进行变色：son变为**黑色**，brother变为father的颜色，father变为黑色。\n  \n        ![兄黑同红子-红子变黑-兄变父色-父变黑色-外加单旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250729193857476.png)\n  \n      - 并且兄弟节点有一个与它<mark>方向相反</mark>的红色节点，**同时兄弟节点没有与它<mark>方向一致</mark>的红色子节点**。父亲节点颜色随意：\n  \n        <mark>方向相反</mark>：参考方向一致。`father`、`brother`、`son`三点不共线，即认为是方向相反。\n  \n        > 先让兄弟节点son变为父亲节点father的颜色，再让父亲节点father颜色变黑。最后分析情况执行**左右双旋**或者**右左双旋**。\n  \n        ![兄黑反红子-兄变父色-父变黑色-外加双旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250729193004686.png)\n  \n      - 并且**兄弟节点没有红色子节点**。**父亲**节点为<font style=\"background: white\" color=\"RED\">红色</font>：\n  \n        > 兄弟节点变红，父亲节点变黑。\n  \n        ![兄黑父红无红子-兄变红-父变黑](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250729230437194.png)\n  \n      - 并且**兄弟节点没有红色子节点**。**父亲**节点为<font style=\"background: white\" color=\"BLACK\">黑色</font>：\n  \n        > 兄弟节点变为红色，双黑标记上移至父亲节点（将父亲节点当作被删除节点）。递归判断父亲节点的情况。\n  \n        ![兄黑父黑-兄变红-父变双黑-递归判断](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250730001039457.png)\n  \n    - **兄弟**节点为<font style=\"background: white\" color=\"RED\">红色</font>：\n  \n      此时**兄弟节点没有红色子节点**，也不可能有红色子节点（[性质4](#性质4)）。同时**父亲**节点必定为<font style=\"background: white\" color=\"black\">黑色</font>（[性质4](#性质4)）。执行操作：\n  \n      > 兄弟节点变黑色，父亲节点变红色。然后左旋或者右旋父亲节点。（将父亲节点下移，兄弟节点上移）\n      \n      ![兄红父黑-先变色，再左旋或右旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250729192538724.png)\n    \n  - **被删除节点为红色**：\n  \n    最简单的情况。直接删除该节点。（因为没有左右孩子，并且不影响红黑树基本性质，所以可以直接删除，不做任何额外操作）\n\n#### 查询\n\n查询思路与二叉搜索树相同。\n\n#### C++实现\n\n```cpp\n#include <iostream>\n\n\n```\n\n","source":"_posts/数据结构/树/RBTree.md","raw":"---\ntitle: 红黑树\ndate: 2025-07-14\nupdated: 2025-07-15\ntags: [数据结构, 红黑树, 二叉树, C++]\ncategories: 数据结构\n---\n\n### 概念\n\n> 一种自平衡的二叉搜索树。每个节点额外存储了一个 color 字段 (\"RED\" or \"BLACK\")，用于确保树在插入和删除时保持平衡。\n>\n> 红黑树是 4 阶 B 树（[2-3-4 树](https://oi-wiki.org/ds/2-3-4-tree/)）的变体。\n\n### 特点\n\n红黑树本身也是二叉搜索树，具有所有二叉搜索树的特点。\n\n**一棵合法的红黑树必须遵循以下性质**：\n\n1. <a name=\"性质1\">（节点颜色）所有节点为红色或黑色</a>。\n2. <a name=\"性质2\">（根节点）**根节点必须是黑色**</a>。\n3. <a name=\"性质3\">（叶子节点）`NIL` 节点（空叶子节点）都是黑色</a>。\n4. <a name=\"性质4\">（红色节点）红色节点的左右子节点都为黑色（从每个`NIL`节点到**根节点**的路径上不能有连续的两个红色节点）</a>。\n5. <a name=\"性质5\">（黑色节点）从<mark>任意节点</mark>到其所在子树的 `NIL` 节点的每条路径上的黑色节点数量相同（简称黑高）</a>。\n\n下图为一个合法的红黑树：\n\n![红黑树](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250623201450979.png)\n\n### 扩展特点\n\n- 最长路径**不超过**最短路径的两倍。\n- 由上一特点可得：任一节点的左右子树的高度差不会超过**2倍**。\n\n> 对比平衡二叉树：平衡二叉树要求左右子树高度相差不超过1，而红黑树要求左右子树高度差不超过2倍。由此看来平衡二叉树对平衡的要求更严格，插入时进行的旋转操作更多。\n\n### 实现\n\n#### 插入\n\n插入的新节点默认是<mark>红色</mark>节点。因为如果对一个红黑树插入一个黑色节点，无论黑色节点插在哪里，都会违反红黑树基本特点中的[第`5`条](#性质5)（因为插入之前的红黑树肯定满足以上所有特点，但插入后一定会破坏第`5`条）。\n\n那么在插入红色节点的情况下，可能会违反基本特点中的[第`4`条特点](#性质4)（不能有两个连续的红色节点）。如果没有违反特点，则不需要调整。如果违反了特点，就需要进行旋转，分为三种情况：\n\n- 新插入的节点是根节点：直接将根节点变黑（只有在**插入之前树为空**的情况下才会发生）。\n\n- 新插入节点的**叔叔节点**（父节点的兄弟节点）是**红色**：\n  - 调整新插入的节点的**父亲、叔叔、爷爷**三个节点的颜色：红色变为黑色，黑色变为红色。\n  - 令爷爷节点当作新插入节点，重新判断（循环或者递归）。\n  \n- 新插入节点的**叔叔节点**是**黑色**：\n\n  - 判断`LL, LR, RR, RL`四种失衡类型，然后旋转。因为只有连续两个红色节点才需要旋转，所以可以确定新插入节点的父节点一定是红色的。据此判断失衡类型。\n\n    - `LL`：\n\n      ![LL情况-右旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/image%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250727161732_25.jpg)\n\n    - `LR`：\n\n      ![LR情况-左右双旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/image%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250727161726_23.jpg)\n\n    - `RR`：\n    \n      ![RR情况-左旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/image%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250727161735_26.jpg)\n    \n    - `RL`：\n    \n      ![RL情况-右左双旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/image%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250727161716_22.jpg)\n\n\n#### 删除\n\n删除操作是红黑树逻辑最复杂的操作，主要是删除黑色节点时，会导致被删除节点所在路径上的黑色节点数量减`1`，导致违反上述基本性质中的[第`5`条性质](#性质5)。而删除红色节点则相对简单。\n\n##### 删除的情况分类\n\n对被删除节点的情况进行分类。\n\n- ###### 被删除节点只有左孩子/只有右孩子\n\n  **此时被删除节点一定为黑色节点**，因为如果是红色节点，那么一定是左右子树都存在或者左右子树都不存在，否则就会违背上述[第`5`条性质](#性质5)。\n\n  确定了被删除节点一定为**黑色**后，可以推得：被删除节点的**仅有的孩子节点**一定是红色。因为被删除节点的其中一个子树是空的，那么剩下的那个非空的子树中一定不会存在黑色节点，否则就会违反基本性质中的[第5条性质](#性质5)。\n\n  具体情况和对应操作见下图：\n\n  ![image-20250728155640665](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250728155640665.png)\n\n  可见，只需要将唯一的那个子节点向上提升，替代要删除的节点即可。\n\n- ###### 被删除节点左右孩子都有\n\n  可以转换为其他两种情况：用要删除的节点的右子树上的最小节点替换要删除的节点，然后删除右子树上的最小节点。如此递归，可转化为另外两种情况。\n\n- ###### 被删除节点没有孩子\n\n  - **被删除节点为黑色**：\n  \n    因为删除了黑色节点后，从该节点到根节点的路径上少了一个黑色节点，破坏了[第`5`条性质](#性质5)，所以需要观察兄弟节点和父亲节点颜色，分情况处理这缺失的一个黑色节点：\n  \n    - 兄弟节点为黑色：\n  \n      - 并且兄弟节点有一个与它<mark>方向一致</mark>的红色节点。父亲节点颜色随意:\n  \n        <mark>方向一致</mark>：指的是`brother`是`father`的左子节点并且`son`是`brother`的左子节点，或者`brother`是`father`的右子节点并且`son`是`brother`的右子节点。即：`father`、`brother`、`son`<三点共线>。\n  \n        > 此时执行**左旋**(`RR`情况下)或者**右旋**(`LL`情况下)。并且在旋转之前，先按步骤进行变色：son变为**黑色**，brother变为father的颜色，father变为黑色。\n  \n        ![兄黑同红子-红子变黑-兄变父色-父变黑色-外加单旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250729193857476.png)\n  \n      - 并且兄弟节点有一个与它<mark>方向相反</mark>的红色节点，**同时兄弟节点没有与它<mark>方向一致</mark>的红色子节点**。父亲节点颜色随意：\n  \n        <mark>方向相反</mark>：参考方向一致。`father`、`brother`、`son`三点不共线，即认为是方向相反。\n  \n        > 先让兄弟节点son变为父亲节点father的颜色，再让父亲节点father颜色变黑。最后分析情况执行**左右双旋**或者**右左双旋**。\n  \n        ![兄黑反红子-兄变父色-父变黑色-外加双旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250729193004686.png)\n  \n      - 并且**兄弟节点没有红色子节点**。**父亲**节点为<font style=\"background: white\" color=\"RED\">红色</font>：\n  \n        > 兄弟节点变红，父亲节点变黑。\n  \n        ![兄黑父红无红子-兄变红-父变黑](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250729230437194.png)\n  \n      - 并且**兄弟节点没有红色子节点**。**父亲**节点为<font style=\"background: white\" color=\"BLACK\">黑色</font>：\n  \n        > 兄弟节点变为红色，双黑标记上移至父亲节点（将父亲节点当作被删除节点）。递归判断父亲节点的情况。\n  \n        ![兄黑父黑-兄变红-父变双黑-递归判断](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250730001039457.png)\n  \n    - **兄弟**节点为<font style=\"background: white\" color=\"RED\">红色</font>：\n  \n      此时**兄弟节点没有红色子节点**，也不可能有红色子节点（[性质4](#性质4)）。同时**父亲**节点必定为<font style=\"background: white\" color=\"black\">黑色</font>（[性质4](#性质4)）。执行操作：\n  \n      > 兄弟节点变黑色，父亲节点变红色。然后左旋或者右旋父亲节点。（将父亲节点下移，兄弟节点上移）\n      \n      ![兄红父黑-先变色，再左旋或右旋](https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250729192538724.png)\n    \n  - **被删除节点为红色**：\n  \n    最简单的情况。直接删除该节点。（因为没有左右孩子，并且不影响红黑树基本性质，所以可以直接删除，不做任何额外操作）\n\n#### 查询\n\n查询思路与二叉搜索树相同。\n\n#### C++实现\n\n```cpp\n#include <iostream>\n\n\n```\n\n","slug":"数据结构/树/RBTree","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfja9lqd004h4e4pb5ri120j","content":"<h3 id=\"概念\">概念</h3>\n<blockquote>\n<p>一种自平衡的二叉搜索树。每个节点额外存储了一个 color 字段 (“RED” or “BLACK”)，用于确保树在插入和删除时保持平衡。</p>\n<p>红黑树是 4 阶 B 树（<a href=\"https://oi-wiki.org/ds/2-3-4-tree/\">2-3-4 树</a>）的变体。</p>\n</blockquote>\n<h3 id=\"特点\">特点</h3>\n<p>红黑树本身也是二叉搜索树，具有所有二叉搜索树的特点。</p>\n<p><strong>一棵合法的红黑树必须遵循以下性质</strong>：</p>\n<ol>\n<li><a name=\"性质1\">（节点颜色）所有节点为红色或黑色</a>。</li>\n<li><a name=\"性质2\">（根节点）<strong>根节点必须是黑色</strong></a>。</li>\n<li><a name=\"性质3\">（叶子节点）<code>NIL</code> 节点（空叶子节点）都是黑色</a>。</li>\n<li><a name=\"性质4\">（红色节点）红色节点的左右子节点都为黑色（从每个<code>NIL</code>节点到<strong>根节点</strong>的路径上不能有连续的两个红色节点）</a>。</li>\n<li><a name=\"性质5\">（黑色节点）从<mark>任意节点</mark>到其所在子树的 <code>NIL</code> 节点的每条路径上的黑色节点数量相同（简称黑高）</a>。</li>\n</ol>\n<p>下图为一个合法的红黑树：</p>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250623201450979.png\" alt=\"红黑树\"></p>\n<h3 id=\"扩展特点\">扩展特点</h3>\n<ul>\n<li>最长路径<strong>不超过</strong>最短路径的两倍。</li>\n<li>由上一特点可得：任一节点的左右子树的高度差不会超过<strong>2倍</strong>。</li>\n</ul>\n<blockquote>\n<p>对比平衡二叉树：平衡二叉树要求左右子树高度相差不超过1，而红黑树要求左右子树高度差不超过2倍。由此看来平衡二叉树对平衡的要求更严格，插入时进行的旋转操作更多。</p>\n</blockquote>\n<h3 id=\"实现\">实现</h3>\n<h4 id=\"插入\">插入</h4>\n<p>插入的新节点默认是<mark>红色</mark>节点。因为如果对一个红黑树插入一个黑色节点，无论黑色节点插在哪里，都会违反红黑树基本特点中的<a href=\"#%E6%80%A7%E8%B4%A85\">第<code>5</code>条</a>（因为插入之前的红黑树肯定满足以上所有特点，但插入后一定会破坏第<code>5</code>条）。</p>\n<p>那么在插入红色节点的情况下，可能会违反基本特点中的<a href=\"#%E6%80%A7%E8%B4%A84\">第<code>4</code>条特点</a>（不能有两个连续的红色节点）。如果没有违反特点，则不需要调整。如果违反了特点，就需要进行旋转，分为三种情况：</p>\n<ul>\n<li>\n<p>新插入的节点是根节点：直接将根节点变黑（只有在<strong>插入之前树为空</strong>的情况下才会发生）。</p>\n</li>\n<li>\n<p>新插入节点的<strong>叔叔节点</strong>（父节点的兄弟节点）是<strong>红色</strong>：</p>\n<ul>\n<li>调整新插入的节点的<strong>父亲、叔叔、爷爷</strong>三个节点的颜色：红色变为黑色，黑色变为红色。</li>\n<li>令爷爷节点当作新插入节点，重新判断（循环或者递归）。</li>\n</ul>\n</li>\n<li>\n<p>新插入节点的<strong>叔叔节点</strong>是<strong>黑色</strong>：</p>\n<ul>\n<li>\n<p>判断<code>LL, LR, RR, RL</code>四种失衡类型，然后旋转。因为只有连续两个红色节点才需要旋转，所以可以确定新插入节点的父节点一定是红色的。据此判断失衡类型。</p>\n<ul>\n<li>\n<p><code>LL</code>：</p>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/image%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250727161732_25.jpg\" alt=\"LL情况-右旋\"></p>\n</li>\n<li>\n<p><code>LR</code>：</p>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/image%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250727161726_23.jpg\" alt=\"LR情况-左右双旋\"></p>\n</li>\n<li>\n<p><code>RR</code>：</p>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/image%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250727161735_26.jpg\" alt=\"RR情况-左旋\"></p>\n</li>\n<li>\n<p><code>RL</code>：</p>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/image%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250727161716_22.jpg\" alt=\"RL情况-右左双旋\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"删除\">删除</h4>\n<p>删除操作是红黑树逻辑最复杂的操作，主要是删除黑色节点时，会导致被删除节点所在路径上的黑色节点数量减<code>1</code>，导致违反上述基本性质中的<a href=\"#%E6%80%A7%E8%B4%A85\">第<code>5</code>条性质</a>。而删除红色节点则相对简单。</p>\n<h5 id=\"删除的情况分类\">删除的情况分类</h5>\n<p>对被删除节点的情况进行分类。</p>\n<ul>\n<li>\n<h6 id=\"被删除节点只有左孩子-只有右孩子\">被删除节点只有左孩子/只有右孩子</h6>\n<p><strong>此时被删除节点一定为黑色节点</strong>，因为如果是红色节点，那么一定是左右子树都存在或者左右子树都不存在，否则就会违背上述<a href=\"#%E6%80%A7%E8%B4%A85\">第<code>5</code>条性质</a>。</p>\n<p>确定了被删除节点一定为<strong>黑色</strong>后，可以推得：被删除节点的<strong>仅有的孩子节点</strong>一定是红色。因为被删除节点的其中一个子树是空的，那么剩下的那个非空的子树中一定不会存在黑色节点，否则就会违反基本性质中的<a href=\"#%E6%80%A7%E8%B4%A85\">第5条性质</a>。</p>\n<p>具体情况和对应操作见下图：</p>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250728155640665.png\" alt=\"image-20250728155640665\"></p>\n<p>可见，只需要将唯一的那个子节点向上提升，替代要删除的节点即可。</p>\n</li>\n<li>\n<h6 id=\"被删除节点左右孩子都有\">被删除节点左右孩子都有</h6>\n<p>可以转换为其他两种情况：用要删除的节点的右子树上的最小节点替换要删除的节点，然后删除右子树上的最小节点。如此递归，可转化为另外两种情况。</p>\n</li>\n<li>\n<h6 id=\"被删除节点没有孩子\">被删除节点没有孩子</h6>\n<ul>\n<li>\n<p><strong>被删除节点为黑色</strong>：</p>\n<p>因为删除了黑色节点后，从该节点到根节点的路径上少了一个黑色节点，破坏了<a href=\"#%E6%80%A7%E8%B4%A85\">第<code>5</code>条性质</a>，所以需要观察兄弟节点和父亲节点颜色，分情况处理这缺失的一个黑色节点：</p>\n<ul>\n<li>\n<p>兄弟节点为黑色：</p>\n<ul>\n<li>\n<p>并且兄弟节点有一个与它<mark>方向一致</mark>的红色节点。父亲节点颜色随意:</p>\n<p><mark>方向一致</mark>：指的是<code>brother</code>是<code>father</code>的左子节点并且<code>son</code>是<code>brother</code>的左子节点，或者<code>brother</code>是<code>father</code>的右子节点并且<code>son</code>是<code>brother</code>的右子节点。即：<code>father</code>、<code>brother</code>、<code>son</code>&lt;三点共线&gt;。</p>\n<blockquote>\n<p>此时执行<strong>左旋</strong>(<code>RR</code>情况下)或者<strong>右旋</strong>(<code>LL</code>情况下)。并且在旋转之前，先按步骤进行变色：son变为<strong>黑色</strong>，brother变为father的颜色，father变为黑色。</p>\n</blockquote>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250729193857476.png\" alt=\"兄黑同红子-红子变黑-兄变父色-父变黑色-外加单旋\"></p>\n</li>\n<li>\n<p>并且兄弟节点有一个与它<mark>方向相反</mark>的红色节点，<strong>同时兄弟节点没有与它<mark>方向一致</mark>的红色子节点</strong>。父亲节点颜色随意：</p>\n<p><mark>方向相反</mark>：参考方向一致。<code>father</code>、<code>brother</code>、<code>son</code>三点不共线，即认为是方向相反。</p>\n<blockquote>\n<p>先让兄弟节点son变为父亲节点father的颜色，再让父亲节点father颜色变黑。最后分析情况执行<strong>左右双旋</strong>或者<strong>右左双旋</strong>。</p>\n</blockquote>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250729193004686.png\" alt=\"兄黑反红子-兄变父色-父变黑色-外加双旋\"></p>\n</li>\n<li>\n<p>并且<strong>兄弟节点没有红色子节点</strong>。<strong>父亲</strong>节点为<font style=\"background: white\" color=\"RED\">红色</font>：</p>\n<blockquote>\n<p>兄弟节点变红，父亲节点变黑。</p>\n</blockquote>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250729230437194.png\" alt=\"兄黑父红无红子-兄变红-父变黑\"></p>\n</li>\n<li>\n<p>并且<strong>兄弟节点没有红色子节点</strong>。<strong>父亲</strong>节点为<font style=\"background: white\" color=\"BLACK\">黑色</font>：</p>\n<blockquote>\n<p>兄弟节点变为红色，双黑标记上移至父亲节点（将父亲节点当作被删除节点）。递归判断父亲节点的情况。</p>\n</blockquote>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250730001039457.png\" alt=\"兄黑父黑-兄变红-父变双黑-递归判断\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>兄弟</strong>节点为<font style=\"background: white\" color=\"RED\">红色</font>：</p>\n<p>此时<strong>兄弟节点没有红色子节点</strong>，也不可能有红色子节点（<a href=\"#%E6%80%A7%E8%B4%A84\">性质4</a>）。同时<strong>父亲</strong>节点必定为<font style=\"background: white\" color=\"black\">黑色</font>（<a href=\"#%E6%80%A7%E8%B4%A84\">性质4</a>）。执行操作：</p>\n<blockquote>\n<p>兄弟节点变黑色，父亲节点变红色。然后左旋或者右旋父亲节点。（将父亲节点下移，兄弟节点上移）</p>\n</blockquote>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250729192538724.png\" alt=\"兄红父黑-先变色，再左旋或右旋\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>被删除节点为红色</strong>：</p>\n<p>最简单的情况。直接删除该节点。（因为没有左右孩子，并且不影响红黑树基本性质，所以可以直接删除，不做任何额外操作）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"查询\">查询</h4>\n<p>查询思路与二叉搜索树相同。</p>\n<h4 id=\"C-实现\">C++实现</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"概念\">概念</h3>\n<blockquote>\n<p>一种自平衡的二叉搜索树。每个节点额外存储了一个 color 字段 (“RED” or “BLACK”)，用于确保树在插入和删除时保持平衡。</p>\n<p>红黑树是 4 阶 B 树（<a href=\"https://oi-wiki.org/ds/2-3-4-tree/\">2-3-4 树</a>）的变体。</p>\n</blockquote>\n<h3 id=\"特点\">特点</h3>\n<p>红黑树本身也是二叉搜索树，具有所有二叉搜索树的特点。</p>\n<p><strong>一棵合法的红黑树必须遵循以下性质</strong>：</p>\n<ol>\n<li><a name=\"性质1\">（节点颜色）所有节点为红色或黑色</a>。</li>\n<li><a name=\"性质2\">（根节点）<strong>根节点必须是黑色</strong></a>。</li>\n<li><a name=\"性质3\">（叶子节点）<code>NIL</code> 节点（空叶子节点）都是黑色</a>。</li>\n<li><a name=\"性质4\">（红色节点）红色节点的左右子节点都为黑色（从每个<code>NIL</code>节点到<strong>根节点</strong>的路径上不能有连续的两个红色节点）</a>。</li>\n<li><a name=\"性质5\">（黑色节点）从<mark>任意节点</mark>到其所在子树的 <code>NIL</code> 节点的每条路径上的黑色节点数量相同（简称黑高）</a>。</li>\n</ol>\n<p>下图为一个合法的红黑树：</p>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250623201450979.png\" alt=\"红黑树\"></p>\n<h3 id=\"扩展特点\">扩展特点</h3>\n<ul>\n<li>最长路径<strong>不超过</strong>最短路径的两倍。</li>\n<li>由上一特点可得：任一节点的左右子树的高度差不会超过<strong>2倍</strong>。</li>\n</ul>\n<blockquote>\n<p>对比平衡二叉树：平衡二叉树要求左右子树高度相差不超过1，而红黑树要求左右子树高度差不超过2倍。由此看来平衡二叉树对平衡的要求更严格，插入时进行的旋转操作更多。</p>\n</blockquote>\n<h3 id=\"实现\">实现</h3>\n<h4 id=\"插入\">插入</h4>\n<p>插入的新节点默认是<mark>红色</mark>节点。因为如果对一个红黑树插入一个黑色节点，无论黑色节点插在哪里，都会违反红黑树基本特点中的<a href=\"#%E6%80%A7%E8%B4%A85\">第<code>5</code>条</a>（因为插入之前的红黑树肯定满足以上所有特点，但插入后一定会破坏第<code>5</code>条）。</p>\n<p>那么在插入红色节点的情况下，可能会违反基本特点中的<a href=\"#%E6%80%A7%E8%B4%A84\">第<code>4</code>条特点</a>（不能有两个连续的红色节点）。如果没有违反特点，则不需要调整。如果违反了特点，就需要进行旋转，分为三种情况：</p>\n<ul>\n<li>\n<p>新插入的节点是根节点：直接将根节点变黑（只有在<strong>插入之前树为空</strong>的情况下才会发生）。</p>\n</li>\n<li>\n<p>新插入节点的<strong>叔叔节点</strong>（父节点的兄弟节点）是<strong>红色</strong>：</p>\n<ul>\n<li>调整新插入的节点的<strong>父亲、叔叔、爷爷</strong>三个节点的颜色：红色变为黑色，黑色变为红色。</li>\n<li>令爷爷节点当作新插入节点，重新判断（循环或者递归）。</li>\n</ul>\n</li>\n<li>\n<p>新插入节点的<strong>叔叔节点</strong>是<strong>黑色</strong>：</p>\n<ul>\n<li>\n<p>判断<code>LL, LR, RR, RL</code>四种失衡类型，然后旋转。因为只有连续两个红色节点才需要旋转，所以可以确定新插入节点的父节点一定是红色的。据此判断失衡类型。</p>\n<ul>\n<li>\n<p><code>LL</code>：</p>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/image%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250727161732_25.jpg\" alt=\"LL情况-右旋\"></p>\n</li>\n<li>\n<p><code>LR</code>：</p>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/image%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250727161726_23.jpg\" alt=\"LR情况-左右双旋\"></p>\n</li>\n<li>\n<p><code>RR</code>：</p>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/image%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250727161735_26.jpg\" alt=\"RR情况-左旋\"></p>\n</li>\n<li>\n<p><code>RL</code>：</p>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/image%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250727161716_22.jpg\" alt=\"RL情况-右左双旋\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"删除\">删除</h4>\n<p>删除操作是红黑树逻辑最复杂的操作，主要是删除黑色节点时，会导致被删除节点所在路径上的黑色节点数量减<code>1</code>，导致违反上述基本性质中的<a href=\"#%E6%80%A7%E8%B4%A85\">第<code>5</code>条性质</a>。而删除红色节点则相对简单。</p>\n<h5 id=\"删除的情况分类\">删除的情况分类</h5>\n<p>对被删除节点的情况进行分类。</p>\n<ul>\n<li>\n<h6 id=\"被删除节点只有左孩子-只有右孩子\">被删除节点只有左孩子/只有右孩子</h6>\n<p><strong>此时被删除节点一定为黑色节点</strong>，因为如果是红色节点，那么一定是左右子树都存在或者左右子树都不存在，否则就会违背上述<a href=\"#%E6%80%A7%E8%B4%A85\">第<code>5</code>条性质</a>。</p>\n<p>确定了被删除节点一定为<strong>黑色</strong>后，可以推得：被删除节点的<strong>仅有的孩子节点</strong>一定是红色。因为被删除节点的其中一个子树是空的，那么剩下的那个非空的子树中一定不会存在黑色节点，否则就会违反基本性质中的<a href=\"#%E6%80%A7%E8%B4%A85\">第5条性质</a>。</p>\n<p>具体情况和对应操作见下图：</p>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250728155640665.png\" alt=\"image-20250728155640665\"></p>\n<p>可见，只需要将唯一的那个子节点向上提升，替代要删除的节点即可。</p>\n</li>\n<li>\n<h6 id=\"被删除节点左右孩子都有\">被删除节点左右孩子都有</h6>\n<p>可以转换为其他两种情况：用要删除的节点的右子树上的最小节点替换要删除的节点，然后删除右子树上的最小节点。如此递归，可转化为另外两种情况。</p>\n</li>\n<li>\n<h6 id=\"被删除节点没有孩子\">被删除节点没有孩子</h6>\n<ul>\n<li>\n<p><strong>被删除节点为黑色</strong>：</p>\n<p>因为删除了黑色节点后，从该节点到根节点的路径上少了一个黑色节点，破坏了<a href=\"#%E6%80%A7%E8%B4%A85\">第<code>5</code>条性质</a>，所以需要观察兄弟节点和父亲节点颜色，分情况处理这缺失的一个黑色节点：</p>\n<ul>\n<li>\n<p>兄弟节点为黑色：</p>\n<ul>\n<li>\n<p>并且兄弟节点有一个与它<mark>方向一致</mark>的红色节点。父亲节点颜色随意:</p>\n<p><mark>方向一致</mark>：指的是<code>brother</code>是<code>father</code>的左子节点并且<code>son</code>是<code>brother</code>的左子节点，或者<code>brother</code>是<code>father</code>的右子节点并且<code>son</code>是<code>brother</code>的右子节点。即：<code>father</code>、<code>brother</code>、<code>son</code>&lt;三点共线&gt;。</p>\n<blockquote>\n<p>此时执行<strong>左旋</strong>(<code>RR</code>情况下)或者<strong>右旋</strong>(<code>LL</code>情况下)。并且在旋转之前，先按步骤进行变色：son变为<strong>黑色</strong>，brother变为father的颜色，father变为黑色。</p>\n</blockquote>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250729193857476.png\" alt=\"兄黑同红子-红子变黑-兄变父色-父变黑色-外加单旋\"></p>\n</li>\n<li>\n<p>并且兄弟节点有一个与它<mark>方向相反</mark>的红色节点，<strong>同时兄弟节点没有与它<mark>方向一致</mark>的红色子节点</strong>。父亲节点颜色随意：</p>\n<p><mark>方向相反</mark>：参考方向一致。<code>father</code>、<code>brother</code>、<code>son</code>三点不共线，即认为是方向相反。</p>\n<blockquote>\n<p>先让兄弟节点son变为父亲节点father的颜色，再让父亲节点father颜色变黑。最后分析情况执行<strong>左右双旋</strong>或者<strong>右左双旋</strong>。</p>\n</blockquote>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250729193004686.png\" alt=\"兄黑反红子-兄变父色-父变黑色-外加双旋\"></p>\n</li>\n<li>\n<p>并且<strong>兄弟节点没有红色子节点</strong>。<strong>父亲</strong>节点为<font style=\"background: white\" color=\"RED\">红色</font>：</p>\n<blockquote>\n<p>兄弟节点变红，父亲节点变黑。</p>\n</blockquote>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250729230437194.png\" alt=\"兄黑父红无红子-兄变红-父变黑\"></p>\n</li>\n<li>\n<p>并且<strong>兄弟节点没有红色子节点</strong>。<strong>父亲</strong>节点为<font style=\"background: white\" color=\"BLACK\">黑色</font>：</p>\n<blockquote>\n<p>兄弟节点变为红色，双黑标记上移至父亲节点（将父亲节点当作被删除节点）。递归判断父亲节点的情况。</p>\n</blockquote>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250730001039457.png\" alt=\"兄黑父黑-兄变红-父变双黑-递归判断\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>兄弟</strong>节点为<font style=\"background: white\" color=\"RED\">红色</font>：</p>\n<p>此时<strong>兄弟节点没有红色子节点</strong>，也不可能有红色子节点（<a href=\"#%E6%80%A7%E8%B4%A84\">性质4</a>）。同时<strong>父亲</strong>节点必定为<font style=\"background: white\" color=\"black\">黑色</font>（<a href=\"#%E6%80%A7%E8%B4%A84\">性质4</a>）。执行操作：</p>\n<blockquote>\n<p>兄弟节点变黑色，父亲节点变红色。然后左旋或者右旋父亲节点。（将父亲节点下移，兄弟节点上移）</p>\n</blockquote>\n<p><img src=\"https://image-1258881983.cos.ap-beijing.myqcloud.com/imageimage-20250729192538724.png\" alt=\"兄红父黑-先变色，再左旋或右旋\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>被删除节点为红色</strong>：</p>\n<p>最简单的情况。直接删除该节点。（因为没有左右孩子，并且不影响红黑树基本性质，所以可以直接删除，不做任何额外操作）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"查询\">查询</h4>\n<p>查询思路与二叉搜索树相同。</p>\n<h4 id=\"C-实现\">C++实现</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmfja9lph00034e4pgtsi38bp","category_id":"cmfja9lpj00064e4p8dna0jy1","_id":"cmfja9lpo000g4e4ph7mb5eal"},{"post_id":"cmfja9lpn000e4e4pgjkfcsqt","category_id":"cmfja9lpo000h4e4p0bwyg9fo","_id":"cmfja9lpq000r4e4p8bkefea2"},{"post_id":"cmfja9lpo000k4e4pavk08f2c","category_id":"cmfja9lpp000m4e4p39p5bgc0","_id":"cmfja9lpt000y4e4pc8c26x2g"},{"post_id":"cmfja9lpp000l4e4p428gb0ok","category_id":"cmfja9lpp000m4e4p39p5bgc0","_id":"cmfja9lpu00134e4p08ffgb1l"},{"post_id":"cmfja9lpq000p4e4p0v23c3tl","category_id":"cmfja9lpt000x4e4p7gvoabi6","_id":"cmfja9lpw001a4e4p7ieb3u7j"},{"post_id":"cmfja9lpq000q4e4pedfi4ffq","category_id":"cmfja9lpv00154e4pcsxt3t4s","_id":"cmfja9lpx001i4e4pegf8bxia"},{"post_id":"cmfja9lpr000s4e4p36zj460g","category_id":"cmfja9lpv00154e4pcsxt3t4s","_id":"cmfja9lpy001o4e4p4le6dyqo"},{"post_id":"cmfja9lps000v4e4pajp21yzz","category_id":"cmfja9lpv00154e4pcsxt3t4s","_id":"cmfja9lq0001u4e4p1iehd8mv"},{"post_id":"cmfja9lpz001p4e4p76mrfy0p","category_id":"cmfja9lpj00064e4p8dna0jy1","_id":"cmfja9lq100204e4pbsmu8v2o"},{"post_id":"cmfja9lpt000w4e4pddw409qf","category_id":"cmfja9lpv00154e4pcsxt3t4s","_id":"cmfja9lq100234e4ph1plhjjj"},{"post_id":"cmfja9lpt00104e4p409sdmhj","category_id":"cmfja9lq0001t4e4p4muy5d3c","_id":"cmfja9lq200274e4phu0h5xx8"},{"post_id":"cmfja9lpu00124e4pgjpaea2r","category_id":"cmfja9lq0001t4e4p4muy5d3c","_id":"cmfja9lq4002c4e4p54cqg2pu"},{"post_id":"cmfja9lpv00174e4p5ejsdewd","category_id":"cmfja9lq0001t4e4p4muy5d3c","_id":"cmfja9lq4002e4e4p8qul1zh5"},{"post_id":"cmfja9lq0001z4e4phr0lhziv","category_id":"cmfja9lq4002b4e4p5lioh504","_id":"cmfja9lq5002l4e4p9hro3k4j"},{"post_id":"cmfja9lq100224e4p61pl7j9i","category_id":"cmfja9lq4002b4e4p5lioh504","_id":"cmfja9lq6002q4e4phehnbv6f"},{"post_id":"cmfja9lq200254e4p86hb02kj","category_id":"cmfja9lq4002b4e4p5lioh504","_id":"cmfja9lq6002t4e4p3jfu74xh"},{"post_id":"cmfja9lq300284e4pen49aihh","category_id":"cmfja9lq4002b4e4p5lioh504","_id":"cmfja9lq7002x4e4p4zpc84vg"},{"post_id":"cmfja9lq3002a4e4pfas86woq","category_id":"cmfja9lq4002b4e4p5lioh504","_id":"cmfja9lq700314e4pfssoasn2"},{"post_id":"cmfja9lqd004g4e4p7mir0p5q","category_id":"cmfja9lq4002b4e4p5lioh504","_id":"cmfja9lqe004l4e4pgpom0h2u"},{"post_id":"cmfja9lqd004h4e4pb5ri120j","category_id":"cmfja9lq4002b4e4p5lioh504","_id":"cmfja9lqe004n4e4p60ggbin7"}],"PostTag":[{"post_id":"cmfja9lph00034e4pgtsi38bp","tag_id":"cmfja9lpk00074e4p230y3gcq","_id":"cmfja9lpm000d4e4p7fbeb7q2"},{"post_id":"cmfja9lpn000e4e4pgjkfcsqt","tag_id":"cmfja9lpo000i4e4p7u3chzsv","_id":"cmfja9lpq000o4e4p70uw4194"},{"post_id":"cmfja9lpo000k4e4pavk08f2c","tag_id":"cmfja9lpk00074e4p230y3gcq","_id":"cmfja9lpu00114e4p623eaf7o"},{"post_id":"cmfja9lpo000k4e4pavk08f2c","tag_id":"cmfja9lpq000n4e4pbb71hipc","_id":"cmfja9lpu00144e4p0ljibdwh"},{"post_id":"cmfja9lpo000k4e4pavk08f2c","tag_id":"cmfja9lpr000u4e4p5p456zww","_id":"cmfja9lpw00184e4pde1p4iug"},{"post_id":"cmfja9lpp000l4e4p428gb0ok","tag_id":"cmfja9lpk00074e4p230y3gcq","_id":"cmfja9lpx001e4e4pf1bt4ii0"},{"post_id":"cmfja9lpp000l4e4p428gb0ok","tag_id":"cmfja9lpt000z4e4p6cf50qn2","_id":"cmfja9lpx001g4e4pa97h4gza"},{"post_id":"cmfja9lpp000l4e4p428gb0ok","tag_id":"cmfja9lpr000u4e4p5p456zww","_id":"cmfja9lpy001l4e4pa1epa5uz"},{"post_id":"cmfja9lpq000p4e4p0v23c3tl","tag_id":"cmfja9lpw001c4e4p5no02iqo","_id":"cmfja9lpz001r4e4p8gzt75sb"},{"post_id":"cmfja9lpq000p4e4p0v23c3tl","tag_id":"cmfja9lpk00074e4p230y3gcq","_id":"cmfja9lq0001v4e4p9g4a8dy1"},{"post_id":"cmfja9lpq000p4e4p0v23c3tl","tag_id":"cmfja9lpx001j4e4p32m7h3lp","_id":"cmfja9lq0001y4e4p04pu1dle"},{"post_id":"cmfja9lpq000q4e4pedfi4ffq","tag_id":"cmfja9lpz001q4e4pfvpxehx2","_id":"cmfja9lq4002f4e4phs11b73v"},{"post_id":"cmfja9lpq000q4e4pedfi4ffq","tag_id":"cmfja9lq0001x4e4pfp8m3ixi","_id":"cmfja9lq5002h4e4pcq7v4w1h"},{"post_id":"cmfja9lpq000q4e4pedfi4ffq","tag_id":"cmfja9lq200244e4p6vge7gyu","_id":"cmfja9lq5002j4e4pcwk0fgie"},{"post_id":"cmfja9lpq000q4e4pedfi4ffq","tag_id":"cmfja9lq300294e4pafligqi0","_id":"cmfja9lq5002m4e4pg5igdv4h"},{"post_id":"cmfja9lpr000s4e4p36zj460g","tag_id":"cmfja9lq4002d4e4pbv0lau4b","_id":"cmfja9lq6002o4e4p4t8dejbw"},{"post_id":"cmfja9lps000v4e4pajp21yzz","tag_id":"cmfja9lpz001q4e4pfvpxehx2","_id":"cmfja9lq6002u4e4p7ofcbg63"},{"post_id":"cmfja9lps000v4e4pajp21yzz","tag_id":"cmfja9lq0001x4e4pfp8m3ixi","_id":"cmfja9lq6002v4e4p0drff6mo"},{"post_id":"cmfja9lpt000w4e4pddw409qf","tag_id":"cmfja9lq0001x4e4pfp8m3ixi","_id":"cmfja9lq7002y4e4p62ehgief"},{"post_id":"cmfja9lpt000w4e4pddw409qf","tag_id":"cmfja9lpk00074e4p230y3gcq","_id":"cmfja9lq7002z4e4p6aivh0p0"},{"post_id":"cmfja9lpt00104e4p409sdmhj","tag_id":"cmfja9lq200244e4p6vge7gyu","_id":"cmfja9lq800334e4pe2ai7msw"},{"post_id":"cmfja9lpt00104e4p409sdmhj","tag_id":"cmfja9lq700304e4phiufcioo","_id":"cmfja9lq800344e4pahosc02r"},{"post_id":"cmfja9lpt00104e4p409sdmhj","tag_id":"cmfja9lpk00074e4p230y3gcq","_id":"cmfja9lq800364e4pfsih7tyn"},{"post_id":"cmfja9lpu00124e4pgjpaea2r","tag_id":"cmfja9lq200244e4p6vge7gyu","_id":"cmfja9lq800384e4pfwdw3894"},{"post_id":"cmfja9lpu00124e4pgjpaea2r","tag_id":"cmfja9lq800354e4pbjx0gfm2","_id":"cmfja9lq800394e4p58s12ant"},{"post_id":"cmfja9lpv00174e4p5ejsdewd","tag_id":"cmfja9lq200244e4p6vge7gyu","_id":"cmfja9lq8003b4e4p69djhumt"},{"post_id":"cmfja9lpv00174e4p5ejsdewd","tag_id":"cmfja9lpk00074e4p230y3gcq","_id":"cmfja9lq8003c4e4pee6u8p8x"},{"post_id":"cmfja9lpz001p4e4p76mrfy0p","tag_id":"cmfja9lpk00074e4p230y3gcq","_id":"cmfja9lq9003e4e4pcrom6ult"},{"post_id":"cmfja9lpz001p4e4p76mrfy0p","tag_id":"cmfja9lq8003a4e4pb8iy8wa3","_id":"cmfja9lq9003f4e4p9ku56n0i"},{"post_id":"cmfja9lq0001z4e4phr0lhziv","tag_id":"cmfja9lq8003d4e4patkhfbln","_id":"cmfja9lq9003j4e4pfcv4g1yr"},{"post_id":"cmfja9lq0001z4e4phr0lhziv","tag_id":"cmfja9lq9003g4e4p6hqz6itb","_id":"cmfja9lq9003k4e4pfgecb1wv"},{"post_id":"cmfja9lq0001z4e4phr0lhziv","tag_id":"cmfja9lq9003h4e4pbd2u017u","_id":"cmfja9lq9003m4e4ph2lc4goh"},{"post_id":"cmfja9lq0001z4e4phr0lhziv","tag_id":"cmfja9lpk00074e4p230y3gcq","_id":"cmfja9lq9003n4e4phn5z23ps"},{"post_id":"cmfja9lq100224e4p61pl7j9i","tag_id":"cmfja9lq8003d4e4patkhfbln","_id":"cmfja9lqa003q4e4phy9xaphh"},{"post_id":"cmfja9lq100224e4p61pl7j9i","tag_id":"cmfja9lq9003l4e4phct87e2a","_id":"cmfja9lqa003r4e4p2esj8for"},{"post_id":"cmfja9lq100224e4p61pl7j9i","tag_id":"cmfja9lpk00074e4p230y3gcq","_id":"cmfja9lqa003t4e4pcdw1f7ha"},{"post_id":"cmfja9lq100224e4p61pl7j9i","tag_id":"cmfja9lq9003o4e4p71wz0g8r","_id":"cmfja9lqa003u4e4phx658d75"},{"post_id":"cmfja9lq200254e4p86hb02kj","tag_id":"cmfja9lq8003d4e4patkhfbln","_id":"cmfja9lqa003x4e4pa1pn7gie"},{"post_id":"cmfja9lq200254e4p86hb02kj","tag_id":"cmfja9lq9003l4e4phct87e2a","_id":"cmfja9lqa003y4e4p6edndohg"},{"post_id":"cmfja9lq200254e4p86hb02kj","tag_id":"cmfja9lpk00074e4p230y3gcq","_id":"cmfja9lqb00404e4p1qmdhsvg"},{"post_id":"cmfja9lq200254e4p86hb02kj","tag_id":"cmfja9lq9003o4e4p71wz0g8r","_id":"cmfja9lqb00414e4phak33bo6"},{"post_id":"cmfja9lq300284e4pen49aihh","tag_id":"cmfja9lq8003d4e4patkhfbln","_id":"cmfja9lqb00444e4pdekn3eaz"},{"post_id":"cmfja9lq300284e4pen49aihh","tag_id":"cmfja9lq9003l4e4phct87e2a","_id":"cmfja9lqb00454e4phuqj4ylj"},{"post_id":"cmfja9lq300284e4pen49aihh","tag_id":"cmfja9lpk00074e4p230y3gcq","_id":"cmfja9lqb00474e4pbc7mf82f"},{"post_id":"cmfja9lq300284e4pen49aihh","tag_id":"cmfja9lq9003o4e4p71wz0g8r","_id":"cmfja9lqb00484e4p249o41h8"},{"post_id":"cmfja9lq3002a4e4pfas86woq","tag_id":"cmfja9lq8003d4e4patkhfbln","_id":"cmfja9lqc004b4e4p4ng5gpa0"},{"post_id":"cmfja9lq3002a4e4pfas86woq","tag_id":"cmfja9lq9003l4e4phct87e2a","_id":"cmfja9lqc004c4e4pb2da9ka2"},{"post_id":"cmfja9lq3002a4e4pfas86woq","tag_id":"cmfja9lpk00074e4p230y3gcq","_id":"cmfja9lqc004d4e4p2loi78h1"},{"post_id":"cmfja9lq3002a4e4pfas86woq","tag_id":"cmfja9lq9003o4e4p71wz0g8r","_id":"cmfja9lqc004e4e4pdit0dxcb"},{"post_id":"cmfja9lq3002a4e4pfas86woq","tag_id":"cmfja9lqb004a4e4p9aff4sx1","_id":"cmfja9lqc004f4e4p9kcs8sz6"},{"post_id":"cmfja9lqd004g4e4p7mir0p5q","tag_id":"cmfja9lq8003d4e4patkhfbln","_id":"cmfja9lqd004i4e4p3sc0ctec"},{"post_id":"cmfja9lqd004g4e4p7mir0p5q","tag_id":"cmfja9lq9003l4e4phct87e2a","_id":"cmfja9lqd004k4e4p8jp1hdow"},{"post_id":"cmfja9lqd004g4e4p7mir0p5q","tag_id":"cmfja9lpk00074e4p230y3gcq","_id":"cmfja9lqe004m4e4p2zvq72x5"},{"post_id":"cmfja9lqd004g4e4p7mir0p5q","tag_id":"cmfja9lq9003o4e4p71wz0g8r","_id":"cmfja9lqe004o4e4pg57p8jo8"},{"post_id":"cmfja9lqd004h4e4pb5ri120j","tag_id":"cmfja9lq8003d4e4patkhfbln","_id":"cmfja9lqe004p4e4pc516g9zo"},{"post_id":"cmfja9lqd004h4e4pb5ri120j","tag_id":"cmfja9lqd004j4e4p7n3z8xq8","_id":"cmfja9lqe004q4e4perql78s7"},{"post_id":"cmfja9lqd004h4e4pb5ri120j","tag_id":"cmfja9lq9003l4e4phct87e2a","_id":"cmfja9lqe004r4e4phobvdysu"},{"post_id":"cmfja9lqd004h4e4pb5ri120j","tag_id":"cmfja9lpk00074e4p230y3gcq","_id":"cmfja9lqe004s4e4p8jim55or"}],"Tag":[{"name":"C++","_id":"cmfja9lpk00074e4p230y3gcq"},{"name":"测试","_id":"cmfja9lpo000i4e4p7u3chzsv"},{"name":"string","_id":"cmfja9lpq000n4e4pbb71hipc"},{"name":"实用代码","_id":"cmfja9lpr000u4e4p5p456zww"},{"name":"文件操作","_id":"cmfja9lpt000z4e4p6cf50qn2"},{"name":"算法","_id":"cmfja9lpw001c4e4p5no02iqo"},{"name":"排序","_id":"cmfja9lpx001j4e4p32m7h3lp"},{"name":"epoll","_id":"cmfja9lpz001q4e4pfvpxehx2"},{"name":"socket","_id":"cmfja9lq0001x4e4pfp8m3ixi"},{"name":"Linux","_id":"cmfja9lq200244e4p6vge7gyu"},{"name":"IO多路复用","_id":"cmfja9lq300294e4pafligqi0"},{"name":"网络协议","_id":"cmfja9lq4002d4e4pbv0lau4b"},{"name":"并发","_id":"cmfja9lq700304e4phiufcioo"},{"name":"C","_id":"cmfja9lq800354e4pbjx0gfm2"},{"name":"对象模型","_id":"cmfja9lq8003a4e4pb8iy8wa3"},{"name":"数据结构","_id":"cmfja9lq8003d4e4patkhfbln"},{"name":"堆","_id":"cmfja9lq9003g4e4p6hqz6itb"},{"name":"优先级队列","_id":"cmfja9lq9003h4e4pbd2u017u"},{"name":"二叉树","_id":"cmfja9lq9003l4e4phct87e2a"},{"name":"树","_id":"cmfja9lq9003o4e4p71wz0g8r"},{"name":"完全N叉树","_id":"cmfja9lqb004a4e4p9aff4sx1"},{"name":"红黑树","_id":"cmfja9lqd004j4e4p7n3z8xq8"}]}}