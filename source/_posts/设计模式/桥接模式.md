---
title: 设计模式之桥接模式
date: 2025-09-13
tags: [设计模式, Cpp]
categories: 设计模式
---

### 桥接模式

桥接模式(`Bridge Pattern`)是一种**结构型设计模式**，它将抽象部分与其实现部分分离，使它们都可以独立变化。这种模式有时也被称作**柄体`(Handle and Body)`模式**或**接口隔离模式**。它的**主要目的是将抽象层与实现层解耦，使得两者可以独立扩展而互不影响**。核心是**委托**：将对自己的调用委托给其他对象。

```cpp
/** 
 * Implementation类 定义了所有 Implementation类 的子类的接口。它不需要匹配 Abstraction 类的接口。
 * 其实两接口可以完全不同。
 * 通常，Implementation类 接口只提供原始操作，而 Abstraction类 定义了更高的--基于这些原语的级别操作。
 */

class Implementation {
public:
    virtual ~Implementation() {}
    virtual std::string OperationImplementation() const = 0;
};

// 具体实现 （Concrete Implementations） 中包括特定于平台的代码

class ConcreteImplementationA : public Implementation {
public:
    std::string OperationImplementation() const override {
        return "ConcreteImplementationA: Here's the result on the platform A.\n";
    }
};

class ConcreteImplementationB : public Implementation {
public:
    std::string OperationImplementation() const override {
        return "ConcreteImplementationB: Here's the result on the platform B.\n";
    }
};

// Abstraction类 定义了“控制”部分的接口。它管理着一个指向Implementation类对象的引用，并会将所有真实工作委派给该对象。

class Abstraction {
    /**
     * @var Implementation
     */
protected:
    Implementation *implementation_;

public:
    Abstraction(Implementation *implementation) :
        implementation_(implementation) {}

    virtual ~Abstraction() {}

    virtual std::string Operation() const {
        return "Abstraction: Base operation with:\n" +
               this->implementation_->OperationImplementation();
    }
};

class ExtendedAbstraction : public Abstraction {
public:
    ExtendedAbstraction(Implementation *implementation) :
        Abstraction(implementation) {}

    std::string Operation() const override {
        return "ExtendedAbstraction: Extended operation with:\n" +
               this->implementation_->OperationImplementation();
    }
};

void ClientCode(const Abstraction &abstraction) {
    // ...
    std::cout << abstraction.Operation();
    // ...
}

int main() {
    Implementation *implementation = new ConcreteImplementationA;
    Abstraction *abstraction = new Abstraction(implementation);
    ClientCode(*abstraction);
    std::cout << std::endl;
    delete implementation;
    delete abstraction;

    implementation = new ConcreteImplementationB;
    abstraction = new ExtendedAbstraction(implementation);
    ClientCode(*abstraction);

    delete implementation;
    delete abstraction;

    return 0;
}
```

